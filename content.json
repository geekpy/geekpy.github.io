{"meta":{"title":"Geekpy's Blog","subtitle":null,"description":null,"author":"geekpy","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-08-12T03:45:00.000Z","updated":"2018-08-12T03:45:39.672Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I’m geekpy"}],"posts":[{"title":"史上最详解Python日期和时间处理（上）","slug":"python_time","date":"2018-08-12T03:52:56.000Z","updated":"2018-08-12T06:19:17.377Z","comments":true,"path":"2018/08/12/python_time/","link":"","permalink":"http://yoursite.com/2018/08/12/python_time/","excerpt":"好吧，我承认这有标题党的嫌疑，不过看了那么多文章，的确没有找到一篇让我满意的关于日期和时间处理的详解文章，于是决心自己动手亲写一篇，希望能对得起这个霸气的标题。言归正传，在Python编程中，日期和时间处理是非常繁琐的一块，不仅概念众多，且有很多不同的module, 尤其涉及时区处理的时候会将问题进一步复杂化。本文将对Python在日期和时间处理上进行一步步详细讲解，总共会分为上下两篇，其中时区处理是较为棘手的一块内容，单独拿出来作为下篇。此上篇将主要讲解时间和日期处理中的基本概念，和常用的场景。","text":"好吧，我承认这有标题党的嫌疑，不过看了那么多文章，的确没有找到一篇让我满意的关于日期和时间处理的详解文章，于是决心自己动手亲写一篇，希望能对得起这个霸气的标题。言归正传，在Python编程中，日期和时间处理是非常繁琐的一块，不仅概念众多，且有很多不同的module, 尤其涉及时区处理的时候会将问题进一步复杂化。本文将对Python在日期和时间处理上进行一步步详细讲解，总共会分为上下两篇，其中时区处理是较为棘手的一块内容，单独拿出来作为下篇。此上篇将主要讲解时间和日期处理中的基本概念，和常用的场景。本篇目录如下： 时间和日期的表示 时间、日期对象 时间戳 日期时间字符串 日期时间处理场景 获取当前时间 获取特定时间 不同时间表示的转化 时间和日期的表示在Python中表示日期和时间，最基本的有三种形式： 时间、日期对象(Object) 时间戳(Timestamp) 字符串(String) 在这三种基本形式中又会衍生出一些其它的概念，下面来分别讲解下： 先看张脑图来理清它们之间的关系 时间、日期对象Python中用于表示日期和时间的对象有很多种，在详细讲解这些对象之前先要明确一个概念，即这些对象都分为两种：一种是”原始的(naive)”，另一种是”有知的(aware)”。区别在于原始的时间没有时区概念，只是单纯的表示一个日期和时间，而有知的时间会包含一些额外信息，如时区，是否夏令时等信息，而这些信息会通过tzinfo子类来进行封装，我们将在（下）中详细讲解。 datetime对象：这个是最常用的日期时间对象，可以即表示日期又表示时间。datetime对象可以直接用于日期和时间相关的计算（比如计算5天之前的时间）。另外，datetime既可以表示原始时间，也可以表示有知时间，如果要表示有知时间，则在初始化时需要传递tzinfo类型的参数。 12345678In [16]: import datetimeIn [17]: datetime.datetime.now() # 返回一个datetime对象Out[17]: datetime.datetime(2018, 7, 28, 11, 17, 38, 972555)# 也可以直接初始化一个datetime对象In [20]: datetime.datetime(2018, 7, 5, 10, 20)Out[20]: datetime.datetime(2018, 7, 5, 10, 20) time对象：与datetime类似，但只用于表示时间，不表示日期 123# 这里初始化一个datetime.time对象用于表示时间11点28分05秒In [19]: datetime.time(11, 28, 5)Out[19]: datetime.time(11, 28, 5) date对象：与datetime类似，但只表示日期，不表示时间 12In [23]: datetime.date(2018, 07, 10)Out[23]: datetime.date(2018, 7, 10) time tuple: time tuple又叫struct time，是一种用于表示日期和时间的数据结构，此数据结构主要用于time module中的相关函数。time tuple中有9个元素，如下表所示： 索引（Index）| 属性（Attribute）| 值（Values）—|—-|—-0 | tm_year（年）| 比如20111 | tm_mon（月）| 1 - 122 | tm_mday（日）| 1 - 313 | tm_hour（时）| 0 - 234 | tm_min（分）| 0 - 595 | tm_sec（秒）| 0 - 616 | tm_wday（weekday）| 0 - 6（0表示周日）7 | tm_yday（一年中的第几天）| 1 - 3668 | tm_isdst（是否是夏令时） | 默认为-1 1234In [21]: import timeIn [22]: time.localtime() # 返回一个time tuple用于表示当前时间的local timeOut[22]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=11, tm_min=26, tm_sec=19, tm_wday=5, tm_yday=209, tm_isdst=0) 总结：以上前三个对象(datetime, date, time)均来自datetime module（注意区分datetime module和datetime 对象），而最后一个time tuple主要用于time module中的相关操作。 时间戳时间戳(Timestamp)是表示当前时间距离元年时间(epoch, 1970年1月1日00:00:00 UTC)的偏移量，这个偏移量在Python中用秒数来计算，但有些编程语言如JavaScript是用毫秒来计算的，需要注意。另外需要知道时间戳没有时区概念，是不分时区的。这就是为什么我们在数据库中通常存储的是时间戳，当需要向用户显示时间的时候，再转化为对应时区的时间。 123# 获取当前时间的时间戳In [24]: time.time()Out[24]: 1532750668.210267 日期时间字符串通常在需要向用户展示时间的时候，我们都需要将时间戳或者时间对象转化为字符串形式，从而在标准输出中能够打印出相应的时间。我们可以通过将时间戳或者对象进行转化和格式化来得到相应的字符串。需要说明的是，字符串表示时间有一个标准形式称为ISO8601，可以通过专门的函数来获得。 123456789In [29]: dt = datetime.datetime.now()# 获取ISO8601标准时间字符串In [30]: dt.isoformat()Out[30]: &apos;2018-07-28T12:11:33.582380&apos;# 自定义格式的时间字符串In [31]: dt.strftime(&quot;%Y%m%d-%H:%M:%S&quot;)Out[31]: &apos;20180728-12:11:33&apos; 日期时间处理场景时间处理主要有以下几个场景： 获取当前时间 获取特定时间：例如获取5天前的时间。 不同时间表示的转化：例如将datetime对象转化为时间字符串 时区处理：这个将在《下篇》中详细讲述 下面分别介绍下这几种处理场景： 获取当前时间获取当前时间可以通过获取datetime对象、时间戳或time tuple三种方式来获取。 1234567891011121314151617181920# 最常用的获取当前日期时间的方法，其有一个tz参数用于设置时区，默认为None，所以最终获取的是一个原始naive时间In [36]: dt = datetime.datetime.now()# 注意获取的是当地时间的时间表示，但其本身是一个原始naive时间In [37]: dtOut[37]: datetime.datetime(2018, 7, 28, 12, 58, 57, 676468)# 获取当前时间的UTC时间表示，注意这仍然是一个原始naive时间，也就是用当前的UTC时间4点59分32秒来构造一个naive时间对象，但这个对象并没有包含时区信息In [38]: utc_now = datetime.datetime.utcnow()In [39]: utc_nowOut[39]: datetime.datetime(2018, 7, 28, 4, 59, 32, 258087)# 获取当前时间的时间戳In [40]: time.time()Out[40]: 1532753948.563503# 获取当地时间的time tupleIn [41]: time.localtime()Out[41]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=13, tm_min=0, tm_sec=2, tm_wday=5, tm_yday=209, tm_isdst=0) 获取特定时间1234567891011121314In [42]: dtOut[42]: datetime.datetime(2018, 7, 28, 12, 58, 57, 676468)# 获取两天前的时间In [43]: dt - datetime.timedelta(days=2)Out[43]: datetime.datetime(2018, 7, 26, 12, 58, 57, 676468)# 获取一周前的时间In [44]: dt - datetime.timedelta(weeks=1)Out[44]: datetime.datetime(2018, 7, 21, 12, 58, 57, 676468)# 获取3小时前的时间In [45]: dt - datetime.timedelta(hours=3)Out[45]: datetime.datetime(2018, 7, 28, 9, 58, 57, 676468) 通过timedelta基本可以满足我们获取特定时间的需求，但是这里不涉及时区相关的转化。而且只是原始naive时间之间的转化 不同时间表示的转化先来看一张关系图： 从上图可以看出总共有5对关系，每对关系都是可以双向转化的(除timetuple无法直接转化为datetime，需要先转化为timestamp或者time string)，所以总共有9种转化，下面将分别介绍下它们之间是如何互相转化的。 datetime object &amp; timestamp从时间戳timestamp ==&gt; datetime object1234567891011121314151617181920In [2]: import timeIn [3]: from datetime import datetimeIn [4]: ts = time.time()# 直接通过fromtimestamp就可以获得时间戳对应的datetime对象In [5]: dt = datetime.fromtimestamp(ts)In [6]: tsOut[6]: 1532775234.192805# 注意这个datetime对象获取的是本地时间的表示，但是仍然是原始naive timeIn [7]: dtOut[7]: datetime.datetime(2018, 7, 28, 18, 53, 54, 192805)# 获取对应utc的时间表示，仍然是原始naive时间In [11]: utc_dt = datetime.utcfromtimestamp(ts)In [12]: utc_dtOut[12]: datetime.datetime(2018, 7, 28, 10, 53, 54, 192805) 从datetime object ==&gt;时间戳timestamp12345678910111213141516171819# 定义一个函数用于返回datetime object对应的时间戳In [8]: def get_timestamp(datetime_obj): ...: if not isinstance(datetime_obj, datetime): ...: raise ValueError() ...: return (datetime_obj - datetime(1970, 1, 1)).total_seconds() ...:In [9]: get_timestamp(dt)Out[9]: 1532804034.192805# 也可以先转化为time tuple，再通过mktime函数转化为timestamp，但是精度不如上一版高In [13]: def get_timestamp_v2(datetime_obj): ...: if not isinstance(datetime_obj, datetime): ...: raise ValueError() ...: return time.mktime(datetime_obj.timetuple()) ...:In [14]: get_timestamp_v2(dt)Out[14]: 1532775234.0 datetime object &amp; time stringdatetime object ==&gt; time string关于格式化的说明可以参考官网文档12345678910In [15]: dtOut[15]: datetime.datetime(2018, 7, 28, 18, 53, 54, 192805)# 自定义格式In [16]: dt.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)Out[16]: &apos;2018-07-28T18:53:54&apos;# 转化为ISO8601格式字符串的快捷方式In [17]: dt.isoformat()Out[17]: &apos;2018-07-28T18:53:54.192805&apos; time string ==&gt; datetime object123456In [18]: time_str = &apos;2018-07-28T18:53:54&apos;In [19]: dt2 = datetime.strptime(time_str, &quot;%Y-%m-%dT%H:%M:%S&quot;)In [20]: dt2Out[20]: datetime.datetime(2018, 7, 28, 18, 53, 54) datetime object &amp; time tupledatetime object ==&gt; time tuple12In [21]: dt.timetuple()Out[21]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=-1) time tuple ==&gt; datetime object无法直接转化，需要先转化为time str或者timestamp time tuple &amp; timestamptime tuple ==&gt; timestamp12345678In [25]: time_tupleOut[25]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=-1)# 注意：该函数精度只能到秒In [26]: ts = time.mktime(time_tuple)In [27]: tsOut[27]: 1532775234.0 timestamp ==&gt; time tuple1234567891011121314In [27]: tsOut[27]: 1532775234.0# 转为本地时间的time tuple表示，In [29]: tt = time.localtime(ts)In [30]: ttOut[30]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=0)# 转为UTC时间的time tuple表示In [31]: utc_tt = time.gmtime(ts)In [32]: utc_ttOut[32]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=10, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=0) time tuple &amp; time stringtime tuple ==&gt; time string123456789101112131415In [33]: ttOut[33]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=0)# 注意：这里strftime并非time tuple的方法，而是time module下的函数In [34]: tt.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-34-1be0f512fc77&gt; in &lt;module&gt;()----&gt; 1 tt.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)AttributeError: &apos;time.struct_time&apos; object has no attribute &apos;strftime&apos;# 如下是正解In [35]: time.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;, tt)Out[35]: &apos;2018-07-28T18:53:54&apos; time string ==&gt; time tuple1234567In [36]: time_strOut[36]: &apos;2018-07-28T18:53:54&apos;In [37]: tt = time.strptime(time_str, &quot;%Y-%m-%dT%H:%M:%S&quot;)In [38]: ttOut[38]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=-1) timestamp &amp; time string无法相互转化，只能通过先转化为datetime object或者time tuple之后才能再转化 References time module document datetime module document 10 things you need to know about Date and Time in Python PYTHON-基础-时间日期处理小结","categories":[],"tags":[]},{"title":"在Flask中使用Celery的最佳实践","slug":"flask_celery","date":"2018-02-22T10:18:18.000Z","updated":"2018-08-12T05:54:49.367Z","comments":true,"path":"2018/02/22/flask_celery/","link":"","permalink":"http://yoursite.com/2018/02/22/flask_celery/","excerpt":"主要是笔者在项目实践中总结的关于Celery使用的一些最佳实践，欢迎补充","text":"主要是笔者在项目实践中总结的关于Celery使用的一些最佳实践，欢迎补充 写在前面本最佳实践是基于作者有限的经验，欢迎大家共同讨论，可以持续维护此最佳实践。另本文中所使用的环境为Mac&amp;Ubuntu环境，软件版本如下： Celery (4.1.0) Flask (0.12.1) RabbitMQ(3.6.9) librabbitmq (1.6.1) 介绍简单来说Celery是一个异步的任务队列，当我们需要将一些任务(比如一些需要长时间操作的任务)异步操作的时候，这时候Celery就可以帮到我们，另外Celery还支持定时任务(类似Crontab)。详细的介绍可以参考官网 使用RabbitMQ作为BrokerRabbitMQ是官方推荐使用的Broker，它实际是一个消息中间件，负责消息的路由分发，安装RabbitMQ如下：123# install on Ubuntuapt-get updateapt-get install rabbitmq-server -yq 需要注意的是，线上环境我们需要创建新的账号，并将guest账号删除，操作如下：1234rabbitmqctl add_user myuser mypassword # 新增用户rabbitmqctl add_vhost myvhost # 新增vhost，以使用不同的命名空间rabbitmqctl set_permissions -p myvhost myuser &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; # 设置权限rabbitmqctl delete_user guest # 安全原因，删除guest 注意：vhost是一个虚拟空间，用于区分不同类型的消息然后，在Celery的配置中配置broker URL1CELERY_BROKER_URL = &apos;amqp://myuser:mypassword@localhost:5672/myvhost&apos; 注意：当使用amqp协议头时，如果安装有librabbitmq则使用librabbitmq，否则使用pyamqp Celery的日志输出在task中想要输出日志，最好的方法是通过如下方式1234567from celery.utils.log import get_task_loggerlg = get_task_logger(__name__)@celery.taskdef log_test(): lg.debug(&quot;in log_test()&quot;) 但是仅如此会发现所有的日志最后都跑到shell窗口的stdout当中，原来必须得在启动celery的时候使用-f option来指定输出文件，如下：1celery -A main.celery worker -l debug -f log/celery/celery_task.log &amp; -A：指定celery实例worker: 启动worker进程-l：指定log level，这里指定log level为debug level-f：指定输出的日志文件 使用Redis作为backend当使用Redis作为存储后端的时候，我们可以通过设置DB number来使得Celery的结果存储与其它数据存储隔离开来，比如在笔者的项目中，redis还用作缓存的存储后端，因此为了区分，Celery在使用Redis的时候使用的DB number是1（默认是0），关于Redis DB number可以参考这里.因此我们的backend设置如下：1CELERY_RESULT_BACKEND = &apos;redis://localhost:6379/1&apos; # 最后的数字1代表DB number 查看Celery任务的结果可以通过Redis-cli连接Redis数据库进行查看123&gt; redis-cli&gt; select 1 # 这里选择DB 1， 也可以在使用redis-cli -n 1来进入指定的DB&gt; get key # 获取指定key对应的结果 调试代码我认为此处是非常重要的一个技巧，即在调试代码的时候，我们可以将delay或者apply_async先去掉，直接调用worker的函数进行同步调试，调试成功后再加上delay或者apply_async method Celery可能会遇到的坑Celery4.x版本使用librabbitmq的问题Celery 4.x版本在使用librabbitmq时，会出现类似这样的错误1Received and deleted unknown message. Wrong destination?!? 完整错误如图： 解决这个问题有两个方式： 推荐方式，更改配置项task_protocol为1。Github上Robert Kopaczewski详细解释了这个问题，原文如下： Apparently librabbitmq issue is related to new default protocol in celery 4.x. You can switch to previous protocol version by either putting CELERY_TASK_PROTOCOL = 1 in your settings if you’re using Django or settings app.conf.task_protocol = 1 in celeryconf.py. 另一种方式是不使用librabbitmq, 通过pip uninstall librabbitmq, 并且更改broker配置的协议头为’pyamqp’,如下，也可以解决这个问题。 1BROKER_URL = &apos;pyamqp://guest:guest@localhost:5672/%2F&apos; 由于librabbitmq的性能优势，我们还是推荐方式1来解决该问题。 RabbitMQ远程连接问题如果RabbitMQ与Celery不在同一台机器上，除在Celery配置的时候要将BROKER_URL设置为正确的IP地址外，还需要将Rabbitmq的配置文件/usr/local/etc/rabbitmq/rabbitmq-env.conf中的NODE_IP_ADDRESS更改为0.0.0.01NODE_IP_ADDRESS=0.0.0.0 Celery import问题123456789101112131415The message has been ignored and discarded.Did you remember to import the module containing this task?Or maybe you&apos;re using relative imports?Please seehttp://docs.celeryq.org/en/latest/internals/protocol.htmlfor more information.The full contents of the message body was:&apos;\\x8e\\xa7expires\\xc0\\xa3utc\\xc3\\xa4args\\x91\\x85\\xa3tid\\xb85971a43d47f84bb278f77fc2\\xa3sen\\xa2A1\\xa2tt\\xa2ar\\xa2co\\xc4\\x00\\xa1t\\xa4like\\xa5chord\\xc0\\xa9callbacks\\xc0\\xa8errbacks\\xc0\\xa7taskset\\xc0\\xa2id\\xc4$c133dbf8-2c89-4311-b7cf-c377041058ec\\xa7retries\\x00\\xa4task\\xd9$tasks.messageTasks.send_like_message\\xa5group\\xc0\\xa9timelimit\\x92\\xc0\\xc0\\xa3eta\\xc0\\xa6kwargs\\x80&apos; (239b)Traceback (most recent call last): File &quot;/Users/liufeng/.pyenv/versions/2.7.13/envs/kaopu_backend/lib/python2.7/site-packages/celery/worker/consumer/consumer.py&quot;, line 561, in on_task_received strategy = strategies[type_]KeyError: u&apos;tasks.messageTasks.send_like_message&apos; 出现这条错误是由于我们的tasks跟celery并不是在同一个文件中，即不是同一个module，当我们通过如下命令启动task worker时，实际只加载了app module，而没有加载tasks相关的module12celery -A app.celery worker -l info` 要解决这个问题，必须为celery配置文件添加import参数，如下1app.config[&apos;imports&apos;] = [&apos;tasks.messageTasks&apos;] Celery unregistered task问题在开发过程中遇到了这样一个问题12345678910111213141516[2017-08-31 15:38:19,605: ERROR/MainProcess] Received unregistered task of type u&apos;app.tasks.messageTasks.send_follow_message&apos;.The message has been ignored and discarded.Did you remember to import the module containing this task?Or maybe you&apos;re using relative imports?Please seehttp://docs.celeryq.org/en/latest/internals/protocol.htmlfor more information.The full contents of the message body was:&apos;\\x8e\\xa7expires\\xc0\\xa3utc\\xc3\\xa4args\\x91\\x86\\xa6sender\\xa5Jenny\\xa9target_id\\xb859a5313847f84be534ad7d46\\xabtarget_type\\xa4user\\xa7content\\xc4\\x00\\xa8receiver\\xb859a5313847f84be534ad7d46\\xa4type\\xa6follow\\xa5chord\\xc0\\xa9callbacks\\xc0\\xa8errbacks\\xc0\\xa7taskset\\xc0\\xa2id\\xc4$a4d40c14-1976-41a6-a753-d2a495929920\\xa7retries\\x00\\xa4task\\xd9*app.tasks.messageTasks.send_follow_message\\xa5group\\xc0\\xa9timelimit\\x92\\xc0\\xc0\\xa3eta\\xc0\\xa6kwargs\\x80&apos; (312b)Traceback (most recent call last): File &quot;/Users/liufeng/.pyenv/versions/2.7.13/envs/kaopu_backend/lib/python2.7/site-packages/celery/worker/consumer/consumer.py&quot;, line 561, in on_task_received strategy = strategies[type_]KeyError: u&apos;app.tasks.messageTasks.send_follow_message&apos; 解决这个问题，最开始是根据提示，将所有涉及到task的module全部加上from __future__ import absolute_import 之后运行之后还是不行，后来发现是由于之前启动时使用的是app module， 但是我的代码已经改成了main.py，所以重新启动了celery，最后问题解决 使用镜像迁移系统也依然需要重新添加rabbitmq的用户问题最开始是发现无法点赞，也无法Follow用户，通过http消息发现出现502错误，于是登录到服务器检查，发现应用服务本身没有任何报错，于是又去查看Celery的日志，结果发现出现如下错误：1[2017-11-13 16:32:01,243: ERROR/MainProcess] consumer: Cannot connect to amqp://celeryuser:**@loc alhost:5672/celeryvhost: Couldn&apos;t log in: a socket error occurred. 经过一番搜索发现网上的评论主要是说URL不对的情况下会出现这种情况，但是我的URL没有改过啊，那又会是什么问题呢？继续看，发现有人提到了权限问题，于是又是一番检查，发现RabbitMQ中并没有原先设置的用户（我使用的是原系统的镜像，原以为用户也是已经设置好的）12# 查看有哪些用户rabbitmqctl list_users 然后就简单了，按照步骤创建用户，vhost，再赋予权限，删除guest，然后就终于都连好了 另外，发现从镜像复制系统后，RabbitMQ并不能正常工作，必须杀掉原先的进程，重新启动 更改task的代码后，重启Celery需要注意的是，在更改task的代码后，必须重新启动Celery，否则代码改动无法生效，可能导致一些意外的问题","categories":[],"tags":[]},{"title":"Flask-Login详解","slug":"Flask-Login","date":"2017-10-12T10:18:18.000Z","updated":"2018-08-12T06:06:52.332Z","comments":true,"path":"2017/10/12/Flask-Login/","link":"","permalink":"http://yoursite.com/2017/10/12/Flask-Login/","excerpt":"本文主要通过源码分析Flask-Login插件，并详述其使用方法","text":"本文主要通过源码分析Flask-Login插件，并详述其使用方法 关于Flask登录认证的详细过程请参见拙作&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;一文，而本文则偏重于详细介绍Flask-Login的原理，代码的解析。 首次登陆我们首先来看一下首次登录验证的流程图： Flask-Login在登录过程中主要负责： 将用户对象存入request context中 将用户ID，Session ID等信息存入Session中在&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;中我们已经介绍过如何通过Flask-Login来实现登录的过程，其中最重要的代码就是login_user，如下：1login_user(user, remember=remember_me) 那么login_user具体做了什么呢？我们来看下源码123456789101112131415def login_user(user, remember=False, force=False, fresh=True): if not force and not user.is_active: return False user_id = getattr(user, current_app.login_manager.id_attribute)() session[&apos;user_id&apos;] = user_id session[&apos;_fresh&apos;] = fresh session[&apos;_id&apos;] = current_app.login_manager._session_identifier_generator() if remember: session[&apos;remember&apos;] = &apos;set&apos; _request_ctx_stack.top.user = user user_logged_in.send(current_app._get_current_object(), user=_get_user()) return True getattr(user, current_app.login_manager.id_attribute)() 这里login_manager.id_attribute是一个字符串&#39;get_id&#39;。因此这句的意思是获取User对象的get_id method，然后执行，从而获取到用户的ID 通过session[&#39;user_id&#39;] = user_id来将用户的ID存储进Session当中，后面紧跟着将fresh信息，session id信息，remember信息存储进session。 注意：Flask的session是以cookie为基础，但是是在Server端使用secret key并使用AES之类的对称加密算法进行加密的，然后将加密后的cookie发送给客户端。由于是加密后的数据，客户端无法篡改数据，也无法获知session中的信息，只能保存该session信息，在之后的请求中携带该session信息 _request_ctx_stack.top.user = user这里是将user对象存储进当前的request context中，_request_ctx_stack是一个LocalStack对象，top属性指向的就是当前的request context。关于LocalStack及相关技术，请参考拙作&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt; user_logged_in.send(current_app._get_current_object(), user=_get_user()) 此句中user_logged_in是Flask-Login定义的signal，此处通过send来发射此signal，当注册监听此signal的回调函数收到此signal之后就会执行函数。这里send有两个参数，第一个参数是sender对象，此处通过current_app._get_current_object()来获取当前的app对象，即此signal的sender设为当前的应用；第二个参数是该signal携带的数据，此处将user对象做为signal的数据传递给相应的回调函数。关于signal的详细解释请参考拙作&lt;&gt;非首次登陆非首次登陆流程图如下： 在这个流程图中，Flask-Login主要起如下作用： 从session中获取用户ID 当用户的请求访问的是受登录保护的路由时，就要通过用户ID重新load user，如果load user失败则进入鉴权失败处理流程，如果成功，则允许正常处理请求那么Flask-Login究竟是如何保护路由的呢？我们来看个例子：123456@app.route(&apos;/&apos;)@app.route(&apos;/main&apos;)@login_requireddef main(): return render_template( &apos;main.html&apos;, username=current_user.username) 我们看到只要给路由函数加一个@login_required装饰器就可以了，那么这个装饰器究竟是怎么做到的呢？来看下源码：1234567891011121314151617# flask_login/utils.pydef login_required(func): @wraps(func) def decorated_view(*args, **kwargs): # 如果request method为例外method，即在EXEMPT_METHODS中的method，可以不必鉴权 if request.method in EXEMPT_METHODS: return func(*args, **kwargs) # 如果_login_disabled为True则不必鉴权 elif current_app.login_manager._login_disabled: return func(*args, **kwargs) # 正常鉴权 elif not current_user.is_authenticated: return current_app.login_manager.unauthorized() return func(*args, **kwargs) return decorated_view 默认情况下只有OPTIONS method在EXEMPT_METHODS set中，而GET、PUT、POST等常见的methods都需要鉴权 _login_disabled默认为False 正常鉴权的关键在于current_user.is_authenticated是否为True，为True则正常处理请求，为False则进入unauthorized处理流程。那么这个current_user到底怎么就能鉴权了？它是怎么来的呢？来看下定义：12# flask_login/utils.pycurrent_user = LocalProxy(lambda: _get_user()) 原来current_user是一个LocalProxy对象，其代理的对象需要通过_get_user()来获取，简单来说_get_user()会返回两种用户，一种是正常的用户对象(鉴权成功)，一种是anonymous用户对象(鉴权失败)。而正常的用户对象其is_authenticated属性总是为True，相对的anonymous用户对象的is_authenticated属性总是为False LocalProxy对象每次操作都会重新获取代理的对象从而实现动态更新，关于LocalProxy的详细说明请参考拙作&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt; 而要实现动态更新的关键就在于_get_user函数，接下来我们看下_get_user函数是如何获取user对象的：123456# flask_login/utils.pydef _get_user(): if has_request_context() and not hasattr(_request_ctx_stack.top, &apos;user&apos;): current_app.login_manager._load_user() return getattr(_request_ctx_stack.top, &apos;user&apos;, None) 在之前的首次登陆那小节中，我们已经知道用户鉴权成功后，会将User对象保存在当前的request context当中，这时我们调用_get_user函数时就会直接从request context中获取user对象return getattr(_request_ctx_stack.top, &#39;user&#39;, None)但如果是非首次登陆，当前request context中并没有保存user对象，就需要调用current_app.login_manager._load_user()来去load user对象，接下来再看看如何去load：1234567891011121314151617181920212223242526272829303132# flask_login/login_manager.pydef _load_user(self): &apos;&apos;&apos;Loads user from session or remember_me cookie as applicable&apos;&apos;&apos; user_accessed.send(current_app._get_current_object()) # first check SESSION_PROTECTION config = current_app.config if config.get(&apos;SESSION_PROTECTION&apos;, self.session_protection): deleted = self._session_protection() if deleted: return self.reload_user() # If a remember cookie is set, and the session is not, move the # cookie user ID to the session. # # However, the session may have been set if the user has been # logged out on this request, &apos;remember&apos; would be set to clear, # so we should check for that and not restore the session. is_missing_user_id = &apos;user_id&apos; not in session if is_missing_user_id: cookie_name = config.get(&apos;REMEMBER_COOKIE_NAME&apos;, COOKIE_NAME) header_name = config.get(&apos;AUTH_HEADER_NAME&apos;, AUTH_HEADER_NAME) has_cookie = (cookie_name in request.cookies and session.get(&apos;remember&apos;) != &apos;clear&apos;) if has_cookie: return self._load_from_cookie(request.cookies[cookie_name]) elif self.request_callback: return self._load_from_request(request) elif header_name in request.headers: return self._load_from_header(request.headers[header_name]) return self.reload_user() _load_user大体的过程是首先检查SESSION_PROTECTION设置，如果SESSION_PROTECTION 为strong或者basic类型，那么就会执行_session_protection()动作，否则不执行此操作。_session_protection在session_id不一致的时候(比如IP变化会导致session id的变化)才真正有用，这时，如果为basic类型或者session permanent为True时，只标注session为非新鲜的(not fresh)；而如果为strong，则会删除session中的用户信息，并重新load user，即调用reload_user。 session permanent为True时，用户退出浏览器不会删除session，其会保留permanent_session_lifetime s(默认是31天)，但是当其为False且SESSION_PROTECTION 设为strong时，用户的session就会被删除。 接下来的代码是说当session中没有用户信息时(这里通过是否能获取到user_id来判断)，如果有则直接reload_user,如果没有，则有三种方式来load user，一种是通过remember cookie，一种通过request，一种是通过request header，依次尝试。 remember cookie是指，当用户勾选’remember me’复选框时，Flask-Login会将用户信息放入到指定的cookie当中，同样也是加密的。这就是为什么当session中没有携带用户信息时，我们可以通过remember cookie来获取用户的信息 而reload_user是如何获取用户的呢，来看下源代码：1234567891011121314151617181920212223# flask_login/login_manager.pydef reload_user(self, user=None): ctx = _request_ctx_stack.top if user is None: user_id = session.get(&apos;user_id&apos;) if user_id is None: # 当无法获取到有效的用户id时，就认为是anonymous user ctx.user = self.anonymous_user() else: # user callback就是我们通过@login_manager.user_loader装饰的函数，用于获取user object if self.user_callback is None: raise Exception( &quot;No user_loader has been installed for this &quot; &quot;LoginManager. Add one with the &quot; &quot;&apos;LoginManager.user_loader&apos; decorator.&quot;) user = self.user_callback(user_id) if user is None: ctx.user = self.anonymous_user() else: ctx.user = user else: ctx.user = user 首先获取user id，如果获取不到有效的id，就将user设为anonymous user 获取到id后，再通过@login_manager.user_loader装饰的函数获取到user对象，如果没有获取到有效的user对象，就认为是anonymous user 最后将user保存于request context中（无论是正常的用户还是anonymous用户） 至此，我们已经将Flask-Login的核心代码剖析了一遍，如果你有收获，不妨点个赞鼓励一下吧！","categories":[],"tags":[]},{"title":"Werkzeug(Flask)之Local、LocalStack和LocalProxy","slug":"Werkzeug-Local","date":"2017-10-08T10:18:18.000Z","updated":"2018-08-12T05:29:42.840Z","comments":true,"path":"2017/10/08/Werkzeug-Local/","link":"","permalink":"http://yoursite.com/2017/10/08/Werkzeug-Local/","excerpt":"","text":"在我们使用Flask以及Werkzeug框架的过程中，经常会遇到如下三个概念：Local、LocalStack和LocalProxy。尤其在学习Flask的Request Context和App Context的过程中，这几个概念出现的更加频繁，另外很多Flask插件都会使用这三个概念对应的技术。那么这三个东西到底是什么？我们为什么需要它们？以及如何使用呢？本篇文章主要就是来解答这些问题。 Local这部分我们重点介绍Local概念，主要分为以下几个部分： 为什么需要Local？ Local的使用 Local的实现为什么需要Local？在Python的标准库中提供了thread local对象用于存储thread-safe和thread-specific的数据，通过这种方式存储的数据只在本线程中有效，而对于其它线程则不可见。正是基于这样的特性，我们可以把针对线程全局的数据存储进thread local对象，举个简单的例子12345&gt;&gt;from threading import local&gt;&gt;thread_local_data = local()&gt;&gt;thread_local_data.user_name=&quot;Jim&quot;&gt;&gt;thread_local_data.user_name&apos;Jim&apos; 使用thread local对象虽然可以基于线程存储全局变量，但是在Web应用中可能会存在如下问题： 有些应用使用的是greenlet协程，这种情况下无法保证协程之间数据的隔离，因为不同的协程可以在同一个线程当中。 即使使用的是线程，WSGI应用也无法保证每个http请求使用的都是不同的线程，因为后一个http请求可能使用的是之前的http请求的线程，这样的话存储于thread local中的数据可能是之前残留的数据。 为了解决上述问题，Werkzeug开发了自己的local对象，这也是为什么我们需要Werkzeug的local对象 Local的使用先举一个简单的示例：1234567891011from werkzeug.local import Local, LocalManagerlocal = Local()local_manager = LocalManager([local])def application(environ, start_response): local.request = request = Request(environ) ...# make_middleware会确保当request结束时，所有存储于local中的对象的reference被清除application = local_manager.make_middleware(application) 首先Local对象需要通过LocalManager来管理，初次生成LocalManager对象需要传一个list类型的参数，list中是Local对象，当有新的Local对象时，可以通过local_manager.locals.append()来添加。而当LocalManager对象清理的时候会将所有存储于locals中的当前context的数据都清理掉 上例中当local.request被赋值之后，其可以在当前context中作为全局数据使用 所谓当前context(the same context)意味着是在同一个greenlet(如果有)中，也就肯定是在同一个线程当中 那么Werkzeug的Local对象是如何实现这种在相同的context环境下保证数据的全局性和隔离性的呢？ Local的实现我们先来看下源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 在有greenlet的情况下，get_indent实际获取的是greenlet的id，而没有greenlet的情况下获取的是thread idtry: from greenlet import getcurrent as get_identexcept ImportError: try: from thread import get_ident except ImportError: from _thread import get_identclass Local(object): __slots__ = (&apos;__storage__&apos;, &apos;__ident_func__&apos;) def __init__(self): object.__setattr__(self, &apos;__storage__&apos;, &#123;&#125;) object.__setattr__(self, &apos;__ident_func__&apos;, get_ident) def __iter__(self): return iter(self.__storage__.items()) # 当调用Local对象时，返回对应的LocalProxy def __call__(self, proxy): &quot;&quot;&quot;Create a proxy for a name.&quot;&quot;&quot; return LocalProxy(self, proxy) # Local类中特有的method，用于清空greenlet id或线程id对应的dict数据 def __release_local__(self): self.__storage__.pop(self.__ident_func__(), None) def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; def __delattr__(self, name): try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) 这段代码实际是对__storage__ dict的封装，而这个dict中的key使用的就是get_indent函数获取的id（当有greenlet时使用greenlet id，没有则使用thread id） __storage__ dict中的value也是一个dict，这个dict就是该greenlet(或者线程)对应的local存储空间 通过重新实现__getattr__, __setattr__等魔术方法，我们在greenlet或者线程中使用local对象时，实际会自动获取greenlet id(或者线程id)，从而获取到对应的dict存储空间，再通过name key就可以获取到真正的存储的对象 当我们需要释放local数据的内存时，可以通过调用release_local()函数来释放当前context的local数据，如下12345&gt;&gt;&gt; loc = Local()&gt;&gt;&gt; loc.foo = 42&gt;&gt;&gt; release_local(loc) # release_local实际调用local对象的__release_local__ method&gt;&gt;&gt; hasattr(loc, &apos;foo&apos;)False LocalStackLocalStack与Local对象类似，都是可以基于Greenlet协程或者线程进行全局存储的存储空间(实际LocalStack是对Local进行了二次封装），区别在于其数据结构是栈的形式。示例如下：1234567891011&gt;&gt;&gt; ls = LocalStack()&gt;&gt;&gt; ls.push(42)&gt;&gt;&gt; ls.top42&gt;&gt;&gt; ls.push(23)&gt;&gt;&gt; ls.top23&gt;&gt;&gt; ls.pop()23&gt;&gt;&gt; ls.top42 从示例看出Local对象存储的时候是类似字典的方式，需要有key和value，而LocalStack是基于栈的，通过push和pop来存储和弹出数据 另外，当我们想释放存储空间的时候，也可以调用release_local() LocalStack在Flask框架中会频繁的出现，其Request Context和App Context的实现都是基于LocalStack，具体可以参考Github上的Flask源码 LocalProxyLocalProxy用于代理Local对象和LocalStack对象，而所谓代理就是作为中间的代理人来处理所有针对被代理对象的操作，如下图所示： 接下来我们将重点讲下如下内容： LocalProxy的使用 LocalProxy代码解析 为什么要使用LocalProxyLocalProxy的使用初始化LocalProxy有三种方式： 通过Local或者LocalStack对象的__call__ method12345678910111213from werkzeug.local import Locall = Local()# these are proxiesrequest = l(&apos;request&apos;)user = l(&apos;user&apos;)from werkzeug.local import LocalStack_response_local = LocalStack()# this is a proxyresponse = _response_local() 上述代码直接将对象像函数一样调用，这是因为Local和LocalStack都实现了__call__ method，这样其对象就是callable的，因此当我们将对象作为函数调用时，实际调用的是__call__ method，可以看下本文开头部分的Local的源代码，会发现__call__ method会返回一个LocalProxy对象 通过LocalProxy类进行初始化12l = Local()request = LocalProxy(l, &apos;request&apos;) 实际上这段代码跟第一种方式是等价的，但这种方式是最’原始’的方式，我们在Local的源代码实现中看到其__call__ method就是通过这种方式生成LocalProxy的 使用callable对象作为参数1request = LocalProxy(get_current_request()) 通过传递一个函数，我们可以自定义如何返回Local或LocalStack对象 那么LocalProxy是如何实现这种代理的呢？接下来看下源码解析 LocalProxy代码解析下面截取LocalProxy的部分代码，我们来进行解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# LocalProxy部分代码@implements_boolclass LocalProxy(object): __slots__ = (&apos;__local&apos;, &apos;__dict__&apos;, &apos;__name__&apos;, &apos;__wrapped__&apos;) def __init__(self, local, name=None): object.__setattr__(self, &apos;_LocalProxy__local&apos;, local) object.__setattr__(self, &apos;__name__&apos;, name) if callable(local) and not hasattr(local, &apos;__release_local__&apos;): # &quot;local&quot; is a callable that is not an instance of Local or # LocalManager: mark it as a wrapped function. object.__setattr__(self, &apos;__wrapped__&apos;, local) def _get_current_object(self): &quot;&quot;&quot;Return the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context. &quot;&quot;&quot; # 由于所有Local或LocalStack对象都有__release_local__ method, 所以如果没有该属性就表明self.__local为callable对象 if not hasattr(self.__local, &apos;__release_local__&apos;): return self.__local() try: # 此处self.__local为Local或LocalStack对象 return getattr(self.__local, self.__name__) except AttributeError: raise RuntimeError(&apos;no object bound to %s&apos; % self.__name__) @property def __dict__(self): try: return self._get_current_object().__dict__ except RuntimeError: raise AttributeError(&apos;__dict__&apos;) def __getattr__(self, name): if name == &apos;__members__&apos;: return dir(self._get_current_object()) return getattr(self._get_current_object(), name) def __setitem__(self, key, value): self._get_current_object()[key] = value def __delitem__(self, key): del self._get_current_object()[key] if PY2: __getslice__ = lambda x, i, j: x._get_current_object()[i:j] def __setslice__(self, i, j, seq): self._get_current_object()[i:j] = seq def __delslice__(self, i, j): del self._get_current_object()[i:j] # 截取部分操作符代码 __setattr__ = lambda x, n, v: setattr(x._get_current_object(), n, v) __delattr__ = lambda x, n: delattr(x._get_current_object(), n) __str__ = lambda x: str(x._get_current_object()) __lt__ = lambda x, o: x._get_current_object() &lt; o __le__ = lambda x, o: x._get_current_object() &lt;= o __eq__ = lambda x, o: x._get_current_object() == o 首先在__init__ method中传递的local参数会被赋予属性_LocalProxy__local,该属性可以通过self.local进行访问，关于这一点可以看StackOverflow的问题回答 LocalProxy通过_get_current_object来获取代理的对象。需要注意的是当初始化参数为callable对象时，则直接调用以返回Local或LocalStack对象，具体看源代码的注释。 重载了绝大多数操作符，以便在调用LocalProxy的相应操作时，通过_get_current_object method来获取真正代理的对象，然后再进行相应操作 为什么要使用LocalProxy可是说了这么多，为什么一定要用proxy，而不能直接调用Local或LocalStack对象呢？这主要是在有多个可供调用的对象的时候会出现问题，如下图： 我们再通过下面的代码也许可以看出一二：123456789101112131415# use Local object directlyfrom werkzeug.local import LocalStackuser_stack = LocalStack()user_stack.push(&#123;&apos;name&apos;: &apos;Bob&apos;&#125;)user_stack.push(&#123;&apos;name&apos;: &apos;John&apos;&#125;)def get_user(): # do something to get User object and return it return user_stack.pop()# 直接调用函数获取user对象user = get_user()print user[&apos;name&apos;]print user[&apos;name&apos;] 打印结果是：12JohnJohn 再看下使用LocalProxy1234567891011121314# use LocalProxyfrom werkzeug.local import LocalStack, LocalProxyuser_stack = LocalStack()user_stack.push(&#123;&apos;name&apos;: &apos;Bob&apos;&#125;)user_stack.push(&#123;&apos;name&apos;: &apos;John&apos;&#125;)def get_user(): # do something to get User object and return it return user_stack.pop()# 通过LocalProxy使用user对象user = LocalProxy(get_user)print user[&apos;name&apos;]print user[&apos;name&apos;] 打印结果是：12JohnBob 怎么样，看出区别了吧，直接使用LocalStack对象，user一旦赋值就无法再动态更新了，而使用Proxy，每次调用操作符(这里[]操作符用于获取属性)，都会重新获取user，从而实现了动态更新user的效果。见下图： Flask以及Flask的插件很多时候都需要这种动态更新的效果，因此LocalProxy就会非常有用了。 至此，我们针对Local、LocalStack和LocalProxy的概念已经做了详细阐释，如果你觉得文章对你有帮助，不妨点个赞吧！","categories":[],"tags":[]},{"title":"Flask Signals 详解","slug":"Flask-Signals","date":"2017-10-05T14:22:18.000Z","updated":"2018-08-12T05:55:48.002Z","comments":true,"path":"2017/10/05/Flask-Signals/","link":"","permalink":"http://yoursite.com/2017/10/05/Flask-Signals/","excerpt":"Flask Signals和操作系统的signals系统很类似，都是通过信号（也可以说是事件event）来通知已经注册的回调函数，让回调函数自动开始执行。Flask定义了自己的一套核心signals和对应的functions(用于发起消息，注册回调函数)，我们需要定义自己的回调函数，然后注册到对应的signal，这样就可以在收到该信号的时候自动执行我们定义的回调函数。","text":"Flask Signals和操作系统的signals系统很类似，都是通过信号（也可以说是事件event）来通知已经注册的回调函数，让回调函数自动开始执行。Flask定义了自己的一套核心signals和对应的functions(用于发起消息，注册回调函数)，我们需要定义自己的回调函数，然后注册到对应的signal，这样就可以在收到该信号的时候自动执行我们定义的回调函数。 Flask Signals简介Flask Signals和操作系统的signals系统很类似，都是通过信号（也可以说是事件event）来通知已经注册的回调函数，让回调函数自动开始执行。Flask定义了自己的一套核心signals和对应的functions(用于发起消息，注册回调函数)，我们需要定义自己的回调函数，然后注册到对应的signal，这样就可以在收到该信号的时候自动执行我们定义的回调函数。 什么情况下需要使用Signals?当我们需要使用观察者模式来解耦模块之间的信息传递的时候，Signals系统就可以帮助我们轻松达到目的。观察者模式如下图(图片来自voidcn) 与Hook函数的区别试想，当我们需要监听某个事件，当它发生的时候，需要执行一系列functions，来实现诸如log记录等功能时，我们就可以使用Signals系统来实现，但是这里有一个疑问就是这个功能通过hook函数似乎也可以实现，比如通过before_request decorator实现记录日志的功能和使用request_started来记录日志就非常相似， 如下代码所示：1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, request, request_startedapp = Flask(__name__)@app.before_requestdef print_url_in_hook(): print &quot;in hook, url: %s&quot; % request.url@app.route(&quot;/&quot;)def hello(): return &quot;Hello, World!&quot;def print_url_in_signal_subscriber(sender, **extra): print &quot;in signal subscriber, url: %s&quot; % request.urlif __name__ == &quot;__main__&quot;: request_started.connect(print_url_in_signal_subscriber, app) app.run() 当收到http请求后，打印如下：123in signal subscriber, url: http://localhost:5000/in hook, url: http://localhost:5000/127.0.0.1 - - [05/Oct/2017 16:57:20] &quot;GET / HTTP/1.1&quot; 200 - 那么到底什么情况下使用signal，什么情况下使用hook函数呢？我们来看下它们的主要区别： signal的callback函数是无顺序的，而hook函数的执行是按照定义的顺序执行的。（这一点虽然是官网提出的区别，但是实际测试发现signal执行实际是按照注册的顺序执行的，即先通过connect进行注册的回调函数会先被执行） signal无法直接abort这个request请求，相比较在hook函数中可以直接abort request，即直接返回response给客户端，而无需再执行后续的操作。 signal可以通过参数携带数据，而hook函数通常不会携带额外的参数与RabbitMQ等消息中间件的区别Rabbitmq与signals都支持观察者模式，但是它们的区别也是很明显的： Rabbitmq之类的消息中间件更加重量级，提供更多功能，如分布式部署，消息存储备份等功能，而signal系统显然更加轻量级，只提供简单的消息分发功能 Rabbitmq之类的消息中间件可以在不同的系统间传递消息，从而使得不同的功能模块可以使用不同的语言进行开发，而signal系统显然仅限于Flask系统中使用 显然，signal系统使用局限性更大，但也更加轻量级，在只是简单的进行消息分发的系统中，使用signal更加简单方便 怎么使用Signals?Flask提供的signal机制优先使用blinker提供的库，但当blinker没有安装的时候，Flask也可以回退到使用自己的库。但是鉴于官网推荐使用blinker，所以我们最好还是安装blinker。 使用blinker安装blinker1pip install blinker 测试Flask signal是否使用blinker1234In [1]: from flask import signalsIn [2]: signals.signals_availableOut[2]: True 当signals.signals_available返回True时，说明使用的是Blinker库 使用Flask Built-in signalsFlask内置有多个signals可以直接使用，这些signals会自动emit(发射)，我们只需要定义自己的回调函数，然后通过connect方式来subscribe我们定义的函数到对应的signal即可监听该signal 下表展示了Flask内置的Signals，详细请参考Flask built-in signals: Signals 说明 template_rendered 当template被成功渲染之后会触发 before_render_template 当template被渲染之前会触发 request_started 当request context建立好之后，并在request被处理之前 request_finished 当发送response给客户端之后被触发 got_request_exception 当request处理过程中发生异常时，该signal会被触发，它甚至早于程序中的异常处理 request_tearing_down 当request tear down的时候触发，无论何种情况该signal都会被触发，即使发生异常 appcontext_tearing_down 当应用的context tear down的时候触发 appcontext_pushed 当应用的context被push时触发 appcontext_popped 当应用的context被pop时触发 message_flashed 当应用发送flash message时触发 之前的例子我们已经看到如何使用request_started signal了，这里需要说明两点： 在定义回调函数时，第一个参数必须是sender对象（即发送该signal的对象），第二个参数**extra用于接受额外的参数，也防止将来Flask在发送signal时添加新的参数。 使用connect注册回调函数时，第一个参数是回调函数，这个是必须的，第二参数是sender对象，是可选的，但最佳实践是要明确发送该signal的对象 另外，我们也可以临时性注册一个回调函数，这个尤其在进行单元测试时非常有用，因为我们不想在实际程序中添加测试相关的回调函数，因此需要一种机制在测试完成后，再取消注册该回调函数，有两种方式可以此种临时注册的机制： 一种是通过contextmanagerdecorator和disconnect函数一起来实现，如下：123456789101112131415from flask import template_renderedfrom contextlib import contextmanager@contextmanagerdef captured_templates(app): recorded = [] def record(sender, template, context, **extra): recorded.append((template, context)) # 当使用with关键字进入with context时，自动注册record函数到template_rendered signal template_rendered.connect(record, app) try: yield recorded finally: # with context结束时会自动调用disconnect函数来解除注册 template_rendered.disconnect(record, app) 使用时代码如下：1234567with captured_templates(app) as templates: rv = app.test_client().get(&apos;/&apos;) assert rv.status_code == 200 assert len(templates) == 1 template, context = templates[0] assert template.name == &apos;index.html&apos; assert len(context[&apos;items&apos;]) == 10 另外一种方式是使用connect_to函数123456from flask import template_rendereddef captured_templates(app, recorded, **extra): def record(sender, template, context): recorded.append((template, context)) return template_rendered.connected_to(record, app) 使用时代码如下：1234templates = []with captured_templates(app, templates, **extra): ... template, context = templates[0] 自定义signals的使用自定义signal当我们需要自定义signal时，我们可以直接使用blinker库 首先定义一个namespace 12from blinker import Namespacemy_signals = Namespace() 使用我们自定义的namespace定义自己的signal 1upload_image_finished = my_signals.signal(&apos;upload_image_finished&apos;) 至此，我们就定义了一个signal，名为upload_image_finished 发射自定义signal1234567from flask import current_appdef upload_image(image_path, upload_url): # upload image code ... # after upload image upload_image_finished.send(current_app._get_current_object()) 当在类的method中使用send函数发射signal时，我们可以选择该类的对象作为sender对象，因此直接使用self作为参数，但是当我们不是在类的method当中，或者我们想让应用对象作为sender，那么我们就需使用如上代码所示的current_app._get_current_object()来获取应用对象 使用sender时，第一个参数是sender对象，是必选的。其余实际我们还可以传递更多参数(记得我们的callback函数使用了**extra), 这样的话我们实际就拥有了传递更多数据的能力。 注册回调函数的简化写法从文章的第一个示例可以看出我们需要通过调用connect函数来对回调函数进行注册, 其实还有一个简化的写法可以把回调函数的定义和注册过程结合在一起，如下：12345from flask import template_rendered@template_rendered.connect_via(app)def when_template_rendered(sender, template, context, **extra): print &apos;Template %s is rendered with %s&apos; % (template.name, context) 通过connect_via装饰器来简化回调函数定义和注册的过程 Reference Flask Signals Blinker Doc","categories":[],"tags":[]},{"title":"Flask Restful API权限管理设计与实现","slug":"flask_restful_api","date":"2017-08-10T08:21:18.000Z","updated":"2018-08-12T05:50:21.523Z","comments":true,"path":"2017/08/10/flask_restful_api/","link":"","permalink":"http://yoursite.com/2017/08/10/flask_restful_api/","excerpt":"","text":"在使用flask设计restful api的时候，有一个很重要的问题就是如何进行权限管理，以及如何进行角色的定义，在网上找了一下没有发现有类似的资料，虽然有些针对网站进行的权限管理设计，但是跟restful api接口的权限管理还是有很多不同的，于是乎自己动手，丰衣足食。为方便后来者，特撰此文！ 权限的设计从本质上思考，我需要为每个API接口设定相应的权限，所以针对API的权限列表跟普通网站的权限设计是不同的，普通网站的权限设计是针对某个功能，比如是否可以comment功能，通常的权限定义如下：123456class Permission: &quot;&quot;&quot; 权限表 &quot;&quot;&quot; COMMENT = 0x01 # 评论 MODERATE_COMMENT = 0x02 # 移除评论 但是针对restful api，我们更希望权限是针对我们的api接口，而restful api接口是跟我们路由的endpoint以及http method相关的，所以我们的权限设计应该是类似如下示例中的样子：123# 这里comments是路由的endpoint，接口在判断用户是否有权限的时候# 可以先获取到endpoint和http method，然后就可以查看其是否有权限comment_permission = &#123;&quot;comments&quot;: &#123;&quot;post&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: False&#125;&#125; 角色的设计通常，我们在做网站的角色设计时会将角色存储在数据库当中，并会通过或运算(|)赋予角色以特定权限，如下：1234567891011121314151617181920212223242526272829303132333435class Role(db.Model): &quot;&quot;&quot; 用户角色 &quot;&quot;&quot; id = db.Column(db.Integer, primary_key=True) # 该用户角色名称 name = db.Column(db.String(164)) # 该用户角色是否为默认 default = db.Column(db.Boolean, default=False, index=True) # 该用户角色对应的权限 permissions = db.Column(db.Integer) # 该用户角色和用户的关系 # 角色为该用户角色的所有用户 users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;, lazy=&apos;dynamic&apos;) @staticmethod def insert_roles(): &quot;&quot;&quot; 创建用户角色 &quot;&quot;&quot; roles = &#123; # 定义了两个用户角色(User, Admin) &apos;User&apos;: (Permission.COMMENT, True), &apos;Admin&apos;: (Permission.COMMENT | Permission.MODERATE_COMMENT, False) &#125; for r in roles: role = Role.query.filter_by(name=r).first() if role is None: # 如果用户角色没有创建: 创建用户角色 role = Role(name=r) role.permissions = roles[r][0] role.default = roles[r][1] db.session.add(role) db.session.commit() 这里其实我一直没有搞明白，为什么要将角色存储于数据库当中，在我看来这只会导致更多的I/O操作从而影响系统的性能，因此我在设计角色的时候根本没有考虑存储到数据库中，角色的数据结构在系统运行时，直接存在内存当中，这样在接口调用时，可以直接使用角色相关的数据结构。而且由于我们的权限设计也不太相同，所以我针对restful api设计的Role如下：123456789101112131415161718USER = 1ADMIN = 2VISITOR = 3Role = &#123; USER: &#123; &quot;comment&quot;: &#123;&quot;post&quot;: True, &quot;patch&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: True&#125;, &quot;share&quot;: &#123;&quot;post&quot;: True&#125; &#125;, ADMIN: &#123; &quot;comment&quot;: &#123;&quot;post&quot;: True, &quot;patch&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: True&#125;, &quot;share&quot;: &#123;&quot;post&quot;: True&#125; &#125;, VISITOR: &#123; &quot;comment&quot;: &#123;&quot;get&quot;: True&#125;, &quot;share&quot;: &#123;&quot;post&quot;: True&#125; &#125;&#125; 用户可以被赋予特定的role，如下：1userA = &#123;&quot;name&quot;: &quot;John&quot;, &quot;role&quot;: USER&#125; 那么接口如何判断用户是否有权限访问呢？首先用户访问接口时都会带有用户信息，restful api一般是通过token来表明身份，系统通过token来获取用户的信息，比如用户名，然后我们可以通过用户名来获取用户的角色role，假设我们访问的接口是comments endpoint的post接口，那么就可以如下判断：12345678910111213def access_control(user): &quot;&quot;&quot;判断用户是否有访问权限，有就返回True，没有返回False&quot;&quot;&quot; # 首先要获取到API的endpoint和http method，此处代码省略 ... role = user.get(&apos;role&apos;, VISITOR) try: if not Role[role][endpoint][http_method]: return False return True except KeyError: return False 由于基本所有的接口都需要access control，那么我们把上边的代码稍作改变，让它成为一个decorator，同时，user信息也可以直接获取而不需要从参数传递，如下：1234567891011121314151617181920212223from functools import wrapsdef get_role(): # 这里get_resource_by_name用于从数据库中获取该用户的信息，这个需要自己去定义 # 另外我们可以在登录验证的时候或者token验证的时候讲user name存储于全局变量g中，这样我们可以随时获取该用户名 user = UserModel.get_resource_by_name(g.user_name) return user.get(&quot;role&quot;, VISITOR)def access_control(func): @wraps(func) def wrap_func(*args, **kwargs): # 同样要先获取到API的endpoint和http method，此处代码省略 ... try: if not Role[role][endpoint][http_method]: return make_response( jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403) return func(*args, **kwargs) except KeyError: return make_response( jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403) return wrap_func 以下是一个获取图片resource的使用示例1234567891011from flask_restful import Resourceclass ImageResource(Resource): def __init__(self): super(ImageResource, self).__init__() @token_auth.login_required @access_control def get(self, resource_id): response = resource_get(resource_id) return response 这里另外一个decortor @token_auth.login_required用于token验证，大家可以先不用理会。到这里我们已经可以针对每个接口自动判断该用户是否有权限访问了，而所有权限的变化，都可以通过修改Role中的权限来进行更改，而不需要更改原来的代码，很爽吧，有木有？不过，笔者在项目中还遇到了另外一个问题，有时候针对一个接口所有的user都应该有权限，但是针对特定的resource，只能resource owner可以操作，举个栗子，比如我们要删除某个评论，但是只允许发布评论的人才有权限删除，也就是comment resource的owner才可以使用delete接口删除，但是我们所有的用户在Role定义的时候delete接口都是True，这个怎么办呢？这就需要我们在access_control检测完了之后再进一步检测该用户是否是resource owner，所以我们就需要进一步检测，这里添加一个decorator如下：12345678910111213def get_resource_owner(): &quot;&quot;&quot;获取resource的owner&quot;&quot;&quot; # 自定义，代码省略 ...def owner_permission_required(func): @wrap(func) def wrap_func(*args, **kwargs): if g.user_name == get_resource_owner(): return func(*args, **kwargs) return make_response( jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403) return wrap_func 使用如下：12345678910111213from flask_restful import Resourceclass CommentResource(Resource): def __init__(self): super(CommentResource, self).__init__() @token_auth.login_required @access_control @owner_permission_required @marshal_with(image_fields) def delete(self, resource_id): response = resource_delete(resource_id) return response 注意：decorator的顺序是不能改变的。 至此，Restful API权限管理相关的设计就完成了，如果文章给你带来了启发，记得点赞哦！","categories":[],"tags":[]},{"title":"使用Flask实现用户登陆认证的详细过程","slug":"flask_login_detail","date":"2016-12-06T03:57:18.000Z","updated":"2018-08-12T06:15:08.724Z","comments":true,"path":"2016/12/06/flask_login_detail/","link":"","permalink":"http://yoursite.com/2016/12/06/flask_login_detail/","excerpt":"本文旨在详细讲解用户登录的原理和过程，并通过Flask框架来完整实现整个登录过程","text":"本文旨在详细讲解用户登录的原理和过程，并通过Flask框架来完整实现整个登录过程 用户认证的原理在了解使用Flask来实现用户认证之前，我们首先要明白用户认证的原理。假设现在我们要自己去实现用户认证，需要做哪些事情呢？ 首先，用户要能够输入用户名和密码，所以需要网页和表单，用以实现用户输入和提交的过程。 用户提交了用户名和密码，我们就需要比对用户名，密码是否正确，而要想比对，首先我们的系统中就要有存储用户名，密码的地方，大多数后台系统会通过数据库来存储，但是实际上我们也可以简单的存储到文件当中。(为简明起见，本文将用户信息存储到json文件当中) 登录之后，我们需要维持用户登录状态，以便用户在访问特定网页的时候来判断用户是否已经登录，以及是否有权限访问改网页。这就需要有维护一个会话来保存用户的登录状态和用户信息。 从第三步我们也可以看出，如果我们的网页需要权限保护，那么当请求到来的时候，我们就首先要检查用户的信息，比如是否已经登录，是否有权限等，如果检查通过，那么在response的时候就会将相应网页回复给请求的用户，但是如果检查不通过，那么就需要返回错误信息。 在第二步，我们知道要将用户名和密码存储起来，但是如果只是简单的用明文存储用户名和密码，很容易被“有心人”盗取，从而造成用户信息泄露，那么我们实际上应当将用户信息尤其是密码做加密处理之后再存储比较安全。 用户登出 通过Flask以及相应的插件来实现登录过程接下来讲述如何通过Flask框架以及相应的插件来实现整个登录过程，需要用到的插件如下： flask-wtf wtf werkzeug flask_login 使用flask-wtf和wtf来实现表单功能flask-wtf对wtf做了一些封装，不过有些东西还是要直接用wtf，比如StringField等。flask-wtf和wtf主要是用于建立html中的元素和Python中的类的对应关系，通过在Python代码中操作对应的类，对象等从而控制html中的元素。我们需要在python代码中使用flask-wtf和wtf来定义前端页面的表单（实际是定义一个表单类），再将对应的表单对象作为render_template函数的参数，传递给相应的template，之后Jinja模板引擎会将相应的template渲染成html文本，再作为http response返回给用户。 定义表单类示例代码：1234567891011# forms.pyfrom flask_wtf import FlaskFormfrom wtforms import StringField, BooleanField, PasswordFieldfrom wtforms.validators import DataRequired# 定义的表单都需要继承自FlaskFormclass LoginForm(FlaskForm): # 域初始化时，第一个参数是设置label属性的 username = StringField(&apos;User Name&apos;, validators=[DataRequired()]) password = PasswordField(&apos;Password&apos;, validators=[DataRequired()]) remember_me = BooleanField(&apos;remember me&apos;, default=False) 在wtf当中，每个域代表就是html中的元素，比如StringField代表的是&lt;input type=”text”>元素，当然wtf的域还定义了一些特定功能，比如validators，可以通过validators来对这个域的数据做检查，详细请参考wtf教程。对应的html模板可能如下login.html：123456789101112131415161718192021222324&#123;% extends &quot;layout.html&quot; %&#125;&lt;html&gt; &lt;head&gt; &lt;title&gt;Login Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&#123;&#123; url_for(&quot;login&quot;) &#125;&#125;&quot; method=&quot;POST&quot;&gt; &lt;p&gt; User Name:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br&gt; &lt;/p&gt; &lt;p&gt; Password:&lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remember_me&quot;/&gt;Remember Me &lt;/p&gt; &#123;&#123; form.csrf_token &#125;&#125; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;&#123;% 这里\\&#123;\\&#123; form.csrf_token \\&#125;\\&#125;也可以使用&#123;&#123; form.hidden_tag() &#125;&#125;来替换i%&#125; 同时我们也可以使用form去定义模板，跟直接用html标签去定义效果是相同的，Jinja模板引擎会将对象、属性转化为对应的html标签，相对应的template，如下login.html： 123456789101112131415161718192021&lt;!-- 模板的语法应当符合Jinja语法 --&gt;&lt;!-- extend from base layout --&gt;&#123;% extends &quot;base.html&quot; %&#125;&#123;% block content %&#125; &lt;h1&gt;Sign In&lt;/h1&gt; &lt;form action=&quot;&#123;&#123; url_for(&quot;login&quot;) &#125;&#125;&quot; method=&quot;post&quot; name=&quot;login&quot;&gt; &#123;&#123; form.csrf_token &#125;&#125; &lt;p&gt; &#123;&#123; form.username.label &#125;&#125;&lt;br&gt; &#123;&#123; form.username(size=80) &#125;&#125;&lt;br&gt; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.password.label &#125;&#125;&lt;br&gt; &lt;!-- 我们可以传递input标签的属性，这里传递的是size属性 --&gt; &#123;&#123; form.password(size=80) &#125;&#125;&lt;br&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; form.remember_me &#125;&#125; Remember Me&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Sign In&quot;&gt;&lt;/p&gt; &lt;/form&gt;&#123;% endblock %&#125; 现在我们需要在view中定义相应的路由，并将相应的登录界面展示给用户。简单起见，将view的相关路由定义放在主程序当中12345# app.py@app.route(&apos;/login&apos;)def login(): form = LoginForm() return render_template(&apos;login.html&apos;, title=&quot;Sign In&quot;, form=form) 这里简单起见，当用户请求’/login’路由时，直接返回login.html网页，注意这里的html网页是经过Jinja模板引擎将相应的模板转换后的html网页。至此，如果我们把以上代码整合到flask当中，就应该能够看到相应的登录界面了，那么当用户提交之后，我们应当怎样存储呢？这里我们暂时先不用数据库这样复杂的工具存储，先简单地存为文件。接下来就看下如何去存储。 加密和存储我们可以首先定义一个User类，用于处理与用户相关的操作，包括存储和验证等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# models.pyfrom werkzeug.security import generate_password_hashfrom werkzeug.security import check_password_hashfrom flask_login import UserMixinimport jsonimport uuid# define profile.json constant, the file is used to# save user name and password_hashPROFILE_FILE = &quot;profiles.json&quot;class User(UserMixin): def __init__(self, username): self.username = username self.id = self.get_id() @property def password(self): raise AttributeError(&apos;password is not a readable attribute&apos;) @password.setter def password(self, password): &quot;&quot;&quot;save user name, id and password hash to json file&quot;&quot;&quot; self.password_hash = generate_password_hash(password) with open(PROFILE_FILE, &apos;w+&apos;) as f: try: profiles = json.load(f) except ValueError: profiles = &#123;&#125; profiles[self.username] = [self.password_hash, self.id] f.write(json.dumps(profiles)) def verify_password(self, password): password_hash = self.get_password_hash() if password_hash is None: return False return check_password_hash(self.password_hash, password) def get_password_hash(self): &quot;&quot;&quot;try to get password hash from file. :return password_hash: if the there is corresponding user in the file, return password hash. None: if there is no corresponding user, return None. &quot;&quot;&quot; try: with open(PROFILE_FILE) as f: user_profiles = json.load(f) user_info = user_profiles.get(self.username, None) if user_info is not None: return user_info[0] except IOError: return None except ValueError: return None return None def get_id(self): &quot;&quot;&quot;get user id from profile file, if not exist, it will generate a uuid for the user. &quot;&quot;&quot; if self.username is not None: try: with open(PROFILE_FILE) as f: user_profiles = json.load(f) if self.username in user_profiles: return user_profiles[self.username][1] except IOError: pass except ValueError: pass return unicode(uuid.uuid4()) @staticmethod def get(user_id): &quot;&quot;&quot;try to return user_id corresponding User object. This method is used by load_user callback function &quot;&quot;&quot; if not user_id: return None try: with open(PROFILE_FILE) as f: user_profiles = json.load(f) for user_name, profile in user_profiles.iteritems(): if profile[1] == user_id: return User(user_name) except: return None return None User类需要继承flask-login中的UserMixin类，用于实现相应的用户会话管理。 这里我们是直接存储用户信息到一个json文件”profiles.json” 我们并不直接存储密码，而是存储加密后的hash值，在这里我们使用了werkzeug.security包中的generate_password_hash函数来进行加密，由于此函数默认使用了sha1算法，并添加了长度为8的盐值，所以还是相当安全的。一般用途的话也就够用了。 验证password的时候，我们需要使用werkzeug.security包中的check_password_hash函数来验证密码 get_id是UserMixin类中就有的method，在这我们需要overwrite这个method。在json文件中没有对应的user id时，可以使用uuid.uuid4()生成一个用户唯一id 至此，我们就实现了第二步和第五步，接下来要看第三步，如何去维护一个session 维护用户session先看下代码，这里把相应代码也放入到app.py当中123456789101112131415161718192021222324252627282930313233343536373839from forms import LoginFormfrom flask_wtf.csrf import CsrfProtectfrom model import Userfrom flask_login import login_user, login_requiredfrom flask_login import LoginManager, current_userfrom flask_login import logout_userapp = Flask(__name__)app.secret_key = os.urandom(24)# use login manager to manage sessionlogin_manager = LoginManager()login_manager.session_protection = &apos;strong&apos;login_manager.login_view = &apos;login&apos;login_manager.init_app(app=app)# 这个callback函数用于reload User object，根据session中存储的user id@login_manager.user_loaderdef load_user(user_id): return User.get(user_id)# csrf protectioncsrf = CsrfProtect()csrf.init_app(app)@app.route(&apos;/login&apos;)def login(): form = LoginForm() if form.validate_on_submit(): user_name = request.form.get(&apos;username&apos;, None) password = request.form.get(&apos;password&apos;, None) remember_me = request.form.get(&apos;remember_me&apos;, False) user = User(user_name) if user.verify_password(password): login_user(user, remember=remember_me) return redirect(request.args.get(&apos;next&apos;) or url_for(&apos;main&apos;)) return render_template(&apos;login.html&apos;, title=&quot;Sign In&quot;, form=form) 维护用户的会话，关键就在这个LoginManager对象。 必须实现这个load_user callback函数，用以reload user object 当密码验证通过后，使用login_user()函数来登录用户，这时用户在会话中的状态就是登录状态了 受保护网页保护特定网页，只需要对特定路由加一个装饰器就可以，如下12345678910# app.py# ...@app.route(&apos;/&apos;)@app.route(&apos;/main&apos;)@login_requireddef main(): return render_template( &apos;main.html&apos;, username=current_user.username)# ... current_user保存的就是当前用户的信息，实质上是一个User对象，所以我们直接调用其属性, 例如这里我们要给模板传一个username的参数，就可以直接用current_user.username 使用@login_required来标识改路由需要登录用户，非登录用户会被重定向到’/login’路由(这个就是由login_manager.login_view = ‘login’ 语句来指定的) 用户登出123456789# app.py# ...@app.route(&apos;/logout&apos;)@login_requireddef logout(): logout_user() return redirect(url_for(&apos;login&apos;))# ... 至此，我们就实现了一个完整的登陆和登出的过程。 另外我们可能还需要其它辅助的功能，诸如发送确认邮件，密码重置，权限分级管理等，这些功能都可以通过flask及其插件来完成，这个大家可以自己探索下啦！","categories":[],"tags":[]}]}