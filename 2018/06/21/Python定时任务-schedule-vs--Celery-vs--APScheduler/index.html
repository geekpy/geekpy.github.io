<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Python定时任务-schedule vs. Celery vs. APScheduler | Geekpy's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Geekpy's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><div class="wrapper"><div class="container post-header"><h1>Python定时任务-schedule vs. Celery vs. APScheduler</h1></div></div><article><div class="container post"><p>本文详细讲述了在Python开发中常用的几种定时任务途径，并重点对比了schedule, Celery和APScheduler</p>
<p>&lt;!--more--&gt;</p>
<p>在Python开发过程中我们经常需要执行定时任务，而此类任务我们通常有如下选项：</p>
<ul>
<li>自己造轮子</li>
<li>使用schedule库</li>
<li>使用Celery定时任务</li>
<li>使用APScheduler</li>
</ul>
<p>自己造轮子实现，最大的优势就是灵活性，调试方便，对于某些特定系统也许也是一种选择，不过对于大多数应用来说，我们应当尽可能地使用开源的成熟的方案。下面对后三种方案分别讨论：</p>
<h2>使用schedule库</h2>
<p>schedule库是一个轻量级的定时任务方案，<strong>优势是使用简单，也不需要做什么配置；缺点是无法动态添加任务，也无法将任务持久化。</strong></p>
<h5>安装</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install schedule</span><br></pre></td></tr></table></figure></p>
<h5>使用</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import schedule</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def job():</span><br><span class="line">    print(&quot;I&apos;m working...&quot;)</span><br><span class="line"></span><br><span class="line">schedule.every(10).minutes.do(job)</span><br><span class="line">schedule.every().hour.do(job)</span><br><span class="line">schedule.every().day.at(&quot;10:30&quot;).do(job)</span><br><span class="line">schedule.every(5).to(10).minutes.do(job)</span><br><span class="line">schedule.every().monday.do(job)</span><br><span class="line">schedule.every().wednesday.at(&quot;13:15&quot;).do(job)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(1)</span><br></pre></td></tr></table></figure></p>
<h2>使用Celery</h2>
<p>Celery在Python领域可谓大名鼎鼎，我们通常将Celery作为一个任务队列来使用，不过Celery也同时提供了定时任务功能。通常，当我们的解决方案中已经在使用Celery的时候可以考虑同时使用其定时任务功能，但是Celery无法在Flask这样的系统中动态添加定时任务（在Django中有相应的插件可以实现动态添加任务），而且如果对于不使用Celery的项目，单独为定时任务搭建Celery显得过于重量级了。(搭建Celery比较麻烦，还需要配置诸如RabbitMQ之类消息分发程序)。</p>
<p>Celery安装在此不再赘述，大家可以参考官网的资料</p>
<h5>使用</h5>
<p>Celery虽然无法动态添加定时任务，但是可以在程序固定位置添加定时任务，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line"></span><br><span class="line">app = Celery()</span><br><span class="line"></span><br><span class="line"># 此处on_after_configure装饰符意味着当Celery app配置完成之后调用该hook函数</span><br><span class="line">@app.on_after_configure.connect</span><br><span class="line">def setup_periodic_tasks(sender, **kwargs):</span><br><span class="line">    # Calls test(&apos;hello&apos;) every 10 seconds.</span><br><span class="line">    sender.add_periodic_task(10.0, test.s(&apos;hello&apos;), name=&apos;add every 10&apos;)</span><br><span class="line"></span><br><span class="line">    # Calls test(&apos;world&apos;) every 30 seconds</span><br><span class="line">    sender.add_periodic_task(30.0, test.s(&apos;world&apos;), expires=10)</span><br><span class="line"></span><br><span class="line">    # Executes every Monday morning at 7:30 a.m.</span><br><span class="line">    sender.add_periodic_task(</span><br><span class="line">        crontab(hour=7, minute=30, day_of_week=1),</span><br><span class="line">        test.s(&apos;Happy Mondays!&apos;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def test(arg):</span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>这里调用<code>add_periodic_task</code>用于添加一个定时任务，相当于在Celery config文件中的beat_schedule设置项中添加了一项，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line">    &apos;add-every-30-seconds&apos;: &#123;</span><br><span class="line">        &apos;task&apos;: &apos;tasks.add&apos;,</span><br><span class="line">        &apos;schedule&apos;: 30.0,</span><br><span class="line">        &apos;args&apos;: (16, 16)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>在<code>add_periodic_task</code>中指定job function时需要用<code>.s()</code>来调用</p>
</li>
</ul>
<h2>使用APScheduler</h2>
<p>笔者认为APScheduler是在实际项目最好用的一个工具库。<strong>它不仅可以让我们在程序中动态添加和删除我们的定时任务，还支持持久化，且其持久化方案支持很多形式，包括(Memory, MongoDB, SQLAlchemy, Redis, RethinkDB, ZooKeeper), 也可以非常好与一些Python framework集成(包括asyncio, gevent, Tornado, Twisted, Qt).</strong> 笔者所在的项目使用的是Flask框架，也有相应的插件可以供我们直接使用。</p>
<p>但是笔者没有使用插件，而是直接将APScheduler集成于项目代码中。</p>
<h5>初始化scheduler</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 可以在初始化Flask的时候调用，并将返回的scheduler赋给app</span><br><span class="line">def init_scheduler():</span><br><span class="line">    # 这里用于持久化的设置，代码中演示使用MongoDB</span><br><span class="line">    # client用于设置你自己的MongoDB的handler, 即MongoClient对象</span><br><span class="line">    jobstores = &#123;</span><br><span class="line">        &apos;default&apos;: MongoDBJobStore(client=your_db_handler, collection=&quot;schedule_job&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    executors = &#123;</span><br><span class="line">        &apos;default&apos;: ThreadPoolExecutor(20)</span><br><span class="line">    &#125;</span><br><span class="line">    job_defaults = &#123;</span><br><span class="line">        &apos;coalesce&apos;: False,</span><br><span class="line">        &apos;max_instances&apos;: 5</span><br><span class="line">    &#125;</span><br><span class="line">    # 这里使用BackgroundScheduler即可</span><br><span class="line">    scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=utc)</span><br><span class="line">    # 注意这里一定要调用start启动scheduler</span><br><span class="line">    scheduler.start()</span><br><span class="line">    return scheduler</span><br></pre></td></tr></table></figure></p>
<h5>添加定时任务</h5>
<p>APScheduler将定时任务分为三种：</p>
<ul>
<li>interval: 比如每隔5分钟执行一次任务</li>
<li>cron: 比如每天早上5点执行一次任务</li>
<li>date: 比如在2018年5月5日执行一次任务</li>
</ul>
<p>我们以添加cron job为例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def test_job(name):</span><br><span class="line">    print &quot;hello, %s&quot; % name</span><br><span class="line">    </span><br><span class="line">def add_daily_job(name):</span><br><span class="line">    exec_time = datetime.now() + timedelta(minutes=2)</span><br><span class="line">    hour = exec_time.strftime(&quot;%H&quot;)</span><br><span class="line">    minute = exec_time.strftime(&quot;%M&quot;)</span><br><span class="line">    # 这里要选择&apos;cron&apos;</span><br><span class="line">    # 另外，job_id可以根据你自己的情况设定，其会被用于remove_job</span><br><span class="line">    current_app.scheduler.add_job(</span><br><span class="line">        test_job, &apos;cron&apos;, hour=hour, minute=minute,</span><br><span class="line">        args=[name], id=job_id)</span><br></pre></td></tr></table></figure></p>
<h5>删除定时任务</h5>
<p>通过在add_job时使用的job_id可以删除对应的定时任务。实际上在我们添加任务的时候，APScheduler会把相应的任务信息存储于我们jobstore中设置的持久化存储方案，这里使用的是MongoDB，然后当删除的时候会将相应的任务从MongoDB中删除。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def remove_daily_job(job_id):</span><br><span class="line">    current_app.scheduler.remove_job(job_id)</span><br></pre></td></tr></table></figure></p>
<h2>总结：</h2>
<p>APScheduler在实际使用过程中拥有最大的灵活性，可以满足我们的大部分定时任务的相关需求；Celery比较重量级，通常如果项目中已有Celery在使用，而且不需要动态添加定时任务时可以考虑使用；schedule非常轻量级，使用简单，但是不支持任务的持久化，也无法动态添加删除任务，所以主要用于简单的小型应用。</p>
<h2>References</h2>
<ul>
<li><a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">Schedule</a></li>
<li><a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a></li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/" target="_blank" rel="noopener">APScheduler</a></li>
</ul>
</div><div class="container"><hr><div class="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//cdn.jsdelivr.net/npm/valine@1.1.6/dist/Valine.min.js"></script>
<script type="text/javascript">
var leancloud_appid = '';
var leancloud_appkey = '';
var valine_url = 'http://yoursite.com/2018/06/21/Python定时任务-schedule-vs--Celery-vs--APScheduler/';
var valine_notify = false;
var valine_verify = false;
var valine_placeholder = 'input your comments here';
new Valine({
         av: AV, // source from av-min.js
         el: '.comment' ,
         notify: valine_notify,
         verify: valine_verify,
         app_id: leancloud_appid,
         app_key: leancloud_appkey,
         placeholder: valine_placeholder,
         path: valine_url
     });
</script></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:rebor.liu@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/geekpy" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">geekpy</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>