<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Flask-Login详解 | Geekpy's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Geekpy's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><div class="wrapper"><div class="container post-header"><h1>Flask-Login详解</h1></div></div><article><div class="container post"><p>本文主要通过源码分析Flask-Login插件，并详述其使用方法<br><a id="more"></a></p>
<p>关于Flask登录认证的详细过程请参见拙作<a href="http://geekpy.github.io/2016/12/06/flask_login_detail/" target="_blank" rel="noopener">&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;</a>一文，而本文则偏重于详细介绍Flask-Login的原理，代码的解析。</p>
<h3 id="首次登陆"><a href="#首次登陆" class="headerlink" title="首次登陆"></a>首次登陆</h3><p>我们首先来看一下首次登录验证的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3959253-b34989af4a0d0b2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首次登陆"></p>
<p>Flask-Login在登录过程中主要负责：</p>
<ul>
<li>将用户对象存入request context中</li>
<li>将用户ID，Session ID等信息存入Session中<br>在<a href="http://www.jianshu.com/p/06bd93e21945" target="_blank" rel="noopener">&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;</a>中我们已经介绍过如何通过Flask-Login来实现登录的过程，其中最重要的代码就是login_user，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login_user(user, remember=remember_me)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那么login_user具体做了什么呢？我们来看下源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def login_user(user, remember=False, force=False, fresh=True):</span><br><span class="line">    if not force and not user.is_active:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    user_id = getattr(user, current_app.login_manager.id_attribute)()</span><br><span class="line">    session[&apos;user_id&apos;] = user_id</span><br><span class="line">    session[&apos;_fresh&apos;] = fresh</span><br><span class="line">    session[&apos;_id&apos;] = current_app.login_manager._session_identifier_generator()</span><br><span class="line"></span><br><span class="line">    if remember:</span><br><span class="line">        session[&apos;remember&apos;] = &apos;set&apos;</span><br><span class="line"></span><br><span class="line">    _request_ctx_stack.top.user = user</span><br><span class="line">    user_logged_in.send(current_app._get_current_object(), user=_get_user())</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>getattr(user, current_app.login_manager.id_attribute)()</code> 这里<code>login_manager.id_attribute</code>是一个字符串<code>&#39;get_id&#39;</code>。因此这句的意思是获取User对象的get_id method，然后执行，从而获取到用户的ID</li>
<li><p>通过<code>session[&#39;user_id&#39;] = user_id</code>来将用户的ID存储进Session当中，后面紧跟着将fresh信息，session id信息，remember信息存储进session。</p>
<blockquote>
<p>注意：Flask的session是以cookie为基础，但是是在Server端使用secret key并使用AES之类的对称加密算法进行加密的，然后将加密后的cookie发送给客户端。由于是加密后的数据，客户端无法篡改数据，也无法获知session中的信息，只能保存该session信息，在之后的请求中携带该session信息</p>
</blockquote>
</li>
<li><p><code>_request_ctx_stack.top.user = user</code>这里是将user对象存储进当前的request context中，_request_ctx_stack是一个LocalStack对象，top属性指向的就是当前的request context。关于LocalStack及相关技术，请参考拙作<a href="http://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt;</a></p>
</li>
<li><code>user_logged_in.send(current_app._get_current_object(), user=_get_user())</code> 此句中<code>user_logged_in</code>是Flask-Login定义的signal，此处通过send来发射此signal，当注册监听此signal的回调函数收到此signal之后就会执行函数。这里send有两个参数，第一个参数是sender对象，此处通过<code>current_app._get_current_object()</code>来获取当前的app对象，即此signal的sender设为当前的应用；第二个参数是该signal携带的数据，此处将user对象做为signal的数据传递给相应的回调函数。关于signal的详细解释请参考拙作<a href="http://www.jianshu.com/p/756ed0267f53" target="_blank" rel="noopener">&lt;<flask signals详解="">&gt;</flask></a><h3 id="非首次登陆"><a href="#非首次登陆" class="headerlink" title="非首次登陆"></a>非首次登陆</h3>非首次登陆流程图如下：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3959253-7ea20e139da6e2ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非首次登陆"></p>
<p>在这个流程图中，Flask-Login主要起如下作用：</p>
<ol>
<li>从session中获取用户ID</li>
<li>当用户的请求访问的是受登录保护的路由时，就要通过用户ID重新load user，如果load user失败则进入鉴权失败处理流程，如果成功，则允许正常处理请求<br>那么Flask-Login究竟是如何保护路由的呢？我们来看个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">@app.route(&apos;/main&apos;)</span><br><span class="line">@login_required</span><br><span class="line">def main():</span><br><span class="line">    return render_template(</span><br><span class="line">        &apos;main.html&apos;, username=current_user.username)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们看到只要给路由函数加一个<code>@login_required</code>装饰器就可以了，那么这个装饰器究竟是怎么做到的呢？来看下源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/utils.py</span><br><span class="line">def login_required(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def decorated_view(*args, **kwargs):</span><br><span class="line">        # 如果request method为例外method，即在EXEMPT_METHODS中的method，可以不必鉴权</span><br><span class="line">        if request.method in EXEMPT_METHODS:</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        # 如果_login_disabled为True则不必鉴权</span><br><span class="line">        elif current_app.login_manager._login_disabled:</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        # 正常鉴权</span><br><span class="line">        elif not current_user.is_authenticated:</span><br><span class="line">            return current_app.login_manager.unauthorized()</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return decorated_view</span><br></pre></td></tr></table></figure></p>
<ul>
<li>默认情况下只有<em>OPTIONS</em> method在EXEMPT_METHODS set中，而GET、PUT、POST等常见的methods都需要鉴权</li>
<li><code>_login_disabled</code>默认为False</li>
<li>正常鉴权的关键在于<code>current_user.is_authenticated</code>是否为True，为True则正常处理请求，为False则进入unauthorized处理流程。那么这个current_user到底怎么就能鉴权了？它是怎么来的呢？来看下定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/utils.py</span><br><span class="line">current_user = LocalProxy(lambda: _get_user())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>原来current_user是一个LocalProxy对象，其代理的对象需要通过<code>_get_user()</code>来获取，简单来说_get_user()会返回两种用户，一种是正常的用户对象(鉴权成功)，一种是anonymous用户对象(鉴权失败)。而正常的用户对象其<code>is_authenticated</code>属性总是为True，相对的anonymous用户对象的<code>is_authenticated</code>属性总是为False</p>
<blockquote>
<p>LocalProxy对象每次操作都会重新获取代理的对象从而实现动态更新，关于LocalProxy的详细说明请参考拙作<a href="http://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt;</a></p>
</blockquote>
<p>而要实现动态更新的关键就在于<code>_get_user</code>函数，接下来我们看下<code>_get_user</code>函数是如何获取user对象的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/utils.py</span><br><span class="line">def _get_user():</span><br><span class="line">    if has_request_context() and not hasattr(_request_ctx_stack.top, &apos;user&apos;):</span><br><span class="line">        current_app.login_manager._load_user()</span><br><span class="line"></span><br><span class="line">    return getattr(_request_ctx_stack.top, &apos;user&apos;, None)</span><br></pre></td></tr></table></figure></p>
<p>在之前的首次登陆那小节中，我们已经知道用户鉴权成功后，会将User对象保存在当前的request context当中，这时我们调用<code>_get_user</code>函数时就会直接从request context中获取user对象<code>return getattr(_request_ctx_stack.top, &#39;user&#39;, None)</code><br>但如果是非首次登陆，当前request context中并没有保存user对象，就需要调用<code>current_app.login_manager._load_user()</code>来去load user对象，接下来再看看如何去load：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/login_manager.py</span><br><span class="line">def _load_user(self):</span><br><span class="line">        &apos;&apos;&apos;Loads user from session or remember_me cookie as applicable&apos;&apos;&apos;</span><br><span class="line">        user_accessed.send(current_app._get_current_object())</span><br><span class="line"></span><br><span class="line">        # first check SESSION_PROTECTION</span><br><span class="line">        config = current_app.config</span><br><span class="line">        if config.get(&apos;SESSION_PROTECTION&apos;, self.session_protection):</span><br><span class="line">            deleted = self._session_protection()</span><br><span class="line">            if deleted:</span><br><span class="line">                return self.reload_user()</span><br><span class="line"></span><br><span class="line">        # If a remember cookie is set, and the session is not, move the</span><br><span class="line">        # cookie user ID to the session.</span><br><span class="line">        #</span><br><span class="line">        # However, the session may have been set if the user has been</span><br><span class="line">        # logged out on this request, &apos;remember&apos; would be set to clear,</span><br><span class="line">        # so we should check for that and not restore the session.</span><br><span class="line">        is_missing_user_id = &apos;user_id&apos; not in session</span><br><span class="line">        if is_missing_user_id:</span><br><span class="line">            cookie_name = config.get(&apos;REMEMBER_COOKIE_NAME&apos;, COOKIE_NAME)</span><br><span class="line">            header_name = config.get(&apos;AUTH_HEADER_NAME&apos;, AUTH_HEADER_NAME)</span><br><span class="line">            has_cookie = (cookie_name in request.cookies and</span><br><span class="line">                          session.get(&apos;remember&apos;) != &apos;clear&apos;)</span><br><span class="line">            if has_cookie:</span><br><span class="line">                return self._load_from_cookie(request.cookies[cookie_name])</span><br><span class="line">            elif self.request_callback:</span><br><span class="line">                return self._load_from_request(request)</span><br><span class="line">            elif header_name in request.headers:</span><br><span class="line">                return self._load_from_header(request.headers[header_name])</span><br><span class="line"></span><br><span class="line">        return self.reload_user()</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>_load_user</code>大体的过程是首先检查<em>SESSION_PROTECTION</em>设置，如果<em>SESSION_PROTECTION</em> 为strong或者basic类型，那么就会执行<code>_session_protection()</code>动作，否则不执行此操作。<code>_session_protection</code>在session_id不一致的时候(比如IP变化会导致session id的变化)才真正有用，这时，如果为basic类型或者session permanent为True时，只标注session为非新鲜的(not fresh)；而如果为strong，则会删除session中的用户信息，并重新load user，即调用<code>reload_user</code>。<blockquote>
<p>session permanent为True时，用户退出浏览器不会删除session，其会保留permanent_session_lifetime s(默认是31天)，但是当其为False且<em>SESSION_PROTECTION</em> 设为strong时，用户的session就会被删除。</p>
</blockquote>
</li>
<li>接下来的代码是说当session中没有用户信息时(这里通过是否能获取到<code>user_id</code>来判断)，如果有则直接<code>reload_user</code>,如果没有，则有三种方式来load user，一种是通过remember cookie，一种通过request，一种是通过request header，依次尝试。<blockquote>
<p>remember cookie是指，当用户勾选’remember me’复选框时，Flask-Login会将用户信息放入到指定的cookie当中，同样也是加密的。这就是为什么当session中没有携带用户信息时，我们可以通过remember cookie来获取用户的信息</p>
</blockquote>
</li>
</ul>
<p>而<code>reload_user</code>是如何获取用户的呢，来看下源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/login_manager.py</span><br><span class="line">def reload_user(self, user=None):</span><br><span class="line">        ctx = _request_ctx_stack.top</span><br><span class="line"></span><br><span class="line">        if user is None:</span><br><span class="line">            user_id = session.get(&apos;user_id&apos;)</span><br><span class="line">            if user_id is None:</span><br><span class="line">                # 当无法获取到有效的用户id时，就认为是anonymous user</span><br><span class="line">                ctx.user = self.anonymous_user()</span><br><span class="line">            else:</span><br><span class="line">                # user callback就是我们通过@login_manager.user_loader装饰的函数，用于获取user object</span><br><span class="line">                if self.user_callback is None:</span><br><span class="line">                    raise Exception(</span><br><span class="line">                        &quot;No user_loader has been installed for this &quot;</span><br><span class="line">                        &quot;LoginManager. Add one with the &quot;</span><br><span class="line">                        &quot;&apos;LoginManager.user_loader&apos; decorator.&quot;)</span><br><span class="line">                user = self.user_callback(user_id)</span><br><span class="line">                if user is None:</span><br><span class="line">                    ctx.user = self.anonymous_user()</span><br><span class="line">                else:</span><br><span class="line">                    ctx.user = user</span><br><span class="line">        else:</span><br><span class="line">            ctx.user = user</span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先获取user id，如果获取不到有效的id，就将user设为anonymous user</li>
<li>获取到id后，再通过@login_manager.user_loader装饰的函数获取到user对象，如果没有获取到有效的user对象，就认为是anonymous user</li>
<li>最后将user保存于request context中（无论是正常的用户还是anonymous用户）</li>
</ul>
<p>至此，我们已经将Flask-Login的核心代码剖析了一遍，如果你有收获，不妨点个赞鼓励一下吧！</p>
</div><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:rebor.liu@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/geekpy" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">geekpy</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>