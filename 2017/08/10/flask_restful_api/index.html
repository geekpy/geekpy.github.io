<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Flask Restful API权限管理设计与实现 | Geekpy's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Geekpy's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><div class="wrapper"><div class="container post-header"><h1>Flask Restful API权限管理设计与实现</h1></div></div><article><div class="container post"><p>在使用flask设计restful api的时候，有一个很重要的问题就是如何进行权限管理，以及如何进行角色的定义，在网上找了一下没有发现有类似的资料，虽然有些针对网站进行的权限管理设计，但是跟restful api接口的权限管理还是有很多不同的，于是乎自己动手，丰衣足食。为方便后来者，特撰此文！</p>
<h2>权限的设计</h2>
<p>从本质上思考，我需要为每个API接口设定相应的权限，所以针对API的权限列表跟普通网站的权限设计是不同的，普通网站的权限设计是针对某个功能，比如是否可以comment功能，通常的权限定义如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Permission:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    权限表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    COMMENT = 0x01  # 评论</span><br><span class="line">    MODERATE_COMMENT = 0x02  # 移除评论</span><br></pre></td></tr></table></figure></p>
<p>但是针对restful api，我们更希望权限是针对我们的api接口，而restful api接口是跟我们路由的endpoint以及http method相关的，所以我们的权限设计应该是类似如下示例中的样子：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里comments是路由的endpoint，接口在判断用户是否有权限的时候</span><br><span class="line"># 可以先获取到endpoint和http method，然后就可以查看其是否有权限</span><br><span class="line">comment_permission = &#123;&quot;comments&quot;: &#123;&quot;post&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: False&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h2>角色的设计</h2>
<p>通常，我们在做网站的角色设计时会将角色存储在数据库当中，并会通过或运算(|)赋予角色以特定权限，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户角色</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    # 该用户角色名称</span><br><span class="line">    name = db.Column(db.String(164))</span><br><span class="line">    # 该用户角色是否为默认</span><br><span class="line">    default = db.Column(db.Boolean, default=False, index=True)</span><br><span class="line">    # 该用户角色对应的权限</span><br><span class="line">    permissions = db.Column(db.Integer)</span><br><span class="line">    # 该用户角色和用户的关系</span><br><span class="line">    # 角色为该用户角色的所有用户</span><br><span class="line">    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;, lazy=&apos;dynamic&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def insert_roles():</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        创建用户角色</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        roles = &#123;</span><br><span class="line">            # 定义了两个用户角色(User, Admin)</span><br><span class="line">            &apos;User&apos;: (Permission.COMMENT, True),</span><br><span class="line">            &apos;Admin&apos;: (Permission.COMMENT |</span><br><span class="line">                      Permission.MODERATE_COMMENT, False)</span><br><span class="line">        &#125;</span><br><span class="line">        for r in roles:</span><br><span class="line">            role = Role.query.filter_by(name=r).first()</span><br><span class="line">            if role is None:</span><br><span class="line">                # 如果用户角色没有创建: 创建用户角色</span><br><span class="line">                role = Role(name=r)</span><br><span class="line">            role.permissions = roles[r][0]</span><br><span class="line">            role.default = roles[r][1]</span><br><span class="line">            db.session.add(role)</span><br><span class="line">            db.session.commit()</span><br></pre></td></tr></table></figure></p>
<p>这里其实我一直没有搞明白，为什么要将角色存储于数据库当中，在我看来这只会导致更多的I/O操作从而影响系统的性能，因此我在设计角色的时候根本没有考虑存储到数据库中，角色的数据结构在系统运行时，直接存在内存当中，这样在接口调用时，可以直接使用角色相关的数据结构。而且由于我们的权限设计也不太相同，所以我针对restful api设计的Role如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">USER = 1</span><br><span class="line">ADMIN = 2</span><br><span class="line">VISITOR = 3</span><br><span class="line"></span><br><span class="line">Role = &#123;</span><br><span class="line">    USER: &#123;</span><br><span class="line">        &quot;comment&quot;: &#123;&quot;post&quot;: True, &quot;patch&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: True&#125;,</span><br><span class="line">        &quot;share&quot;: &#123;&quot;post&quot;: True&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ADMIN: &#123;</span><br><span class="line">        &quot;comment&quot;: &#123;&quot;post&quot;: True, &quot;patch&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: True&#125;,</span><br><span class="line">        &quot;share&quot;: &#123;&quot;post&quot;: True&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    VISITOR: &#123;</span><br><span class="line">        &quot;comment&quot;: &#123;&quot;get&quot;: True&#125;,</span><br><span class="line">        &quot;share&quot;: &#123;&quot;post&quot;: True&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用户可以被赋予特定的role，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userA = &#123;&quot;name&quot;: &quot;John&quot;, &quot;role&quot;: USER&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么接口如何判断用户是否有权限访问呢？
首先用户访问接口时都会带有用户信息，restful api一般是通过token来表明身份，系统通过token来获取用户的信息，比如用户名，然后我们可以通过用户名来获取用户的角色role，假设我们访问的接口是comments endpoint的post接口，那么就可以如下判断：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def access_control(user):</span><br><span class="line">    &quot;&quot;&quot;判断用户是否有访问权限，有就返回True，没有返回False&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # 首先要获取到API的endpoint和http method，此处代码省略</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    role = user.get(&apos;role&apos;, VISITOR)</span><br><span class="line">    try:</span><br><span class="line">        if not Role[role][endpoint][http_method]:</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br><span class="line">    except KeyError:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p>
<p>由于基本所有的接口都需要access control，那么我们把上边的代码稍作改变，让它成为一个decorator，同时，user信息也可以直接获取而不需要从参数传递，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def get_role():</span><br><span class="line">    # 这里get_resource_by_name用于从数据库中获取该用户的信息，这个需要自己去定义</span><br><span class="line">    # 另外我们可以在登录验证的时候或者token验证的时候讲user name存储于全局变量g中，这样我们可以随时获取该用户名</span><br><span class="line">    user = UserModel.get_resource_by_name(g.user_name)</span><br><span class="line">    return user.get(&quot;role&quot;, VISITOR)</span><br><span class="line"></span><br><span class="line">def access_control(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def wrap_func(*args, **kwargs):</span><br><span class="line">        # 同样要先获取到API的endpoint和http method，此处代码省略</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not Role[role][endpoint][http_method]:</span><br><span class="line">                return make_response(</span><br><span class="line">                    jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403)</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line">        except KeyError:</span><br><span class="line">            return make_response(</span><br><span class="line">                jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403)</span><br><span class="line">    return wrap_func</span><br></pre></td></tr></table></figure></p>
<p>以下是一个获取图片resource的使用示例
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask_restful import Resource</span><br><span class="line"></span><br><span class="line">class ImageResource(Resource):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(ImageResource, self).__init__()</span><br><span class="line"></span><br><span class="line">    @token_auth.login_required</span><br><span class="line">    @access_control</span><br><span class="line">    def get(self, resource_id):</span><br><span class="line">        response = resource_get(resource_id)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure></p>
<p>这里另外一个decortor @token_auth.login_required用于token验证，大家可以先不用理会。到这里我们已经可以针对每个接口自动判断该用户是否有权限访问了，而所有权限的变化，都可以通过修改Role中的权限来进行更改，而不需要更改原来的代码，很爽吧，有木有？
不过，笔者在项目中还遇到了另外一个问题，有时候针对一个接口所有的user都应该有权限，但是针对特定的resource，只能resource owner可以操作，举个栗子，比如我们要删除某个评论，但是只允许发布评论的人才有权限删除，也就是comment resource的owner才可以使用delete接口删除，但是我们所有的用户在Role定义的时候delete接口都是True，这个怎么办呢？
这就需要我们在access_control检测完了之后再进一步检测该用户是否是resource owner，所以我们就需要进一步检测，这里添加一个decorator如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def get_resource_owner():</span><br><span class="line">    &quot;&quot;&quot;获取resource的owner&quot;&quot;&quot;</span><br><span class="line">    # 自定义，代码省略</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">def owner_permission_required(func):</span><br><span class="line">    @wrap(func)</span><br><span class="line">    def wrap_func(*args, **kwargs):</span><br><span class="line">        if g.user_name == get_resource_owner():</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line">        return make_response(</span><br><span class="line">            jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403)</span><br><span class="line">    return wrap_func</span><br></pre></td></tr></table></figure></p>
<p>使用如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask_restful import Resource</span><br><span class="line"></span><br><span class="line">class CommentResource(Resource):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(CommentResource, self).__init__()</span><br><span class="line"></span><br><span class="line">    @token_auth.login_required</span><br><span class="line">    @access_control</span><br><span class="line">    @owner_permission_required</span><br><span class="line">    @marshal_with(image_fields)</span><br><span class="line">    def delete(self, resource_id):</span><br><span class="line">        response = resource_delete(resource_id)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure></p>
<p>注意：decorator的顺序是不能改变的。</p>
<p>至此，Restful API权限管理相关的设计就完成了，如果文章给你带来了启发，记得点赞哦！</p>
</div><div class="container"><hr><div class="comment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//cdn.jsdelivr.net/npm/valine@1.1.6/dist/Valine.min.js"></script>
<script type="text/javascript">
var leancloud_appid = 'OCjgmQiFa9gpVkDabM6KTb8g-gzGzoHsz';
var leancloud_appkey = 'Ie7XE2V6spB6Q6C1W2GU9drV';
var valine_url = 'http://yoursite.com/2017/08/10/flask_restful_api/';
var valine_notify = false;
var valine_verify = false;
var valine_placeholder = '';
new Valine({
         av: AV, // source from av-min.js
         el: '.comment' ,
         notify: valine_notify,
         verify: valine_verify,
         app_id: leancloud_appid,
         app_key: leancloud_appkey,
         placeholder: valine_placeholder,
         path: valine_url
     });
</script></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:rebor.liu@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/geekpy" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">geekpy</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>