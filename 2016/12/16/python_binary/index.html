<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Python二进制表示和位操作 | Geekpy's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Geekpy's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><div class="wrapper"><div class="container post-header"><h1>Python二进制表示和位操作</h1></div></div><article><div class="container post"><p>我们都知道在计算机中所有的信息最终都是以二进制的0和1来表示，而有些算法是通过操作bit位来进行运算的，这就需要我们了解Python中如何去表示二进制，又如何是进行位运算的。</p>
<p>&lt;!--more--&gt;</p>
<h3>二进制的表示</h3>
<p>首先在Python中可以通过以&quot;0b&quot;或者&quot;-0b&quot;开头的字符串来表示二进制，如下所示
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print 0b101 # 输出5</span><br><span class="line">print 0b10  # 输出2</span><br><span class="line">print 0b111 # 输出7</span><br><span class="line">print -0b101 # 输出-5</span><br></pre></td></tr></table></figure></p>
<p>由此可知我们用二进制表示的数字在打印之后会变成我们更为熟悉的十进制数，更容易被人理解。
当我们需要看十进制数字的二进制表示时，可以使用bin函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin(5)  # 输出0b101</span><br></pre></td></tr></table></figure></p>
<h3>二进制的位操作</h3>
<p>首先一点需要明确的是所有的运算（包括位操作）在计算机内部都是通过补码形式来进行运算的，关于补码可以参考文章<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.htmlhttp://note.youdao.com/" target="_blank" rel="noopener">原码，反码和补码</a>，计算机内部运算示意图如下：
<img src="https://segmentfault.com/img/bVp6Ux" alt="image"></p>
<p>在Python中提供了如下二进制的位操作：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;  #右移</span><br><span class="line">&lt;&lt;  #左移</span><br><span class="line">|   #位或 </span><br><span class="line">&amp;   #位与</span><br><span class="line">^   #位异或</span><br><span class="line">~   #非</span><br></pre></td></tr></table></figure></p>
<p>位运算法则：</p>
<p><img src="https://segmentfault.com/img/bVp6Uv" alt="image"></p>
<p>下面我们分别来看下：</p>
<h5>左移</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0b11 &lt;&lt; 2   #输出为12, 即0b1100</span><br><span class="line">5 &lt;&lt; 2      #输出为20, 即0b10100</span><br><span class="line">-2 &lt;&lt; 2     #输出为-8</span><br><span class="line">5 &lt;&lt; 64     #输出为92233720368547758080L</span><br></pre></td></tr></table></figure></p>
<ol>
<li>以0b11为例，0b11的补码就是0b11，所以左移就是将所有的0和1的位置进行左移，移位之后将空位补0。</li>
<li>负数的左移相对来说就比较复杂，以-2 &lt;&lt; 2为例，-2的原码是10000000000000000000000000000010（32位系统），其补码为11111111111111111111111111111110，左移之后变为11111111111111111111111111111000，再转化为原码即10000000000000000000000000001000，也就是-8，也就是-2*(2**2)=-8</li>
<li>左移超过32位或者64位（根据系统的不同）自动转化为long类型。</li>
<li>左移操作相当于乘以2**n，以5 &lt;&lt; 3为例，相当于5*(2**3),结果为40。</li>
</ol>
<h5>右移</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0b11 &gt;&gt; 1   #输出为1, 即0b1</span><br><span class="line">5 &gt;&gt; 1      #输出为2，即0b10</span><br><span class="line">-8 &gt;&gt; 3     #输出为-1</span><br></pre></td></tr></table></figure></p>
<ol>
<li>在Python中如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1；</li>
<li>同样需要先转化为补码再进行计算，以-8 &gt;&gt; 3为例，-8的原码为10...01000,相应的补码为11...11000,右移后变为1...1,相应的原码为10...01,即-1。</li>
<li>右移操作相当于除以2**n，8 &gt;&gt; 3相当于8/(2**3)=1</li>
</ol>
<h5>或</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b110 | 0b101   #输出7,即0b111</span><br><span class="line">-0b001 | 0b101  #输出-1</span><br></pre></td></tr></table></figure></p>
<p>同样是转化为补码后再进行或运算, 只要有一位有1就为1。
所以或运算常常用于mask技术中的打开开关，即针对某一位把其置为1
比如将某个数字的第三位置为1，我们可以将mask设置为0b100，然后再或运算
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = 0b100</span><br><span class="line">0b110000 | mask  #turn on bit 3</span><br></pre></td></tr></table></figure></p>
<h5>与</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0b110 &amp; 0b011   #输出2，即0b010</span><br></pre></td></tr></table></figure></p>
<p>与运算常常用于mask技术的关闭开关，即针对某一位把其置为0
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = 0b10</span><br><span class="line">0b111111 &amp; mask  #turn off bit 2</span><br></pre></td></tr></table></figure></p>
<h5>异或</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b111 ^ 0b111   #输出0</span><br><span class="line">0b100 ^ 0b111   #输出3</span><br></pre></td></tr></table></figure></p>
<p>异或常用于将所有的位反转
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0b1010 ^ 0b1111  #输出5，即0b0101</span><br></pre></td></tr></table></figure></p>
<h5>非</h5>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~0b101  #输出2，即0b010</span><br><span class="line">~-3     #输出2</span><br></pre></td></tr></table></figure></p>
<p>非运算就是把0变1，1变0，唯一需要注意的是取非时符号位也会变换，比如-3，原码是10...011,补码是11...101,取非后变为00...010,由于符号位为0，所以对应的原码即为其本身，即2。</p>
<h3>二进制工具</h3>
<h5>bitarray</h5>
<p>关于bit有一个很有用的Packag叫做bitarray，其中bitarray对象可以帮助我们存储0，1值或者Boolean值，并像list一样进行操作。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from bitarray import bitarray</span><br><span class="line"></span><br><span class="line">#初始化一个有10个bit位的数组，初始值为0</span><br><span class="line">a = bitarray(10)</span><br><span class="line"></span><br><span class="line">#可以像操作list一样操作bitarray对象</span><br><span class="line">a[1:8] = 1</span><br><span class="line"></span><br><span class="line">#bitarray还提供了一些特殊的方法，如：all()</span><br><span class="line">#当bitarray中所有的元素都为1时，all()返回为True</span><br><span class="line">if a.all():</span><br><span class="line">    print &quot;all bits are True.&quot;</span><br></pre></td></tr></table></figure></p>
<p>关于bitarrary的说明详见Github上的<a href="https://github.com/ilanschnell/bitarrayhttp://note.youdao.com/" target="_blank" rel="noopener">bitarray项目</a></p>
<h3>位运算的应用</h3>
<p>常见的应用如判断奇偶数 X &amp; 0x1，变换符号位 ~X + 1，数字交换等，详细可以看参考链接中的文章
下面笔者想就实际项目中的一个例子来说明位操作的应用。</p>
<p>下表是一个TS Package header的说明（TS流是流媒体行业常用的传输格式），我们看到为了减少不必要的浪费，包头在定义域的时候都是按位进行定义的，那么我们如果想要取相应的域的值，也就需要使用位操作了。</p>
<p><strong>Packet Header（包头）信息说明</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>bit数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>sync_byte</td>
<td>8bits</td>
<td>同步字节</td>
</tr>
<tr>
<td>2</td>
<td>transport_error_indicator</td>
<td>1bit</td>
<td>错误指示信息（1：该包至少有1bits传输错误）</td>
</tr>
<tr>
<td>3</td>
<td>payload_unit_start_indicator</td>
<td>1bit</td>
<td>负载单元开始标志（packet不满188字节时需填充）</td>
</tr>
<tr>
<td>4</td>
<td>transport_priority</td>
<td>1bit</td>
<td>传输优先级标志（1：优先级高）</td>
</tr>
<tr>
<td>5</td>
<td>PID</td>
<td>13bits</td>
<td>Packet ID号码，唯一的号码对应不同的包</td>
</tr>
<tr>
<td>6</td>
<td>transport_scrambling_control</td>
<td>2bits</td>
<td>加密标志（00：未加密；其他表示已加密）</td>
</tr>
<tr>
<td>7</td>
<td>adaptation_field_control</td>
<td>2bits</td>
<td>附加区域控制</td>
</tr>
<tr>
<td>8</td>
<td>continuity_counter</td>
<td>4bits</td>
<td>包递增计数器</td>
</tr>
</tbody>
</table>
<p>我们以取PID值为例，当我们获取到包头的字节串之后，我们需要如下几个步骤：</p>
<ol>
<li>需要取到第2个字节，然后忽略第二个字节的高三位（从表中可以看出高三位为其它信息与PID无关）；</li>
<li>将第二个字节的后5位数字左移8位，这样将其移到高位；</li>
<li>移位后与第3个字节的数值相加得到PID的值。</li>
</ol>
<p>要实现第一步，首先就要用到位操作中常用的mask技术，即通过将对应位为0的数值进行&amp;操作
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0b10110111 &amp; 0b00011111 #将高位的3位进行mask关闭操作，使得其值被去除</span><br></pre></td></tr></table></figure></p>
<p>要实现第二步，就需要用到左移操作，左移操作之后与第三个字节的数值相加就是实际的PID值
完整代码实现如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def get_package_pid(package):</span><br><span class="line">    if package is None:</span><br><span class="line">        raise Exception(&quot;get_package_pid param package is None.&quot;)</span><br><span class="line">    return ((ord(package[1]) &amp; 0x1f) &lt;&lt; 8) + ord(package[2])</span><br></pre></td></tr></table></figure></p>
<p>注:</p>
<p>1, ord()将byte串转化为对应的数字从而进行位运算；</p>
<p>2, 0x1f是十六进制表示，转化为二进制就是0b00011111.</p>
<h3>参考链接：</h3>
<p>https://segmentfault.com/a/1190000003789802</p>
<p>https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</p>
<p>https://github.com/wnduan/codecademy-py/blob/master/Bitwise-Operators.md</p>
<p>http://developer.51cto.com/art/200808/83641_all.htm</p>
</div><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:rebor.liu@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/geekpy" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">geekpy</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>