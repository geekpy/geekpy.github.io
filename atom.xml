<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geekpy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-26T08:05:55.238Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>geekpy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB索引详解</title>
    <link href="http://yoursite.com/2019/02/22/MongoDB%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/22/MongoDB索引详解/</id>
    <published>2019-02-22T08:03:58.000Z</published>
    <updated>2019-03-26T08:05:55.238Z</updated>
    
    <content type="html"><![CDATA[<h1>索引基础知识</h1><h2>什么是索引</h2><p>索引最常用的比喻就是书籍的目录，查询索引就像查询一本书的目录。本质上目录是将书中一小部分内容信息（比如题目）和内容的位置信息（页码）共同构成，而由于信息量小（只有题目），所以我们可以很快找到我们想要的信息片段，再根据页码找到相应的内容。同样索引也是只保留某个域的一部分信息（建立了索引的field的信息），以及对应的文档的位置信息。假设我们有如下文档（每行的数据在MongoDB中是存在于一个Document当中）</p><table><thead><tr><th>姓名</th><th>id</th><th>部门</th><th>city</th><th>score</th></tr></thead><tbody><tr><td>张三</td><td>2</td><td>xxx</td><td>Beijing</td><td>90</td></tr><tr><td>李四</td><td>1</td><td>xxx</td><td>Shanghai</td><td>70</td></tr><tr><td>王五</td><td>3</td><td>xxx</td><td>guangzhou</td><td>60</td></tr></tbody></table><p>假如我们想找id为2的document(即张三的记录)，如果没有索引，我们就需要扫描整个数据表，然后找出所有为2的document。当数据表中有大量documents的时候，这个时间就会非常长（从磁盘上查找数据还涉及大量的IO操作)。建立索引后会有什么变化呢？MongoDB会将id数据拿出来建立索引数据，如下</p><table><thead><tr><th>索引值</th><th>位置</th></tr></thead><tbody><tr><td>1</td><td>pos2</td></tr><tr><td>2</td><td>pos1</td></tr><tr><td>3</td><td>pos3</td></tr></tbody></table><p>这样我们就可以通过扫描这个小表找到document对应的位置。</p><p>查找过程示意图如下：<img src="https://upload-images.jianshu.io/upload_images/3959253-7e2a31d0b5301c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来源MongoDB官网"></p><p>为什么这样速度会快呢？这主要有几方面的因素</p><ol><li>索引数据通过B+树来存储，从而使得搜索的时间复杂度为O(log&lt;sub&gt;d&lt;/sub&gt;&lt;sup&gt;N&lt;/sup&gt;)级别的(d是B+树的度, 通常d的值比较大，比如大于100)，比原先O(N)的复杂度大幅下降。这个差距是惊人的，以一个实际例子来看，假设d=100，N=1亿，那么O(log&lt;sub&gt;d&lt;/sub&gt;&lt;sup&gt;N&lt;/sup&gt;) = 8, 而O(N)是1亿。是的，这就是算法的威力。</li><li>索引本身是在高速缓存当中，相比磁盘IO操作会有大幅的性能提升。（需要注意的是，有的时候数据量非常大的时候，索引数据也会非常大，当大到超出内存容量的时候，会导致部分索引数据存储在磁盘上，这会导致磁盘IO的开销大幅增加，从而影响性能，所以务必要保证有足够的内存能容下所有的索引数据）</li></ol><p>当然，事物总有其两面性，在提升查询速度的同时，由于要建立索引，所以写入操作时就需要额外的添加索引的操作，这必然会影响写入的性能，所以当有大量写操作而读操作比较少的时候，且对读操作性能不需要考虑的时候，就不适合建立索引。当然，目前大多数互联网应用都是读操作远大于写操作，因此建立索引很多时候是非常划算和必要的操作。</p><p>关于索引原理的详细解释可以参考文章<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>，虽然讲得是MySQL但是原理相似。</p><h2>MongoDB有哪些类型的索引</h2><h3>单字段索引 （Single Field Index）</h3><p>这个是最简单最常用的索引类型，比如我们上边的例子，为id建立一个单独的索引就是此种类型。<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta"># 为id field建立索引，1表示升序，-1表示降序，没有差别</span></span><br><span class="line">db.employee.createIndex(&#123;'id': <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>需要注意的是通常MongoDB会自动为我们的文档插入'_id' field，且已经按照升序进行索引，如果我们插入的文档中包含有'_id' field，则MongoDB就不会自动创建'_id' field，但是需要我们自己来保证唯一性从而唯一标识一个文档</p><h3>复合索引 (Compound Index)</h3><p>符合索引的原理如下图所示：<img src="https://upload-images.jianshu.io/upload_images/3959253-6b00f39c08c49406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复合索引示意图">上图查询索引的时候会先查询userid，再查询score，然后就可以找到对应的文档。对于复合索引需要注意以下几点：</p><h4>索引field的先后顺序很关键，影响有两方面：</h4><ol><li>MongoDB在复合索引中是根据prefix排序查询，就是说排在前面的可以单独使用。我们创建一个如下的索引<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.createIndex</span>(&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'city'</span>: <span class="number">1</span>, <span class="string">'score'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>我们如下的查询可以利用索引<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.find</span>(&#123;<span class="string">'id'</span>: xxx&#125;)</span><br><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.find</span>(&#123;<span class="string">'id'</span>: xxx, <span class="string">'city'</span>: xxx&#125;)</span><br><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.find</span>(&#123;<span class="string">'id'</span>: xxx, <span class="string">'city'</span>:xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure></p><p>但是如下的查询无法利用该索引<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.find</span>(&#123;<span class="string">'city'</span>: xxx&#125;)</span><br><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.find</span>(&#123;<span class="string">'city'</span>:xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure></p><p>还有一种特殊的情况，就是如下查询：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.find</span>(&#123;<span class="string">'id'</span>: xxx, <span class="string">'score'</span>: xxxx&#125;)</span><br></pre></td></tr></table></figure></p><p>这个查询也可以利用索引的前缀'id'来查询，但是却不能针对score进行查询，你可以说是部分利用了索引，因此其效率可能不如如下索引：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.collection</span><span class="selector-class">.createIndex</span>(&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'score'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>2.过滤出的document越少的field越应该放在前面，比如此例中id如果是唯一的，那么就应该放在最前面，因为这样通过id就可以锁定唯一一个文档。而如果通过city或者score过滤完成后还是会有大量文档，这就会影响最终的性能。</p><h4>索引的排序顺序不同</h4><p>复合索引最末尾的field，其排序顺序不同对于MongoDB的查询排序操作是有影响的。比如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.events</span><span class="selector-class">.createIndex</span>( &#123; <span class="attribute">username</span>: <span class="number">1</span>, date: -<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure></p><p>这种情况下， 如下的query可以利用索引：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.events</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>( &#123; <span class="attribute">username</span>: <span class="number">1</span>, date: -<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure></p><p>但是如下query则无法利用index进行排序<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.events</span><span class="selector-class">.find</span>()<span class="selector-class">.sort</span>( &#123; <span class="attribute">username</span>: <span class="number">1</span>, date: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure></p><h3>多key索引 （Multikey Index）</h3><p>这个主要是针对数据类型为数组的类型，如下示例：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span> : <span class="string">"jack"</span>, <span class="string">"age"</span> : <span class="number">19</span>, habbit: [<span class="string">"football, runnning"</span>]&#125;</span><br><span class="line">db<span class="selector-class">.person</span><span class="selector-class">.createIndex</span>( &#123;habbit: <span class="number">1</span>&#125; )  <span class="comment">// 自动创建多key索引</span></span><br><span class="line">db<span class="selector-class">.person</span><span class="selector-class">.find</span>( &#123;habbit: <span class="string">"football"</span>&#125; )</span><br></pre></td></tr></table></figure></p><h3>其它类型索引</h3><p>另外，MongoDB中还有其它如哈希索引，地理位置索引以及文本索引，主要用于一些特定场景，具体可以参考官网，在此不再详解</p><h3>索引属性</h3><p>索引主要有以下几个属性:</p><ul><li>unique：这个非常常用，用于限制索引的field是否具有唯一性属性，即保证该field的值唯一</li><li>partial：很有用，在索引的时候只针对符合特定条件的文档来建立索引，如下<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.restaurants.createIndex(</span><br><span class="line">   &#123; <span class="string">cuisine:</span> <span class="number">1</span>, <span class="string">name:</span> <span class="number">1</span> &#125;,</span><br><span class="line">   &#123; <span class="string">partialFilterExpression:</span> &#123; <span class="string">rating:</span> &#123; <span class="string">$gt:</span> <span class="number">5</span> &#125; &#125; &#125; <span class="comment">//只有当rating大于5时才会建立索引</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>这样做的好处是，我们可以只为部分数据建立索引，从而可以减少索引数据的量，除节省空间外，其检索性能也会因为较少的数据量而得到提升。</p><ul><li>sparse：可以认为是partial索引的一种特殊情况，由于MongoDB3.2之后已经支持partial属性，所以建议直接使用partial属性。</li><li>TTL。 可以用于设定文档有效期，有效期到自动删除对应的文档。</li></ul><h1>通过explain结果来分析性能</h1><p>我们往往会通过打点数据来分析业务的性能瓶颈，这时，我们会发现很多瓶颈都是出现在数据库相关的操作上，这时由于数据库的查询和存取都涉及大量的IO操作，而且有时由于使用不当，会导致IO操作的大幅度增长，从而导致了产生性能问题。而MongoDB提供了一个explain工具来用于分析数据库的操作。直接拿官网的示例来做说明：</p><p>假设我们在inventory collection中有如下文档：<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">1</span>, <span class="string">"item"</span> : <span class="string">"f1"</span>, <span class="string">type:</span> <span class="string">"food"</span>, <span class="string">quantity:</span> <span class="number">500</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">2</span>, <span class="string">"item"</span> : <span class="string">"f2"</span>, <span class="string">type:</span> <span class="string">"food"</span>, <span class="string">quantity:</span> <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">3</span>, <span class="string">"item"</span> : <span class="string">"p1"</span>, <span class="string">type:</span> <span class="string">"paper"</span>, <span class="string">quantity:</span> <span class="number">200</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">4</span>, <span class="string">"item"</span> : <span class="string">"p2"</span>, <span class="string">type:</span> <span class="string">"paper"</span>, <span class="string">quantity:</span> <span class="number">150</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">5</span>, <span class="string">"item"</span> : <span class="string">"f3"</span>, <span class="string">type:</span> <span class="string">"food"</span>, <span class="string">quantity:</span> <span class="number">300</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">6</span>, <span class="string">"item"</span> : <span class="string">"t1"</span>, <span class="string">type:</span> <span class="string">"toys"</span>, <span class="string">quantity:</span> <span class="number">500</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">7</span>, <span class="string">"item"</span> : <span class="string">"a1"</span>, <span class="string">type:</span> <span class="string">"apparel"</span>, <span class="string">quantity:</span> <span class="number">250</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">8</span>, <span class="string">"item"</span> : <span class="string">"a2"</span>, <span class="string">type:</span> <span class="string">"apparel"</span>, <span class="string">quantity:</span> <span class="number">400</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">9</span>, <span class="string">"item"</span> : <span class="string">"t2"</span>, <span class="string">type:</span> <span class="string">"toys"</span>, <span class="string">quantity:</span> <span class="number">50</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="number">10</span>, <span class="string">"item"</span> : <span class="string">"f4"</span>, <span class="string">type:</span> <span class="string">"food"</span>, <span class="string">quantity:</span> <span class="number">75</span> &#125;</span><br></pre></td></tr></table></figure></p><p>假设此时没有建立索引，做如下查询：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.find</span>( &#123; <span class="attribute">quantity</span>: &#123; $gte: <span class="number">100</span>, $lte: <span class="number">200</span> &#125; &#125; )</span><br></pre></td></tr></table></figure></p><p>返回结果如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"item"</span> : <span class="string">"f2"</span>, <span class="attr">"type"</span> : <span class="string">"food"</span>, <span class="attr">"quantity"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">3</span>, <span class="attr">"item"</span> : <span class="string">"p1"</span>, <span class="attr">"type"</span> : <span class="string">"paper"</span>, <span class="attr">"quantity"</span> : <span class="number">200</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">4</span>, <span class="attr">"item"</span> : <span class="string">"p2"</span>, <span class="attr">"type"</span> : <span class="string">"paper"</span>, <span class="attr">"quantity"</span> : <span class="number">150</span> &#125;</span><br></pre></td></tr></table></figure></p><p>这是我们可以通过explain来分析整个查询的过程：<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># explain 有三种模式： <span class="string">"queryPlanner"</span>, <span class="string">"executionStats"</span>, and <span class="string">"allPlansExecution"</span>.</span></span><br><span class="line"><span class="meta"># 其中最常用的就是第二种<span class="string">"executionStats"</span>，它会返回具体执行的时候的统计数据</span></span><br><span class="line">db.inventory.find(</span><br><span class="line">   &#123; quantity: &#123; $gte: <span class="number">100</span>, $lte: <span class="number">200</span> &#125; &#125;</span><br><span class="line">).explain(<span class="string">"executionStats"</span>)</span><br></pre></td></tr></table></figure></p><p>explain的结果如下：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"queryPlanner"</span> : &#123;</span><br><span class="line">         <span class="string">"plannerVersion"</span> : <span class="number">1</span>,</span><br><span class="line">         ...</span><br><span class="line">         <span class="string">"winningPlan"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"executionStats"</span> : &#123;</span><br><span class="line">      <span class="string">"executionSuccess"</span> : true,</span><br><span class="line">      <span class="string">"nReturned"</span> : <span class="number">3</span>,  # 查询返回的document数量</span><br><span class="line">      <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>, # 执行查询所用的时间</span><br><span class="line">      <span class="string">"totalKeysExamined"</span> : <span class="number">0</span>, # 总共查询了多少个key，由于没有使用索引，因此这里为<span class="number">0</span></span><br><span class="line">      <span class="string">"totalDocsExamined"</span> : <span class="number">10</span>, # 总共在磁盘查询了多少个document，由于是全表扫描，我们总共有<span class="number">10</span>个documents，因此，这里为<span class="number">10</span></span><br><span class="line">      <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">         <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,  # 注意这里，<span class="string">"COLLSCAN"</span>意味着全表扫描</span><br><span class="line">         ...</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的结果中有一个&quot;stage&quot;字段，上例中stage为&quot;COLLSCAN&quot;，而MongoDB总共有如下几种stage：</p><ul><li>COLLSCAN – Collection scan</li><li>IXSCAN – Scan of data in index keys</li><li>FETCH – Retrieving documents</li><li>SHARD_MERGE – Merging results from shards</li><li>SORT – Explicit sort rather than using index order</li></ul><p>现在我们来创建一个索引：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.createIndex</span>( &#123; <span class="attribute">quantity</span>: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure></p><p>再来看下explain的结果</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.find</span>(</span><br><span class="line">   &#123; <span class="attribute">quantity</span>: &#123; $gte: <span class="number">100</span>, $lte: <span class="number">200</span> &#125; &#125;</span><br><span class="line">)<span class="selector-class">.explain</span>("<span class="selector-tag">executionStats</span>")</span><br></pre></td></tr></table></figure></p><p>结果如下：<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"queryPlanner"</span> : &#123;</span><br><span class="line">         <span class="string">"plannerVersion"</span> : <span class="number">1</span>,</span><br><span class="line">         ...</span><br><span class="line">         <span class="string">"winningPlan"</span> : &#123;</span><br><span class="line">               <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">               <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                  <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,  # 这里<span class="string">"IXSCAN"</span>意味着索引扫描</span><br><span class="line">                  <span class="string">"keyPattern"</span> : &#123;</span><br><span class="line">                     <span class="string">"quantity"</span> : <span class="number">1</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  ...</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"executionStats"</span> : &#123;</span><br><span class="line">         <span class="string">"executionSuccess"</span> : <span class="literal">true</span>,</span><br><span class="line">         <span class="string">"nReturned"</span> : <span class="number">3</span>,</span><br><span class="line">         <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">         <span class="string">"totalKeysExamined"</span> : <span class="number">3</span>,  # 这里nReturned、totalKeysExamined和totalDocsExamined相等说明索引没有问题，因为我们通过索引快速查找到了三个文档，且从磁盘上也是去取这三个文档，并返回三个文档。</span><br><span class="line">         <span class="string">"totalDocsExamined"</span> : <span class="number">3</span>,</span><br><span class="line">         <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">            ...</span><br><span class="line">         &#125;,</span><br><span class="line">         ...</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看下如何通过explain来比较compound index的性能，之前我们在介绍复合索引的时候已经说过field的顺序会影响查询的效率。有时这种顺序并不太好确定（比如field的值都不是unique的），那么怎么判断哪种顺序的复合索引的效率高呢，这就像需要explain结合hint来进行分析。比如我们要做如下查询：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.find</span>( &#123;</span><br><span class="line">   <span class="attribute">quantity</span>: &#123;</span><br><span class="line">      $gte: <span class="number">100</span>, $lte: <span class="number">300</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="selector-tag">type</span>: "<span class="selector-tag">food</span>"</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure></p><p>会返回如下文档：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">2</span>, <span class="attr">"item"</span> : <span class="string">"f2"</span>, <span class="attr">"type"</span> : <span class="string">"food"</span>, <span class="attr">"quantity"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="attr">"_id"</span> : <span class="number">5</span>, <span class="attr">"item"</span> : <span class="string">"f3"</span>, <span class="attr">"type"</span> : <span class="string">"food"</span>, <span class="attr">"quantity"</span> : <span class="number">300</span> &#125;</span><br></pre></td></tr></table></figure></p><p>现在我们要比较如下两种复合索引<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.createIndex</span>( &#123; <span class="attribute">quantity</span>: <span class="number">1</span>, type: <span class="number">1</span> &#125; )</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.createIndex</span>( &#123; <span class="attribute">type</span>: <span class="number">1</span>, quantity: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure></p><p>分析索引 { quantity: 1, type: 1 }的情况</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 结合<span class="selector-tag">hint</span>和<span class="selector-tag">explain</span>来进行分析</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.find</span>(</span><br><span class="line">   &#123; <span class="attribute">quantity</span>: &#123; $gte: <span class="number">100</span>, $lte: <span class="number">300</span> &#125;, <span class="selector-tag">type</span>: "<span class="selector-tag">food</span>" &#125;</span><br><span class="line">)<span class="selector-class">.hint</span>(&#123; <span class="attribute">quantity</span>: <span class="number">1</span>, type: <span class="number">1</span> &#125;)<span class="selector-class">.explain</span>("<span class="selector-tag">executionStats</span>") # 这里使用<span class="selector-tag">hint</span>会强制数据库使用索引 &#123; <span class="attribute">quantity</span>: <span class="number">1</span>, type: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><p>explain结果<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"queryPlanner"</span> : &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="string">"winningPlan"</span> : &#123;</span><br><span class="line">         <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">         <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">            <span class="string">"keyPattern"</span> : &#123;</span><br><span class="line">               <span class="string">"quantity"</span> : <span class="number">1</span>,</span><br><span class="line">               <span class="string">"type"</span> : <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"executionStats"</span> : &#123;</span><br><span class="line">      <span class="string">"executionSuccess"</span> : true,</span><br><span class="line">      <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="string">"totalKeysExamined"</span> : <span class="number">5</span>,  # 这里是<span class="number">5</span>与totalDocsExamined、nReturned都不相等</span><br><span class="line">      <span class="string">"totalDocsExamined"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看下索引 { type: 1, quantity: 1 } 的分析</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.find</span>(</span><br><span class="line">   &#123; <span class="attribute">quantity</span>: &#123; $gte: <span class="number">100</span>, $lte: <span class="number">300</span> &#125;, <span class="selector-tag">type</span>: "<span class="selector-tag">food</span>" &#125;</span><br><span class="line">)<span class="selector-class">.hint</span>(&#123; <span class="attribute">type</span>: <span class="number">1</span>, quantity: <span class="number">1</span> &#125;)<span class="selector-class">.explain</span>("<span class="selector-tag">executionStats</span>")</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"queryPlanner"</span> : &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="string">"winningPlan"</span> : &#123;</span><br><span class="line">         <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">         <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">            <span class="string">"keyPattern"</span> : &#123;</span><br><span class="line">               <span class="string">"type"</span> : <span class="number">1</span>,</span><br><span class="line">               <span class="string">"quantity"</span> : <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"executionStats"</span> : &#123;</span><br><span class="line">      <span class="string">"executionSuccess"</span> : <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="string">"totalKeysExamined"</span> : <span class="number">2</span>, # 这里是<span class="number">2</span>，与totalDocsExamined、nReturned相同</span><br><span class="line">      <span class="string">"totalDocsExamined"</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出后一种索引的totalKeysExamined返回是2，相比前一种索引的5，显然更有效率。</p><h1>References</h1><ul><li><a href="https://docs.mongodb.com/manual/indexes/" target="_blank" rel="noopener">MongoDB Index</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li><li><a href="http://www.mongoing.com/archives/2797" target="_blank" rel="noopener">MongoDB索引原理</a></li><li><a href="https://docs.mongodb.com/manual/tutorial/analyze-query-plan/" target="_blank" rel="noopener">Analyze Query Performance</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;索引基础知识&lt;/h1&gt;
&lt;h2&gt;什么是索引&lt;/h2&gt;
&lt;p&gt;索引最常用的比喻就是书籍的目录，查询索引就像查询一本书的目录。本质上目录是将书中一小部分内容信息（比如题目）和内容的位置信息（页码）共同构成，而由于信息量小（只有题目），所以我们可以很快找到我们想要的信息片段，再
      
    
    </summary>
    
      <category term="database" scheme="http://yoursite.com/categories/database/"/>
    
    
      <category term="index" scheme="http://yoursite.com/tags/index/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>gRPC详解</title>
    <link href="http://yoursite.com/2019/02/16/gRPC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/16/gRPC详解/</id>
    <published>2019-02-16T07:30:04.000Z</published>
    <updated>2019-03-26T07:32:57.949Z</updated>
    
    <content type="html"><![CDATA[<h2>gRPC是什么？</h2><p>gRPC是什么可以用官网的一句话来概括</p><blockquote><p>A high-performance, open-source universal RPC framework</p></blockquote><p>**所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。**如下图所示就是一个典型的RPC结构图。</p><p><img src="https://upload-images.jianshu.io/upload_images/3959253-76284b64125a8673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RPC通信"></p><h2>gRPC有什么好处以及在什么场景下需要用gRPC</h2><p>既然是server/client模型，那么我们直接用restful api不是也可以满足吗，为什么还需要RPC呢？下面我们就来看看RPC到底有哪些优势</p><h3>gRPC vs. Restful API</h3><p>gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下：</p><ul><li>gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。关于protobuf可以参见笔者之前的小文<a href="https://www.jianshu.com/p/b723053a86a6" target="_blank" rel="noopener">Google Protobuf简明教程</a></li><li>另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。</li><li>gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）</li></ul><h3>使用场景</h3><ul><li>需要对接口进行严格约束的情况，比如我们提供了一个公共的服务，很多人，甚至公司外部的人也可以访问这个服务，这时对于接口我们希望有更加严格的约束，我们不希望客户端给我们传递任意的数据，尤其是考虑到安全性的因素，我们通常需要对接口进行更加严格的约束。这时gRPC就可以通过protobuf来提供严格的接口约束。</li><li>对于性能有更高的要求时。有时我们的服务需要传递大量的数据，而又希望不影响我们的性能，这个时候也可以考虑gRPC服务，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。</li></ul><p>但是，通常我们不会去单独使用gRPC，而是将gRPC作为一个部件进行使用，这是因为在生产环境，我们面对大并发的情况下，需要使用分布式系统来去处理，而gRPC并没有提供分布式系统相关的一些必要组件。而且，真正的线上服务还需要提供包括负载均衡，限流熔断，监控报警，服务注册和发现等等必要的组件。不过，这就不属于本篇文章讨论的主题了，我们还是先继续看下如何使用gRPC。</p><h2>gRPC HelloWorld实例详解</h2><p>gRPC的使用通常包括如下几个步骤：</p><ol><li>通过protobuf来定义接口和数据类型</li><li>编写gRPC server端代码</li><li>编写gRPC client端代码下面来通过一个实例来详细讲解上述的三步。下边的hello world实例完成之后，其目录结果如下：<img src="https://upload-images.jianshu.io/upload_images/3959253-df25b1a5150fe55d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="project helloworld"></li></ol><h3>定义接口和数据类型</h3><ul><li><p>通过protobuf定义接口和数据类型<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">package rpc_package;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">define</span> <span class="section">a</span> service</span><br><span class="line">service <span class="keyword">HelloWorldService</span> &#123;</span><br><span class="line">    // define the interface <span class="keyword">and</span> data <span class="built_in">type</span></span><br><span class="line">    rpc SayHello (HelloRequest) <span class="literal">returns</span> (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">define</span> <span class="section">the</span> data type of request</span><br><span class="line">message <span class="keyword">HelloRequest</span> &#123;</span><br><span class="line">    string <span class="literal">name</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">define</span> <span class="section">the</span> data type of response</span><br><span class="line">message <span class="keyword">HelloReply</span> &#123;</span><br><span class="line">    string <span class="literal">message</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>使用gRPC protobuf生成工具生成对应语言的库函数<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I=<span class="string">./protos</span> <span class="params">--python_out=</span><span class="string">./rpc_package</span> <span class="params">--grpc_python_out=</span><span class="string">./rpc_package</span> <span class="string">./protos/user_info.proto</span></span><br></pre></td></tr></table></figure></p></li></ul><p>这个指令会自动生成rpc_package文件夹中的<code>helloworld_pb2.py</code>和<code>helloworld_pb2_grpc.py</code>，但是不会自动生成<code>__init__.py</code>文件，需要我们手动添加</p><p>关于protobuf的详细解释请参考<a href="https://www.jianshu.com/p/b723053a86a6" target="_blank" rel="noopener">Google Protobuf简明教程</a></p><h3>gRPC server端代码</h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*-coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rpc_package.helloworld_pb2_grpc <span class="keyword">import</span> add_HelloWorldServiceServicer_to_server, \ </span><br><span class="line">    HelloWorldServiceServicer</span><br><span class="line"><span class="keyword">from</span> rpc_package.helloworld_pb2 <span class="keyword">import</span> HelloRequest, HelloReply</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(HelloWorldServiceServicer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里实现我们定义的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SayHello</span><span class="params">(self, request, context)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HelloReply(message=<span class="string">'Hello, %s!'</span> % request.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 这里通过thread pool来并发处理server的任务</span></span><br><span class="line">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将对应的任务处理函数添加到rpc server中</span></span><br><span class="line">    add_HelloWorldServiceServicer_to_server(Hello(), server)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里使用的非安全接口，世界gRPC支持TLS/SSL安全连接，以及各种鉴权机制</span></span><br><span class="line">    server.add_insecure_port(<span class="string">'[::]:50000'</span>)</span><br><span class="line">    server.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            time.sleep(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        server.stop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure></p><h3>gRPC client端代码</h3><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">from</span> rpc_package.helloworld_pb2 <span class="keyword">import</span> HelloRequest, HelloReply</span><br><span class="line"><span class="keyword">from</span> rpc_package.helloworld_pb2_grpc <span class="keyword">import</span> HelloWorldServiceStub</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用with语法保证channel自动close</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">'localhost:50000'</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        <span class="comment"># 客户端通过stub来实现rpc通信</span></span><br><span class="line">        stub = HelloWorldServiceStub(channel)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 客户端必须使用定义好的类型，这里是HelloRequest类型</span></span><br><span class="line">        response = stub.SayHello(HelloRequest(name=<span class="string">'eric'</span>))</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"hello client received: "</span> + response.message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure></p><h3>演示</h3><p>先执行server端代码<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> hello_server.<span class="keyword">py</span></span><br></pre></td></tr></table></figure></p><p>接着执行client端代码如下：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  grpc_test python hello_client.py</span><br><span class="line">hello<span class="built_in"> client </span>received: Hello, eric!</span><br></pre></td></tr></table></figure></p><h2>References</h2><ul><li><a href="https://grpc.io/" target="_blank" rel="noopener">gRPC官网</a></li><li><a href="https://www.jianshu.com/p/b723053a86a6" target="_blank" rel="noopener">Google Protobuf简明教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;gRPC是什么？&lt;/h2&gt;
&lt;p&gt;gRPC是什么可以用官网的一句话来概括&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A high-performance, open-source universal RPC framework&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;**
      
    
    </summary>
    
      <category term="架构" scheme="http://yoursite.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="gRPC" scheme="http://yoursite.com/tags/gRPC/"/>
    
      <category term="rpc" scheme="http://yoursite.com/tags/rpc/"/>
    
      <category term="protobuf" scheme="http://yoursite.com/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>Pandas系列7-DataFrame之合并组合</title>
    <link href="http://yoursite.com/2018/10/06/pandas7/"/>
    <id>http://yoursite.com/2018/10/06/pandas7/</id>
    <published>2018-10-06T08:20:12.000Z</published>
    <updated>2018-10-06T08:23:27.023Z</updated>
    
    <content type="html"><![CDATA[<p>在Pandas的实践过程中，我们经常需要将两个DataFrame合并组合在一起再进行处理，比如将不同来源的数据合并在一起，或者将不同日期的DataFrame合并在一起。DataFrame的合并组合从方向上分，大体上分为两种情况：横向的，纵向的。（这个很容易理解吧）<a id="more"></a>看下如下的图示（图片来自Pandas官网）<img src="https://upload-images.jianshu.io/upload_images/3959253-72f93e20760715b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="横向"></p><p><img src="https://upload-images.jianshu.io/upload_images/3959253-3d710611ff37ed8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="纵向"></p><p>另外需要注意的是，两个DataFrame在合在一起的时候，如果针对重叠项（比如都有column B)会有两种不同的处理方式，一种是针对重叠项进行合并处理（比如相加，或者直接取代）；另一种是忽略重叠项，只是简单的组合在一起。前者我们称为合并，后者我们叫做组合。</p><p>另外，在Pandas中有很多不同函数和不同用法，比如有concat, join, merge, append，它们各有不同的使用场景。</p><h2>纵向连接</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">In [45]: import pandas as pd</span><br><span class="line"></span><br><span class="line">In [46]: df = pd.DataFrame(&#123;&quot;name&quot;: [&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;], &quot;city&quot;: [&quot;beijing&quot;</span><br><span class="line">    ...: , &quot;beijing&quot;, &quot;shenzhen&quot;], &quot;order&quot;: [12, 33, 67]&#125;)</span><br><span class="line"></span><br><span class="line">In [47]: df</span><br><span class="line">Out[47]:</span><br><span class="line">       city      name  order</span><br><span class="line">0   beijing  zhangsan     12</span><br><span class="line">1   beijing      lisi     33</span><br><span class="line">2  shenzhen    wangwu     67</span><br><span class="line"></span><br><span class="line">In [48]: df2 = pd.DataFrame(&#123;&quot;name&quot;: [&quot;zhanghai&quot;, &quot;liyang&quot;, &quot;wangjing&quot;], &quot;city&quot;: [&quot;sha</span><br><span class="line">    ...: nghai&quot;, &quot;shenzhen&quot;, &quot;chengdu&quot;], &quot;order&quot;: [2, 3, 7]&#125;)</span><br><span class="line"></span><br><span class="line">In [49]: df2</span><br><span class="line">Out[49]:</span><br><span class="line">       city      name  order</span><br><span class="line">0  shanghai  zhanghai      2</span><br><span class="line">1  shenzhen    liyang      3</span><br><span class="line">2   chengdu  wangjing      7</span><br><span class="line"></span><br><span class="line"># concat默认按行拼接(即纵向连接，axis=0), 也可以按列来连接(axis=1)</span><br><span class="line"># 注意concat拼接时，其参数是一个数组 ，因此可以拼接多个DataFrame</span><br><span class="line">In [51]: pd.concat([df, df2])</span><br><span class="line">Out[51]:</span><br><span class="line">       city      name  order</span><br><span class="line">0   beijing  zhangsan     12</span><br><span class="line">1   beijing      lisi     33</span><br><span class="line">2  shenzhen    wangwu     67</span><br><span class="line">0  shanghai  zhanghai      2</span><br><span class="line">1  shenzhen    liyang      3</span><br><span class="line">2   chengdu  wangjing      7</span><br><span class="line"></span><br><span class="line"># append是concat的一种快捷方式，用于将两个DataFrame直接拼接在一起</span><br><span class="line"># append的参数即可以是一个DataFrame，也可以是一个数组，这种情况下可以合并多个DataFrame</span><br><span class="line">In [52]: df.append(df2)</span><br><span class="line">Out[52]:</span><br><span class="line">       city      name  order</span><br><span class="line">0   beijing  zhangsan     12</span><br><span class="line">1   beijing      lisi     33</span><br><span class="line">2  shenzhen    wangwu     67</span><br><span class="line">0  shanghai  zhanghai      2</span><br><span class="line">1  shenzhen    liyang      3</span><br><span class="line">2   chengdu  wangjing      7</span><br></pre></td></tr></table></figure></p><h2>横向连接与合并</h2><p>前面我们已经知道concat不仅可以纵向连接，也可以横向连接<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">8</span>]: df3 = pd.concat([df, df2], <span class="attr">join=</span><span class="string">"inner"</span>, <span class="attr">axis=</span><span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">9</span>]: df3</span><br><span class="line">Out[<span class="number">9</span>]:</span><br><span class="line">       city      name  <span class="keyword">order</span>      <span class="title">city</span>      name  order</span><br><span class="line"><span class="number">0</span>   beijing  zhangsan     <span class="number">12</span>  shanghai  zhanghai      <span class="number">2</span></span><br><span class="line"><span class="number">1</span>   beijing      lisi     <span class="number">33</span>  shenzhen    liyang      <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  shenzhen    wangwu     <span class="number">67</span>   chengdu  wangjing      <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，concat是通过index来作为拼接的依据，什么意思呢，看下面的例子</span></span><br><span class="line"><span class="comment"># 我们重新assign index给df3</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">12</span>]: df3 = pd.DataFrame(&#123;<span class="string">"name"</span>: [<span class="string">"zhanghai"</span>, <span class="string">"liyang"</span>, <span class="string">"wangjing"</span>], <span class="string">"city"</span>: [<span class="string">"shanghai"</span>, <span class="string">"shenzhen"</span>, <span class="string">"chengdu"</span>], <span class="string">"order"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>]&#125;, <span class="attr">index=</span>[</span><br><span class="line">    ...: <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># df3的row index变为了1， 3， 9</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">13</span>]: df3</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">       city      name  order</span><br><span class="line"><span class="number">1</span>  shanghai  zhanghai      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  shenzhen    liyang      <span class="number">3</span></span><br><span class="line"><span class="number">9</span>   chengdu  wangjing      <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用join="outer"的时候，取index的并集，index相同的行会放在同一行，而不同的行会分别列出</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">14</span>]: df4 = pd.concat([df, df3], <span class="attr">join=</span><span class="string">"outer"</span>, <span class="attr">axis=</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">In</span> [<span class="number">15</span>]: df4</span><br><span class="line">Out[<span class="number">15</span>]:</span><br><span class="line">       city      name  <span class="keyword">order</span>      <span class="title">city</span>      name  order</span><br><span class="line"><span class="number">0</span>   beijing  zhangsan   <span class="number">12.0</span>       NaN       NaN    NaN</span><br><span class="line"><span class="number">1</span>   beijing      lisi   <span class="number">33.0</span>  shanghai  zhanghai    <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>  shenzhen    wangwu   <span class="number">67.0</span>       NaN       NaN    NaN</span><br><span class="line"><span class="number">3</span>       NaN       NaN    NaN  shenzhen    liyang    <span class="number">3.0</span></span><br><span class="line"><span class="number">9</span>       NaN       NaN    NaN   chengdu  wangjing    <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当join="inner"时，我们取交集，index相同的行才会拼接在一起</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">16</span>]: df5 = pd.concat([df, df3], <span class="attr">join=</span><span class="string">"inner"</span>, <span class="attr">axis=</span><span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">17</span>]: df5</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">      city  name  <span class="keyword">order</span>      <span class="title">city</span>      name  order</span><br><span class="line"><span class="number">1</span>  beijing  lisi     <span class="number">33</span>  shanghai  zhanghai      <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>我们看到concat仍然是一种拼接，其根据index进行join，而merge更加灵活，可以根据指定的column来进行合并，如下：<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">18</span>]: df</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">18</span>]:</span><br><span class="line">       city      name  order</span><br><span class="line"><span class="number">0</span>   beijing  zhangsan     <span class="number">12</span></span><br><span class="line"><span class="number">1</span>   beijing      lisi     <span class="number">33</span></span><br><span class="line"><span class="number">2</span>  shenzhen    wangwu     <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">19</span>]: df2</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">19</span>]:</span><br><span class="line">       city      name  order</span><br><span class="line"><span class="number">1</span>  shanghai  zhanghai      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  shenzhen    liyang      <span class="number">3</span></span><br><span class="line"><span class="number">9</span>   chengdu  wangjing      <span class="number">7</span></span><br><span class="line"></span><br><span class="line"># 根据指定的列<span class="string">"city"</span>进行合并，同时how=<span class="string">"outer"</span>意味着join的方式</span><br><span class="line"># on也可以跟一个list，这样就可以针对多个列进行join</span><br><span class="line"><span class="keyword">In</span> [<span class="number">21</span>]: df6 = df.merge(df2, on=<span class="string">"city"</span>, how=<span class="string">"outer"</span>)</span><br><span class="line"></span><br><span class="line"># 注意同名的列（非on column)，会默认添加<span class="string">"_x"</span>, <span class="string">"_y"</span>后缀</span><br><span class="line"><span class="keyword">In</span> [<span class="number">22</span>]: df6</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">22</span>]:</span><br><span class="line">       city    name_x  order_x    name_y  order_y</span><br><span class="line"><span class="number">0</span>   beijing  zhangsan     <span class="number">12.0</span>       <span class="meta">NaN</span>      <span class="meta">NaN</span></span><br><span class="line"><span class="number">1</span>   beijing      lisi     <span class="number">33.0</span>       <span class="meta">NaN</span>      <span class="meta">NaN</span></span><br><span class="line"><span class="number">2</span>  shenzhen    wangwu     <span class="number">67.0</span>    liyang      <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>  shanghai       <span class="meta">NaN</span>      <span class="meta">NaN</span>  zhanghai      <span class="number">2.0</span></span><br><span class="line"><span class="number">4</span>   chengdu       <span class="meta">NaN</span>      <span class="meta">NaN</span>  wangjing      <span class="number">7.0</span></span><br></pre></td></tr></table></figure></p><p>可以针对多个列进行join，并重新命名后缀，如下：<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">31</span>]: df2</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line">       city      name  order</span><br><span class="line"><span class="number">1</span>  shanghai  zhanghai      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  shenzhen    liyang     <span class="number">67</span></span><br><span class="line"><span class="number">9</span>   chengdu  wangjing     <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">32</span>]: df</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line">       city      name  order</span><br><span class="line"><span class="number">0</span>   beijing  zhangsan     <span class="number">12</span></span><br><span class="line"><span class="number">1</span>   beijing      lisi     <span class="number">33</span></span><br><span class="line"><span class="number">2</span>  shenzhen    wangwu     <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里针对column "city" 和 "order"进行join</span></span><br><span class="line"><span class="comment"># 同时我们可以通过suffixes来为同名的列赋予更有意义的名字</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">35</span>]: df7 = df.merge(df2, <span class="attr">on=</span>[<span class="string">"city"</span>, <span class="string">"order"</span>], <span class="attr">how=</span><span class="string">"outer"</span>, <span class="attr">suffixes=</span>('_left', '_right'))</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">36</span>]: df7</span><br><span class="line">Out[<span class="number">36</span>]:</span><br><span class="line">       city name_left  <span class="keyword">order</span> <span class="title">name_right</span></span><br><span class="line"><span class="number">0</span>   beijing  zhangsan     <span class="number">12</span>        NaN</span><br><span class="line"><span class="number">1</span>   beijing      lisi     <span class="number">33</span>        NaN</span><br><span class="line"><span class="number">2</span>  shenzhen    wangwu     <span class="number">67</span>     liyang</span><br><span class="line"><span class="number">3</span>  shanghai       NaN      <span class="number">2</span>   zhanghai</span><br><span class="line"><span class="number">4</span>   chengdu       NaN     <span class="number">33</span>   wangjing</span><br></pre></td></tr></table></figure></p><p>关于merge还有几个常用的参数说明如下：<strong>left_index &amp; right_index</strong>: 当我们需要通过index来进行join的时候（类似concat），则可以使用left_index 或者right_index.<strong>sort</strong>: 默认为False，如果True则将join的key按照字典顺序进行排序，比如我们按照&quot;city&quot;进行join的时候，会按照&quot;city&quot;的字典顺序进行排序。但如果我们不需要排序，则可以将其置为False，以提高性能<strong>validate</strong>: 主要针对duplicate的情况，它有以下几个参数可以设置“one_to_one” or “1:1”: checks if merge keys are unique in both left and right datasets.“one_to_many” or “1:m”: checks if merge keys are unique in left dataset.“many_to_one” or “m:1”: checks if merge keys are unique in right dataset.“many_to_many” or “m:m”: allowed, but does not result in checks.更多关于merge的说明参考如下链接：<a href="http://pandas.pydata.org/pandas-docs/stable/merging.html#database-style-dataframe-joining-merging" target="_blank" rel="noopener">关于merge的说明</a></p><p>另外，join是merge的一种简便写法，其底层是通过merge来实现的，如下两种表达方式是相同的。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left.join(right, <span class="attribute">on</span>=key_or_keys)</span><br><span class="line">pd.merge(left, right, <span class="attribute">left_on</span>=key_or_keys, <span class="attribute">right_index</span>=<span class="literal">True</span>,</span><br><span class="line">      <span class="attribute">how</span>=<span class="string">'left'</span>, <span class="attribute">sort</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p><p>示例：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 示例来自官网</span><br><span class="line">In [<span class="number">85</span>]: left = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">   ....:                      <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>],</span><br><span class="line">   ....:                      <span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>]&#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: right = pd.DataFrame(&#123;<span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>],</span><br><span class="line">   ....:                       <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>]&#125;,</span><br><span class="line">   ....:                       index=[<span class="string">'K0'</span>, <span class="string">'K1'</span>])</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: result = left.join(right, on=<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/3959253-11fe4f7fb81567d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="merging_join_key_columns.png">需要注意的是当要join的两个DataFrame有同名的列时，必须指定suffix，否则会报错，如下：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: df</span><br><span class="line">Out[<span class="number">45</span>]:</span><br><span class="line">       city      name  <span class="keyword">order</span></span><br><span class="line"><span class="keyword">0 </span>  <span class="keyword">beijing </span> zhangsan     <span class="number">12</span></span><br><span class="line"><span class="number">1</span>   <span class="keyword">beijing </span>     lisi     <span class="number">33</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">shenzhen </span>   wangwu     <span class="number">67</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: df2</span><br><span class="line">Out[<span class="number">46</span>]:</span><br><span class="line">       city      name  <span class="keyword">order</span></span><br><span class="line"><span class="keyword">1 </span> <span class="keyword">shanghai </span> zhanghai      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="keyword">shenzhen </span>   liyang     <span class="number">67</span></span><br><span class="line"><span class="number">9</span>   chengdu  wangjing     <span class="number">33</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: df.<span class="keyword">join(df2, </span>lsuffix=<span class="string">"_left"</span>, rsuffix=<span class="string">"_right"</span>)</span><br><span class="line">Out[<span class="number">47</span>]:</span><br><span class="line">  city_left name_left  <span class="keyword">order_left </span>city_right name_right  <span class="keyword">order_right</span></span><br><span class="line"><span class="keyword">0 </span>  <span class="keyword">beijing </span> zhangsan          <span class="number">12</span>        NaN        NaN          NaN</span><br><span class="line"><span class="number">1</span>   <span class="keyword">beijing </span>     lisi          <span class="number">33</span>   <span class="keyword">shanghai </span>  zhanghai          <span class="number">2</span>.<span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">shenzhen </span>   wangwu          <span class="number">67</span>        NaN        NaN          NaN</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Pandas的实践过程中，我们经常需要将两个DataFrame合并组合在一起再进行处理，比如将不同来源的数据合并在一起，或者将不同日期的DataFrame合并在一起。DataFrame的合并组合从方向上分，大体上分为两种情况：横向的，纵向的。（这个很容易理解吧）
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>史上最详解Python日期和时间处理（下）</title>
    <link href="http://yoursite.com/2018/08/25/python_time2/"/>
    <id>http://yoursite.com/2018/08/25/python_time2/</id>
    <published>2018-08-25T03:52:56.000Z</published>
    <updated>2018-10-06T07:56:40.209Z</updated>
    
    <content type="html"><![CDATA[<p>此下篇主要讲解跟时区相关的概念和程序中经常使用的场景，希望通过此文大家可以搞定所有时区相关的编程问题（如果还有不明白的地方，请联系我，我将进一步补充）。</p><p><a id="more"></a>本文的目录结构如下：</p><ul><li><a href="#%E6%97%B6%E5%8C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">时区基本概念</a><ul><li><a href="#%E6%97%B6%E5%8C%BA">时区</a></li><li><a href="#GMT%E5%92%8CUTC">GMT和UTC</a></li><li><a href="#%E6%97%B6%E5%8C%BA%E5%81%8F%E7%A7%BB">时区偏移(Offset)</a></li><li><a href="#%E5%A4%8F%E4%BB%A4%E6%97%B6">夏令时(DST)</a></li><li><a href="#%E6%A8%A1%E7%B3%8A%E6%97%B6%E9%97%B4">模糊时间(Ambiguous Time)</a></li></ul></li><li><a href="#%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA">设置时区</a><ul><li><a href="#tzinfo">tzinfo</a></li><li><a href="#dateutil">dateutil</a></li><li><a href="#pytz">pytz</a></li></ul></li><li><a href="#%E6%97%B6%E5%8C%BA%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">时区处理的最佳实践</a></li></ul><h2>时区基本概念</h2><h3>时区</h3><p>由于地球自转导致不同地区的人看到太阳升起和落下的时间不同，于是人们就定义了时区的概念，将全球分为24个时区，其中位于英国的本初子午线作为零时区中线，然后向东划分出十二个时区（分别为+1， +2....+12)，向西也划分成十二个时区(分别为-1, -2 .....-12)。其中最早进入新的一天的是+12时区，当+12时区为中午12点时，正好零时区进入第二天（它们相差12小时，所以+12）</p><h3>GMT和UTC</h3><p>GMT(Greenwich Mean Time)，即格林尼治标准时间，也就是本初子午线所在的时区。UTC(Universal Time Coordinated)，即标准世界时间。GMT和UTC虽然表示的时间相同，但是两个是不同的概念，大家注意区分，实践过程中，我们通常使用UTC时间作为标准时间。</p><h3>时区偏移Offset</h3><p>时区偏移(Offset)是指所处时区时间相对于UTC时间的偏移量，比如中国的CST时间其偏移量就是+8，即相对于UTC时间需要+8小时。有些程序会使用秒或者分钟来替代小时，所以使用的偏移量计算时间的时候需要注意具体使用的时间单位。具体可以参考<a href="https://en.wikipedia.org/wiki/UTC_offset" target="_blank" rel="noopener">wiki时区偏移</a></p><h3>夏令时(DST)</h3><p>关于夏令时我觉得<a href="https://blog.jijiechen.com/post/time-zone-and-dst-basics/#%E5%A4%8F%E4%BB%A4%E6%97%B6-dst" target="_blank" rel="noopener">这篇文章</a>已经讲解比较详细了, 大家可以直接参考，在此不再赘述。但是夏令时进一步增加了复杂度，这意味着即使同一个时区，一年中也会随着夏令时和非夏令时而导致offset的变化。</p><h3>模糊时间(Ambiguous Time)</h3><p>指的是在夏令时转换过程中的一段时间，在夏令时转换时，会有两个正确的时间，那么到底应该如何显示呢，所以要让程序知道到底选择哪个时间，就必须要有一个参数来确定这件事情。关于模糊时间的操作，Python2和Python3是不同的，具体可以参考Paul Ganssle的这篇文章<a href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html" title="Permalink to pytz: The Fastest Footgun in the West" target="_blank" rel="noopener">pytz: The Fastest Footgun in the West</a></p><h2>设置时区</h2><h3>tzinfo</h3><p>在《上篇》中我们已经说过Python用于表示时间的对象会分为原始的(naive)和有知的(aware)两种，而要表示有知的时间，就必须给相应的对象传递tzinfo参数。tzinfo参数主要用在datetime.datetime对象和datetime.time对象，其类初始化函数定义如下：<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># datetime.datetime</span><br><span class="line"><span class="keyword">class</span> datetime.datetime(<span class="built_in">year</span>, <span class="built_in">month</span>, <span class="built_in">day</span>[, <span class="built_in">hour</span>[, <span class="built_in">minute</span>[, <span class="built_in">second</span>[, microsecond[, tzinfo]]]]])</span><br><span class="line"></span><br><span class="line"># datetime.<span class="built_in">time</span></span><br><span class="line"><span class="keyword">class</span> datetime.<span class="built_in">time</span>([<span class="built_in">hour</span>[, <span class="built_in">minute</span>[, <span class="built_in">second</span>[, microsecond[, tzinfo]]]]])</span><br></pre></td></tr></table></figure></p><p>可以看到初始化datetime和time对象时，都有一个tzinfo参数，当我们传递一个tzinfo对象给这个参数的时候我们就可以初始化一个有知的时间对象。</p><p>那么这个tzinfo对象到底是怎么来的呢？先来看下Python官网的定义：</p><blockquote><p>This is an abstract base class, meaning that this class should not be instantiated directly. You need to derive a concrete subclass, and (at least) supply implementations of the standard <a href="https://docs.python.org/2/library/datetime.html#datetime.tzinfo" title="datetime.tzinfo" target="_blank" rel="noopener"><code>tzinfo</code></a> methods needed by the <a href="https://docs.python.org/2/library/datetime.html#datetime.datetime" title="datetime.datetime" target="_blank" rel="noopener"><code>datetime</code></a> methods you use. The <a href="https://docs.python.org/2/library/datetime.html#module-datetime" title="datetime: Basic date and time types." target="_blank" rel="noopener"><code>datetime</code></a> module does not supply any concrete subclasses of <a href="https://docs.python.org/2/library/datetime.html#datetime.tzinfo" title="datetime.tzinfo" target="_blank" rel="noopener"><code>tzinfo</code></a>.</p></blockquote><p>从这段定义我们可以看出，tzinfo只是一个抽象类，而且官网已经明确说了不提供相应的实现，那我们怎么做呢？有两种做法：一是自己实现，Python官网还给出了示例代码，参考<a href="https://docs.python.org/2/library/datetime.html#tzinfo-objects" target="_blank" rel="noopener">这里</a>；另一种就是使用我们下边要讲到的dateutil模块。</p><h3>dateutil</h3><ul><li><p>安装dateutil<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> python-dateutil</span><br></pre></td></tr></table></figure></p></li><li><p>简介官网对dateutil的介绍就一句话</p></li></ul><blockquote><p>The dateutil module provides powerful extensions to the standard datetime module, available in Python.</p></blockquote><p>看到了吧，专门为拓展datetime而开发的，其中我们感兴趣的主要是如何构造时区tzinfo。</p><ul><li>常见的使用场景：</li></ul><h4>1.转换为相应时区的时间</h4><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dateutil.tz <span class="keyword">as</span> tz</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">my_tz = tz.gettz(<span class="string">'Asia/Shanghai'</span>)</span><br><span class="line">d = datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">20</span>, tzinfo=my_tz)</span><br><span class="line"><span class="comment"># datetime.datetime(2018, 8, 20, 0, 0, tzinfo=tzfile('/usr/share/zoneinfo/Asia/Shanghai'))</span></span><br></pre></td></tr></table></figure></p><p>也就是说通过<code>tz.gettz()</code>我们可以得到一个tzinfo对象从而可以将其作为参数传递给datetime初始化函数。通过这种方式，我们就可以表示一个本地时间了，比如我们获取了当前时间后想要表示成NewYork时间（换句话说就是要表示不同地方的当前时间），该怎么处理呢？先看正确的做法：<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NYC = tz.gettz('America/New_York')</span><br><span class="line"></span><br><span class="line">now_utc = datetime.now(tz.tzutc())</span><br><span class="line"># datetime.datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">53</span>, <span class="number">143709</span>, tzinfo=tzutc())</span><br><span class="line"></span><br><span class="line">now_utc.astimezone(NYC)</span><br><span class="line"># datetime.datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">53</span>, <span class="number">143709</span>, tzinfo=tzfile('/usr/share/zoneinfo/America/New_York'))</span><br></pre></td></tr></table></figure></p><p>错误的做法：<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now = datetime.utcnow()</span><br><span class="line"># datetime.datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">161843</span>)</span><br><span class="line">now.astimezone(NYC)  </span><br><span class="line"># datetime.datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">161843</span>, tzinfo=tzfile('/usr/share/zoneinfo/America/New_York'))</span><br></pre></td></tr></table></figure></p><p>为什么会出现这种情况呢，因为单纯的使用的utcnow()得到是一个原始naive time对象，而根据时区转换时，该时间会先从本地时区(+8 Shanghai)转换成UTC时区时间，然后再转化为NewYork时间，因此导致最终多减了8小时。</p><p>另外，有的时候我们获取到的是offset信息而不是时区信息，那么我们也可以将UTC时间转换成对应的当地时间，如下：</p><p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过tzoffset也可以构筑tzinfo对象</span><br><span class="line">now_utc.astimezone(tz.tzoffset('NewYork', <span class="number">-14400</span>))</span><br><span class="line"># datetime.datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">53</span>, <span class="number">143709</span>, tzinfo=tzoffset('NewYork', <span class="number">-14400</span>))</span><br></pre></td></tr></table></figure></p><h4>2.获取当前的时区信息，并可以做相应转换</h4><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.tz <span class="keyword">import</span> tzlocal</span><br><span class="line"></span><br><span class="line">tz_local = tzlocal()</span><br><span class="line">type(tz_local)</span><br><span class="line"><span class="comment">#  dateutil.tz.tz.tzlocal</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, tzinfo=tz_local)</span><br><span class="line"><span class="comment"># datetime.datetime(2018, 8, 20, 9, 10, 5, tzinfo=tzlocal())</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.astimezone(tz.UTC)</span><br><span class="line"><span class="comment">#  datetime.datetime(2018, 8, 20, 1, 10, 5, tzinfo=tzutc())</span></span><br></pre></td></tr></table></figure></p><h3>pytz</h3><p>在时间处理的时候，我们还经常能看到pytz这个库，这个库比较有意思的是，<strong>它与datetime的tzinfo并不完全兼容</strong>，很多时候它是独立的一套处理时间的库。我们来看下如下代码(代码来自Paul Ganssle的文章，Paul是dateutil的核心开发者)：<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line">NYC = pytz.timezone(<span class="string">'America/New_York'</span>)</span><br><span class="line"><span class="comment"># 将timezone直接传入datetime初始化函数</span></span><br><span class="line">dt = datetime(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">12</span>, tzinfo=NYC)</span><br><span class="line"><span class="built_in">print</span>(dt)</span><br><span class="line"><span class="comment"># 2018-02-14 12:00:00-04:56</span></span><br></pre></td></tr></table></figure></p><p>可以看到实际的offset成了-04:56，这就不对了，正确使用pytz的姿势如下：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要使用localize方法来转化datetime对象</span><br><span class="line">dt = NYC.localize(datetime(2018, 2, 14, 12))</span><br><span class="line">print(dt)</span><br><span class="line"><span class="comment"># 2018-02-14 12:00:00-05:00</span></span><br></pre></td></tr></table></figure></p><p>再进行一些操作，如下<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime import timedelta</span><br><span class="line"></span><br><span class="line">dt_spring = dt + timedelta(<span class="attribute">days</span>=60)</span><br><span class="line"><span class="builtin-name">print</span>(dt_spring)</span><br><span class="line"><span class="comment"># 2018-04-15 12:00:00-05:00</span></span><br></pre></td></tr></table></figure></p><p>注意，这里的offset是-5:00，而考虑到夏令时，应当是-4:00，这是由于pytz在之前localize的时候就已经将offset设定好了，其在做其它运算之后也无法改变其offset，所以导致无法针对夏令时调整offset，所以针对pytz，每一次做类似timedelta的运算之后，都需要使用normalize函数进行调整，如下：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">print</span>(<span class="selector-tag">NYC</span><span class="selector-class">.normalize</span>(<span class="selector-tag">dt_spring</span>))</span><br><span class="line"># 2018<span class="selector-tag">-04-15</span> 13<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00-04</span><span class="selector-pseudo">:00</span></span><br></pre></td></tr></table></figure></p><p>在项目实践除非对性能有极端要求，并不推荐使用pytz，毕竟不是每个人都熟悉这个库，项目协作过程中很难避免误用。关于pytz和dateutil的性能比较，可以参考Paul Ganssle的这篇文章<a href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html" title="Permalink to pytz: The Fastest Footgun in the West" target="_blank" rel="noopener">pytz: The Fastest Footgun in the West</a></p><h2>时区处理的最佳实践</h2><h3>所有中间步骤均使用UTC时间或者时间戳</h3><p>所有中间的存储或者计算均应当使用UTC时间或者Timestamp，只有在最终显示的时候如果需要转换成本地时间，那么再将时间转换为特定时区的时间进行显示。</p><h3>存储timezone信息，而不是offset</h3><p>如果需要针对用户本地时区做时间转换，需要存储timezone的信息，如timezone名称，而不是offset。这是由于有些地区可能有夏令时，offset会改变，所以最好是存时区名称之类的信息，这样通过tzinfo会自动进行调整。</p><h2>Reference</h2><ul><li><a href="https://docs.python.org/2/library/time.html" target="_blank" rel="noopener">time module document</a></li><li><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="noopener">datetime module document</a></li><li><a href="http://pytz.sourceforge.net/#introduction" target="_blank" rel="noopener">pytz</a></li><li><a href="https://dateutil.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">dateutil</a></li><li><a href="https://medium.com/@eleroy/10-things-you-need-to-know-about-date-and-time-in-python-with-datetime-pytz-dateutil-timedelta-309bfbafb3f7" target="_blank" rel="noopener">10 things you need to know about Date and Time in Python</a></li><li><a href="https://blog.jijiechen.com/post/time-zone-and-dst-basics/" target="_blank" rel="noopener">时区和夏令时相关的基本知识</a></li><li><a href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html" title="Permalink to pytz: The Fastest Footgun in the West" target="_blank" rel="noopener">pytz: The Fastest Footgun in the West</a></li><li><a href="https://stackoverflow.com/questions/13218506/how-to-get-system-timezone-setting-and-pass-it-to-pytz-timezone/17365806" target="_blank" rel="noopener">StackOverflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此下篇主要讲解跟时区相关的概念和程序中经常使用的场景，希望通过此文大家可以搞定所有时区相关的编程问题（如果还有不明白的地方，请联系我，我将进一步补充）。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
      <category term="timezone" scheme="http://yoursite.com/tags/timezone/"/>
    
  </entry>
  
  <entry>
    <title>史上最详解Python日期和时间处理（上）</title>
    <link href="http://yoursite.com/2018/08/12/python_time/"/>
    <id>http://yoursite.com/2018/08/12/python_time/</id>
    <published>2018-08-12T03:52:56.000Z</published>
    <updated>2018-10-06T08:01:38.468Z</updated>
    
    <content type="html"><![CDATA[<p>好吧，我承认这有标题党的嫌疑，不过看了那么多文章，的确没有找到一篇让我满意的关于日期和时间处理的详解文章，于是决心自己动手亲写一篇，希望能对得起这个霸气的标题。言归正传，在Python编程中，日期和时间处理是非常繁琐的一块，不仅概念众多，且有很多不同的module, 尤其涉及时区处理的时候会将问题进一步复杂化。本文将对Python在日期和时间处理上进行一步步详细讲解，总共会分为上下两篇，其中时区处理是较为棘手的一块内容，单独拿出来作为下篇。此上篇将主要讲解时间和日期处理中的基本概念，和常用的场景。</p><p><a id="more"></a>本篇目录如下：</p><ul><li><a href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9A%84%E8%A1%A8%E7%A4%BA">时间和日期的表示</a><ul><li><a href="#%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1">时间、日期对象</a></li><li><a href="#%E6%97%B6%E9%97%B4%E6%88%B3">时间戳</a></li><li><a href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2">日期时间字符串</a></li></ul></li><li><a href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF">日期时间处理场景</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4">获取当前时间</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4">获取特定时间</a></li><li><a href="#%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E8%A1%A8%E7%A4%BA%E7%9A%84%E8%BD%AC%E5%8C%96">不同时间表示的转化</a></li></ul></li></ul><h2>时间和日期的表示</h2><p>在Python中表示日期和时间，最基本的有三种形式：</p><ul><li>时间、日期对象(Object)</li><li>时间戳(Timestamp)</li><li>字符串(String)</li></ul><p>在这三种基本形式中又会衍生出一些其它的概念，下面来分别讲解下：</p><p>先看张脑图来理清它们之间的关系<img src="https://upload-images.jianshu.io/upload_images/3959253-06d2eac8083f8c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.1-python日期与时间的表示"></p><h3>时间、日期对象</h3><p>Python中用于表示日期和时间的对象有很多种，在详细讲解这些对象之前先要明确一个概念，<strong>即这些对象都分为两种：一种是&quot;原始的(naive)&quot;，另一种是&quot;有知的(aware)&quot;</strong>。区别在于原始的时间没有时区概念，只是单纯的表示一个日期和时间，而有知的时间会包含一些额外信息，如时区，是否夏令时等信息，而这些信息会通过tzinfo子类来进行封装，我们将在（下）中详细讲解。</p><ul><li><p>datetime对象：这个是最常用的日期时间对象，可以即表示日期又表示时间。datetime对象可以直接用于日期和时间相关的计算（比如计算5天之前的时间）。另外，datetime既可以表示原始时间，也可以表示有知时间，如果要表示有知时间，则在初始化时需要传递tzinfo类型的参数。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[16]</span>: <span class="selector-tag">import</span> <span class="selector-tag">datetime</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[17]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span><span class="selector-class">.now</span>() # 返回一个<span class="selector-tag">datetime</span>对象</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[17]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(2018, 7, 28, 11, 17, 38, 972555)</span><br><span class="line"></span><br><span class="line"># 也可以直接初始化一个<span class="selector-tag">datetime</span>对象</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[20]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(2018, 7, 5, 10, 20)</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[20]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(2018, 7, 5, 10, 20)</span><br></pre></td></tr></table></figure></p></li><li><p>time对象：与datetime类似，但只用于表示时间，不表示日期<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里初始化一个<span class="selector-tag">datetime</span><span class="selector-class">.time</span>对象用于表示时间11点28分05秒</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[19]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.time</span>(11, 28, 5)</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[19]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.time</span>(11, 28, 5)</span><br></pre></td></tr></table></figure></p></li><li><p>date对象：与datetime类似，但只表示日期，不表示时间<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[23]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.date</span>(2018, 07, 10)</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[23]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.date</span>(2018, 7, 10)</span><br></pre></td></tr></table></figure></p></li><li><p>time tuple: time tuple又叫struct time，是一种用于表示日期和时间的数据结构，此数据结构主要用于time module中的相关函数。time tuple中有9个元素，如下表所示：</p><table><thead><tr><th>索引(Index)</th><th>属性(Attribute)</th><th>值(Values)</th></tr></thead><tbody><tr><td>0</td><td>tm_year(年)</td><td>比如2011</td></tr><tr><td>1</td><td>tm_mon(月)</td><td>1 - 12</td></tr><tr><td>2</td><td>tm_mday(日)</td><td>1 - 31</td></tr><tr><td>3</td><td>tm_hour(时)</td><td>0 - 23</td></tr><tr><td>4</td><td>tm_min(分)</td><td>0 - 59</td></tr><tr><td>5</td><td>tm_sec(秒)</td><td>0 - 61</td></tr><tr><td>6</td><td>tm_wday(weekday)</td><td>0 - 6(0表示周日)</td></tr><tr><td>7</td><td>tm_yday(一年中的第几天)</td><td>1 - 366</td></tr><tr><td>8</td><td>tm_isdst(是否是夏令时)</td><td>默认为-1</td></tr></tbody></table><p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [21]: import time</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [22]: time.localtime()  # 返回一个time tuple用于表示当前时间的local time</span><br><span class="line">Out[22]: time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=7, <span class="attribute">tm_mday</span>=28, <span class="attribute">tm_hour</span>=11,   <span class="attribute">tm_min</span>=26, <span class="attribute">tm_sec</span>=19, <span class="attribute">tm_wday</span>=5, <span class="attribute">tm_yday</span>=209, <span class="attribute">tm_isdst</span>=0)</span><br></pre></td></tr></table></figure></p></li></ul><p>总结：以上前三个对象(datetime, date, time)均来自datetime module（注意区分datetime module和datetime 对象），而最后一个time tuple主要用于time module中的相关操作。</p><h3>时间戳</h3><p>时间戳(Timestamp)是表示当前时间距离元年时间(epoch, 1970年1月1日00:00:00 UTC)的偏移量，这个偏移量在Python中用秒数来计算，但有些编程语言如JavaScript是用毫秒来计算的，需要注意。**另外需要知道时间戳没有时区概念，是不分时区的。**这就是为什么我们在数据库中通常存储的是时间戳，当需要向用户显示时间的时候，再转化为对应时区的时间。</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前时间的时间戳</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[24]</span>: <span class="selector-tag">time</span><span class="selector-class">.time</span>()</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[24]</span>: 1532750668<span class="selector-class">.210267</span></span><br></pre></td></tr></table></figure></p><h3>日期时间字符串</h3><p>通常在需要向用户展示时间的时候，我们都需要将时间戳或者时间对象转化为字符串形式，从而在标准输出中能够打印出相应的时间。我们可以通过将时间戳或者对象进行转化和格式化来得到相应的字符串。需要说明的是，字符串表示时间有一个标准形式称为<a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO8601</a>，可以通过专门的函数来获得。</p><p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: dt = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ISO8601标准时间字符串</span></span><br><span class="line">In [<span class="number">30</span>]: dt.isoformat()</span><br><span class="line">Out[<span class="number">30</span>]: <span class="string">'2018-07-28T12:11:33.582380'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义格式的时间字符串</span></span><br><span class="line">In [<span class="number">31</span>]: dt.strftime(<span class="string">"%Y%m%d-%H:%M:%S"</span>)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="string">'20180728-12:11:33'</span></span><br></pre></td></tr></table></figure></p><h2>日期时间处理场景</h2><p>时间处理主要有以下几个场景：</p><ul><li>获取当前时间</li><li>获取特定时间：例如获取5天前的时间。</li><li>不同时间表示的转化：例如将datetime对象转化为时间字符串</li><li>时区处理：这个将在《下篇》中详细讲述</li></ul><p>下面分别介绍下这几种处理场景：</p><h3>获取当前时间</h3><p>获取当前时间可以通过获取datetime对象、时间戳或time tuple三种方式来获取。</p><p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最常用的获取当前日期时间的方法，其有一个tz参数用于设置时区，默认为None，所以最终获取的是一个原始naive时间</span></span><br><span class="line"><span class="keyword">In</span> [36]: dt = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意获取的是当地时间的时间表示，但其本身是一个原始naive时间</span></span><br><span class="line"><span class="keyword">In</span> [37]: dt</span><br><span class="line">Out[37]: datetime.datetime(2018, 7, 28, 12, 58, 57, 676468)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间的UTC时间表示，注意这仍然是一个原始naive时间，也就是用当前的UTC时间4点59分32秒来构造一个naive时间对象，但这个对象并没有包含时区信息</span></span><br><span class="line"><span class="keyword">In</span> [38]: utc_now = datetime.datetime.utcnow()</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [39]: utc_now</span><br><span class="line">Out[39]: datetime.datetime(2018, 7, 28, 4, 59, 32, 258087)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间的时间戳</span></span><br><span class="line"><span class="keyword">In</span> [40]: time.time()</span><br><span class="line">Out[40]: 1532753948.563503</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当地时间的time tuple</span></span><br><span class="line"><span class="keyword">In</span> [41]: time.localtime()</span><br><span class="line">Out[41]: time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=7, <span class="attribute">tm_mday</span>=28, <span class="attribute">tm_hour</span>=13, <span class="attribute">tm_min</span>=0, <span class="attribute">tm_sec</span>=2, <span class="attribute">tm_wday</span>=5, <span class="attribute">tm_yday</span>=209, <span class="attribute">tm_isdst</span>=0)</span><br></pre></td></tr></table></figure></p><h3>获取特定时间</h3><p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[42]</span>: <span class="selector-tag">dt</span></span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[42]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">12</span>, <span class="number">58</span>, <span class="number">57</span>, <span class="number">676468</span>)</span><br><span class="line"></span><br><span class="line"># 获取两天前的时间</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[43]</span>: <span class="selector-tag">dt</span> <span class="selector-tag">-</span> <span class="selector-tag">datetime</span><span class="selector-class">.timedelta</span>(days=<span class="number">2</span>)</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[43]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">26</span>, <span class="number">12</span>, <span class="number">58</span>, <span class="number">57</span>, <span class="number">676468</span>)</span><br><span class="line"></span><br><span class="line"># 获取一周前的时间</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[44]</span>: <span class="selector-tag">dt</span> <span class="selector-tag">-</span> <span class="selector-tag">datetime</span><span class="selector-class">.timedelta</span>(weeks=<span class="number">1</span>)</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[44]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">58</span>, <span class="number">57</span>, <span class="number">676468</span>)</span><br><span class="line"></span><br><span class="line"># 获取<span class="selector-tag">3</span>小时前的时间</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[45]</span>: <span class="selector-tag">dt</span> <span class="selector-tag">-</span> <span class="selector-tag">datetime</span><span class="selector-class">.timedelta</span>(hours=<span class="number">3</span>)</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[45]</span>: <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">9</span>, <span class="number">58</span>, <span class="number">57</span>, <span class="number">676468</span>)</span><br></pre></td></tr></table></figure></p><p>通过timedelta基本可以满足我们获取特定时间的需求，但是这里不涉及时区相关的转化。而且只是原始naive时间之间的转化</p><h3>不同时间表示的转化</h3><p>先来看一张关系图：<img src="https://upload-images.jianshu.io/upload_images/3959253-837fe6ec315f069e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.2-不同时间表示的关系图"></p><p>从上图可以看出总共有5对关系，每对关系都是可以双向转化的(除timetuple无法直接转化为datetime，需要先转化为timestamp或者time string)，所以总共有9种转化，下面将分别介绍下它们之间是如何互相转化的。</p><h4>datetime object &amp; timestamp</h4><p>从时间戳timestamp ==&gt; datetime object<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">2</span>]: import <span class="built_in">time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">3</span>]: from datetime import datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">4</span>]: ts = <span class="built_in">time</span>.<span class="built_in">time</span>()</span><br><span class="line"></span><br><span class="line"># 直接通过fromtimestamp就可以获得时间戳对应的datetime对象</span><br><span class="line"><span class="keyword">In</span> [<span class="number">5</span>]: dt = datetime.fromtimestamp(ts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">6</span>]: ts</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">6</span>]: <span class="number">1532775234.192805</span></span><br><span class="line"></span><br><span class="line"># 注意这个datetime对象获取的是本地时间的表示，但是仍然是原始naive <span class="built_in">time</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">7</span>]: dt</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">7</span>]: datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">192805</span>)</span><br><span class="line"></span><br><span class="line"># 获取对应utc的时间表示，仍然是原始naive时间</span><br><span class="line"><span class="keyword">In</span> [<span class="number">11</span>]: utc_dt = datetime.utcfromtimestamp(ts)</span><br><span class="line"><span class="keyword">In</span> [<span class="number">12</span>]: utc_dt</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">12</span>]: datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">10</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">192805</span>)</span><br></pre></td></tr></table></figure></p><p>从datetime object ==&gt;时间戳timestamp<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数用于返回datetime object对应的时间戳</span></span><br><span class="line"><span class="keyword">In</span> [8]: def get_timestamp(datetime_obj):</span><br><span class="line">   <span class="built_in">..</span>.:     <span class="keyword">if</span> <span class="keyword">not</span> isinstance(datetime_obj, datetime):</span><br><span class="line">   <span class="built_in">..</span>.:         raise ValueError()</span><br><span class="line">   <span class="built_in">..</span>.:     return (datetime_obj - datetime(1970, 1, 1)).total_seconds()</span><br><span class="line">   <span class="built_in">..</span>.:</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [9]: get_timestamp(dt)</span><br><span class="line">Out[9]: 1532804034.192805</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以先转化为time tuple，再通过mktime函数转化为timestamp，但是精度不如上一版高</span></span><br><span class="line"><span class="keyword">In</span> [13]: def get_timestamp_v2(datetime_obj):</span><br><span class="line">    <span class="built_in">..</span>.:     <span class="keyword">if</span> <span class="keyword">not</span> isinstance(datetime_obj, datetime):</span><br><span class="line">    <span class="built_in">..</span>.:         raise ValueError()</span><br><span class="line">    <span class="built_in">..</span>.:     return time.mktime(datetime_obj.timetuple())</span><br><span class="line">    <span class="built_in">..</span>.:</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [14]: get_timestamp_v2(dt)</span><br><span class="line">Out[14]: 1532775234.0</span><br></pre></td></tr></table></figure></p><h4>datetime object &amp; time string</h4><p>datetime object ==&gt; time string关于格式化的说明可以参考<a href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior" target="_blank" rel="noopener">官网文档</a><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: dt</span><br><span class="line">Out[<span class="number">15</span>]: datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">192805</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义格式</span></span><br><span class="line">In [<span class="number">16</span>]: dt.strftime(<span class="string">"%Y-%m-%dT%H:%M:%S"</span>)</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'2018-07-28T18:53:54'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化为ISO8601格式字符串的快捷方式</span></span><br><span class="line">In [<span class="number">17</span>]: dt.isoformat()</span><br><span class="line">Out[<span class="number">17</span>]: <span class="string">'2018-07-28T18:53:54.192805'</span></span><br></pre></td></tr></table></figure></p><p>time string ==&gt; datetime object<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: time_str = <span class="string">'2018-07-28T18:53:54'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: dt2 = datetime.strptime(time_str, <span class="string">"%Y-%m-%dT%H:%M:%S"</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: dt2</span><br><span class="line">Out[<span class="number">20</span>]: datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">53</span>, <span class="number">54</span>)</span><br></pre></td></tr></table></figure></p><h4>datetime object &amp; time tuple</h4><p>datetime object ==&gt; time tuple<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [21]: dt.timetuple()</span><br><span class="line">Out[21]: time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=7, <span class="attribute">tm_mday</span>=28, <span class="attribute">tm_hour</span>=18, <span class="attribute">tm_min</span>=53, <span class="attribute">tm_sec</span>=54, <span class="attribute">tm_wday</span>=5, <span class="attribute">tm_yday</span>=209, <span class="attribute">tm_isdst</span>=-1)</span><br></pre></td></tr></table></figure></p><p>time tuple ==&gt; datetime object无法直接转化，需要先转化为time str或者timestamp</p><h4>time tuple &amp; timestamp</h4><p>time tuple ==&gt; timestamp<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [25]: time_tuple</span><br><span class="line">Out[25]: time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=7, <span class="attribute">tm_mday</span>=28, <span class="attribute">tm_hour</span>=18, <span class="attribute">tm_min</span>=53, <span class="attribute">tm_sec</span>=54, <span class="attribute">tm_wday</span>=5, <span class="attribute">tm_yday</span>=209, <span class="attribute">tm_isdst</span>=-1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：该函数精度只能到秒</span></span><br><span class="line"><span class="keyword">In</span> [26]: ts = time.mktime(time_tuple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [27]: ts</span><br><span class="line">Out[27]: 1532775234.0</span><br></pre></td></tr></table></figure></p><p>timestamp ==&gt; time tuple<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [27]: ts</span><br><span class="line">Out[27]: 1532775234.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为本地时间的time tuple表示，</span></span><br><span class="line"><span class="keyword">In</span> [29]: tt = time.localtime(ts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [30]: tt</span><br><span class="line">Out[30]: time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=7, <span class="attribute">tm_mday</span>=28, <span class="attribute">tm_hour</span>=18, <span class="attribute">tm_min</span>=53, <span class="attribute">tm_sec</span>=54, <span class="attribute">tm_wday</span>=5, <span class="attribute">tm_yday</span>=209, <span class="attribute">tm_isdst</span>=0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为UTC时间的time tuple表示</span></span><br><span class="line"><span class="keyword">In</span> [31]: utc_tt = time.gmtime(ts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [32]: utc_tt</span><br><span class="line">Out[32]: time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=7, <span class="attribute">tm_mday</span>=28, <span class="attribute">tm_hour</span>=10, <span class="attribute">tm_min</span>=53, <span class="attribute">tm_sec</span>=54, <span class="attribute">tm_wday</span>=5, <span class="attribute">tm_yday</span>=209, <span class="attribute">tm_isdst</span>=0)</span><br></pre></td></tr></table></figure></p><h4>time tuple &amp; time string</h4><p>time tuple ==&gt; time string<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: tt</span><br><span class="line">Out[<span class="number">33</span>]: time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">28</span>, tm_hour=<span class="number">18</span>, tm_min=<span class="number">53</span>, tm_sec=<span class="number">54</span>, tm_wday=<span class="number">5</span>, tm_yday=<span class="number">209</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这里strftime并非time tuple的方法，而是time module下的函数</span></span><br><span class="line">In [<span class="number">34</span>]: tt.strftime(<span class="string">"%Y-%m-%dT%H:%M:%S"</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call <span class="keyword">last</span>)</span><br><span class="line">&lt;ipython-input-<span class="number">34</span>-<span class="number">1</span>be0f512fc77&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> tt.strftime(<span class="string">"%Y-%m-%dT%H:%M:%S"</span>)</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">'time.struct_time'</span> object has <span class="keyword">no</span> attribute <span class="string">'strftime'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下是正解</span></span><br><span class="line">In [<span class="number">35</span>]: time.strftime(<span class="string">"%Y-%m-%dT%H:%M:%S"</span>, tt)</span><br><span class="line">Out[<span class="number">35</span>]: <span class="string">'2018-07-28T18:53:54'</span></span><br></pre></td></tr></table></figure></p><p>time string ==&gt; time tuple<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">36</span>]: time_str</span><br><span class="line">Out[<span class="number">36</span>]: '<span class="number">2018</span>-<span class="number">07</span>-<span class="number">28</span>T18:<span class="number">53</span>:<span class="number">54</span>'</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: <span class="attr">tt</span> = time.strptime(time_str, <span class="string">"%Y-%m-%dT%H:%M:%S"</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: tt</span><br><span class="line">Out[<span class="number">38</span>]: time.struct_time(<span class="attr">tm_year=2018,</span> <span class="attr">tm_mon=7,</span> <span class="attr">tm_mday=28,</span> <span class="attr">tm_hour=18,</span> <span class="attr">tm_min=53,</span> <span class="attr">tm_sec=54,</span> <span class="attr">tm_wday=5,</span> <span class="attr">tm_yday=209,</span> <span class="attr">tm_isdst=-1)</span></span><br></pre></td></tr></table></figure></p><h4>timestamp &amp; time string</h4><p>无法相互转化，只能通过先转化为datetime object或者time tuple之后才能再转化</p><h2>References</h2><ul><li><a href="https://docs.python.org/2/library/time.html" target="_blank" rel="noopener">time module document</a></li><li><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="noopener">datetime module document</a></li><li><a href="https://medium.com/@eleroy/10-things-you-need-to-know-about-date-and-time-in-python-with-datetime-pytz-dateutil-timedelta-309bfbafb3f7" target="_blank" rel="noopener">10 things you need to know about Date and Time in Python</a></li><li><a href="http://www.wklken.me/posts/2015/03/03/python-base-datetime.html" target="_blank" rel="noopener">PYTHON-基础-时间日期处理小结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好吧，我承认这有标题党的嫌疑，不过看了那么多文章，的确没有找到一篇让我满意的关于日期和时间处理的详解文章，于是决心自己动手亲写一篇，希望能对得起这个霸气的标题。言归正传，在Python编程中，日期和时间处理是非常繁琐的一块，不仅概念众多，且有很多不同的module, 尤其涉及时区处理的时候会将问题进一步复杂化。本文将对Python在日期和时间处理上进行一步步详细讲解，总共会分为上下两篇，其中时区处理是较为棘手的一块内容，单独拿出来作为下篇。此上篇将主要讲解时间和日期处理中的基本概念，和常用的场景。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型和常用命令</title>
    <link href="http://yoursite.com/2018/07/27/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/27/Redis数据类型和常用命令/</id>
    <published>2018-07-27T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.903Z</updated>
    
    <content type="html"><![CDATA[<p>Redis相较于其它的数据库虽然简单，但是要熟记所有命令的用法也并非易事。一个简单的技巧是通过要操作的数据类型来将这些命令进行结构化。</p><p><a id="more"></a></p><h2>数据类型和对应命令</h2><p>所有存储于redis中的数据都对应于一个键值对(key-value pair), key可以是任意二进制序列，通常我们使用字符串来标记一个特定的key。在redis中我们通常称这个key为name或者就叫key, 而对于value，redis支持如下几种类型：</p><ul><li>strings</li><li>lists: list内容只能是string</li><li>sets: set中存储非重复的string</li><li>sorted sets: 与sets类似，但是每个string都会对应一个float类型的score，从而用于排序</li><li>hashes: 键值对hash类型，也就是Python中的dict，注意在redis中最外层的key一般叫做name或者key，而value中数据类型如果是dict，那么这个dict中的key通常被称为field。</li><li>Bit arrays (or simply bitmaps): 实际存储的仍然是string，但是可以针对bit进行操作</li><li>HyperLogLogs: 用于估计unique value的数量</li></ul><p>针对不同的数据类型，会有不同的命令，通过如下脑图可以更加清晰地记忆redis的命令<img src="https://upload-images.jianshu.io/upload_images/3959253-6c756bf39ad702c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Redis数据类型与常用命令"></p><h4>strings</h4><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">set</span> <span class="selector-tag">strtest</span> <span class="selector-tag">xyz</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">strtest</span></span><br><span class="line">"<span class="selector-tag">xyz</span>"</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">mset</span> <span class="selector-tag">a</span> 1 <span class="selector-tag">b</span> 2 <span class="selector-tag">c</span> 3</span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">mget</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">c</span></span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line"># 注意以下增减操作只能针对整数数字(虽然类型仍然是<span class="selector-tag">string</span>类型)</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">incr</span> <span class="selector-tag">a</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 2</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">incrby</span> <span class="selector-tag">b</span> 5</span><br><span class="line">(<span class="selector-tag">integer</span>) 7</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">decr</span> <span class="selector-tag">b</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 6</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">decrby</span> <span class="selector-tag">b</span> 3</span><br><span class="line">(<span class="selector-tag">integer</span>) 3</span><br></pre></td></tr></table></figure></p><h4>lists</h4><p>lists类型中存储的仍然是string类型<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># left push用于从左将item压入到list当中</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush list_test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意如果想看list中的内容，无法通过get直接去看，get只是针对string，而必须使用lrange</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get list_test </span><br><span class="line">(<span class="keyword">error</span>) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里0 -1均为list index，表示从index 0 开始到-1结束，-1即从右数最后一个item</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">lrange</span> list_test <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush list_test <span class="number">5</span> <span class="number">7</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">lrange</span> list_test <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"5"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"7"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpop list_test</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">lrange</span> list_test <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"5"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"7"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左trim截断list，以下是截取index 0 到index 2 的item作为新的list</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ltrim list_test <span class="number">0</span> <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">lrange</span> list_test <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"5"</span></span><br></pre></td></tr></table></figure></p><h4>hashes (dict)</h4><p>哈希类型，在python中也就是dict类型。这也是非常常用的数据类型。<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hset htest a <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hget htest a</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hmset htest a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hmget htest a b c</span><br><span class="line"><span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"3"</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hgetall htest</span><br><span class="line"><span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hkeys htest</span><br><span class="line"><span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> hvals htest</span><br><span class="line"><span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"3"</span></span><br></pre></td></tr></table></figure></p><p>在python程序中使用redis-py driver的时候，通过dict进行操作会非常清晰和简单。<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">1</span>]: import redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">2</span>]: r = redis.StrictRedis(host=<span class="symbol">'localhost</span>', port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">3</span>]: d = &#123;<span class="string">"a"</span>: <span class="number">2</span>, <span class="string">"b"</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">4</span>]: key = <span class="string">"test:2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">5</span>]: r.hmset(key, d)</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">6</span>]: r.hgetall(key)</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">6</span>]: &#123;<span class="string">'a'</span>: <span class="string">'2'</span>, <span class="string">'b'</span>: <span class="string">'3'</span>&#125;</span><br></pre></td></tr></table></figure></p><h4>sets</h4><p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> sadd set_test a b <span class="number">33</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> sadd set_test c a b <span class="number">22</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到不会有重复的item</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> smembers set_test</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"33"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于测试set中是否包含指定的item，如有则返回1，没有返回0</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> sismember set_test a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> sismember set_test xx</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> sadd set_test2 a b <span class="number">56</span> <span class="number">66</span></span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> smembers set_test2</span><br><span class="line"><span class="number">1</span>) <span class="string">"56"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"66"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求交集</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> sinter set_test set_test2</span><br><span class="line"><span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求并集</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> sunion set_test set_test2</span><br><span class="line"><span class="number">1</span>) <span class="string">"33"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"56"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"66"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"22"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"b"</span></span><br></pre></td></tr></table></figure></p><h4>sorted sets</h4><p>sorted sets与sets类似，可以保证item不重复，区别在于sorted sets中每个item对应一个float类型的score<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">sort_set</span> 2<span class="selector-class">.2</span> <span class="selector-tag">a</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">sort_set</span> 2 <span class="selector-tag">bb</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">sort_set</span> 10 <span class="selector-tag">x</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"></span><br><span class="line"># 获取<span class="selector-tag">index</span> 从0 到<span class="selector-tag">-1</span>的(即所有) <span class="selector-tag">items</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zrange</span> <span class="selector-tag">sort_set</span> 0 <span class="selector-tag">-1</span></span><br><span class="line">1) "<span class="selector-tag">bb</span>"</span><br><span class="line">2) "<span class="selector-tag">a</span>"</span><br><span class="line">3) "<span class="selector-tag">x</span>"</span><br><span class="line"></span><br><span class="line"># 获取<span class="selector-tag">item</span> <span class="selector-tag">bb</span>对应的<span class="selector-tag">index</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zrank</span> <span class="selector-tag">sort_set</span> <span class="selector-tag">bb</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zrank</span> <span class="selector-tag">sort_set</span> <span class="selector-tag">x</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 2</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zscore</span> <span class="selector-tag">sort_set</span> <span class="selector-tag">x</span></span><br><span class="line">"10"</span><br><span class="line"></span><br><span class="line"># 用于获取对应<span class="selector-tag">score</span> <span class="selector-tag">set</span>中<span class="selector-tag">item</span>的数量</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zcard</span> <span class="selector-tag">sort_set</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 3</span><br></pre></td></tr></table></figure></p><h4>bit arrays</h4><p>用于针对指定的key设置位数据为0 或 1。当我们对存储有较高要求，且对于统计为1的item的数量时，使用bit array是一个好的办法。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 针对<span class="selector-tag">bit</span> 7进行设置，设置为1，返回该位之前存储的值</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">setbit</span> <span class="selector-tag">bit_test</span> 7 1</span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">setbit</span> <span class="selector-tag">bit_test</span> 7 0</span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">bit_test</span></span><br><span class="line">"\<span class="selector-tag">x00</span>"</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">setbit</span> <span class="selector-tag">bit_test</span> 8 1</span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">setbit</span> <span class="selector-tag">bit_test</span> 9 1</span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br><span class="line"></span><br><span class="line"># 统计有多少位为1</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">bitcount</span> <span class="selector-tag">bit_test</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 2</span><br></pre></td></tr></table></figure></p><h4>HyperLogLogs</h4><p>redis实现了相应算法可以估计hyperloglog中存储的所有item中非重复的item的数量<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">pfadd</span> <span class="selector-tag">loglog</span> 1 3 5 7 1</span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">pfcount</span> <span class="selector-tag">loglog</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 4</span><br></pre></td></tr></table></figure></p><h2>通用的命令</h2><ul><li>keys pattern: pattern可以为glob风格的通配符格式，最常用的是<code>keys *</code>查询所有的keys</li><li>exists key: 查询该key是否存在</li><li>del key: 删除该key对应的数据</li><li>type key: 查询该key对应的value的数据类型</li><li>expire key: 定义多长时间后key对应的数据过期，过期后数据会被自动删除</li><li>ttl key: 查询该key对应的剩余存活时间</li><li>flushdb/flushall: flushdb用于清除当前db的所有数据，flushall清除所有数据库的数据</li></ul><h2>References</h2><ul><li><a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">Redis Type Introduction</a></li><li><a href="https://redis.io/commands#" target="_blank" rel="noopener">Redis Commands</a></li><li><a href="https://segmentfault.com/a/1190000010999677" target="_blank" rel="noopener">Redis 常用命令</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis相较于其它的数据库虽然简单，但是要熟记所有命令的用法也并非易事。一个简单的技巧是通过要操作的数据类型来将这些命令进行结构化。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Pandas系列6-DataFrame的分组与聚合</title>
    <link href="http://yoursite.com/2018/07/23/Pandas%E7%B3%BB%E5%88%976-DataFrame%E7%9A%84%E5%88%86%E7%BB%84%E4%B8%8E%E8%81%9A%E5%90%88/"/>
    <id>http://yoursite.com/2018/07/23/Pandas系列6-DataFrame的分组与聚合/</id>
    <published>2018-07-23T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.903Z</updated>
    
    <content type="html"><![CDATA[<p>在对数据进行处理的时候，分组与聚合是非常常用的操作。在Pandas中此类操作主要是通过groupby函数来完成的。</p><p><a id="more"></a></p><p>先看一个实际的例子：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个原始的DataFrame</span><br><span class="line">In [<span class="number">70</span>]: raw_data = &#123;<span class="string">'regiment'</span>: [<span class="string">'Nighthawks'</span>, <span class="string">'Nighthawks'</span>, <span class="string">'Nighthawks'</span>, <span class="string">'Nighthawk</span></span><br><span class="line"><span class="string">    ...: s'</span>, <span class="string">'Dragoons'</span>, <span class="string">'Dragoons'</span>, <span class="string">'Dragoons'</span>, <span class="string">'Dragoons'</span>, <span class="string">'Scouts'</span>, <span class="string">'Scouts'</span>, <span class="string">'Scou</span></span><br><span class="line"><span class="string">    ...: ts'</span>, <span class="string">'Scouts'</span>],</span><br><span class="line">    ...:         <span class="string">'company'</span>: [<span class="string">'1st'</span>, <span class="string">'1st'</span>, <span class="string">'2nd'</span>, <span class="string">'2nd'</span>, <span class="string">'1st'</span>, <span class="string">'1st'</span>, <span class="string">'2nd'</span>, <span class="string">'2nd'</span>,<span class="string">'1</span></span><br><span class="line"><span class="string">    ...: st'</span>, <span class="string">'1st'</span>, <span class="string">'2nd'</span>, <span class="string">'2nd'</span>],</span><br><span class="line">    ...:         <span class="string">'name'</span>: [<span class="string">'Miller'</span>, <span class="string">'Jacobson'</span>, <span class="string">'Ali'</span>, <span class="string">'Milner'</span>, <span class="string">'Cooze'</span>, <span class="string">'Jacon'</span>, <span class="string">'Ry</span></span><br><span class="line"><span class="string">    ...: aner'</span>, <span class="string">'Sone'</span>, <span class="string">'Sloan'</span>, <span class="string">'Piger'</span>, <span class="string">'Riani'</span>, <span class="string">'Ali'</span>],</span><br><span class="line">    ...:         <span class="string">'preTestScore'</span>: [<span class="number">4</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    ...:         <span class="string">'postTestScore'</span>: [<span class="number">25</span>, <span class="number">94</span>, <span class="number">57</span>, <span class="number">62</span>, <span class="number">70</span>, <span class="number">25</span>, <span class="number">94</span>, <span class="number">57</span>, <span class="number">62</span>, <span class="number">70</span>, <span class="number">62</span>, <span class="number">70</span>]&#125;</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: df = pd.DataFrame(raw_data, columns = [<span class="string">'regiment'</span>, <span class="string">'company'</span>, <span class="string">'name'</span>, <span class="string">'preTes</span></span><br><span class="line"><span class="string">    ...: tScore'</span>, <span class="string">'postTestScore'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: df</span><br><span class="line">Out[<span class="number">72</span>]:</span><br><span class="line">      regiment company      name  preTestScore  postTestScore</span><br><span class="line"><span class="number">0</span>   Nighthawks     <span class="number">1s</span>t    Miller             <span class="number">4</span>             <span class="number">25</span></span><br><span class="line"><span class="number">1</span>   Nighthawks     <span class="number">1s</span>t  Jacobson            <span class="number">24</span>             <span class="number">94</span></span><br><span class="line"><span class="number">2</span>   Nighthawks     <span class="number">2</span>nd       Ali            <span class="number">31</span>             <span class="number">57</span></span><br><span class="line"><span class="number">3</span>   Nighthawks     <span class="number">2</span>nd    Milner             <span class="number">2</span>             <span class="number">62</span></span><br><span class="line"><span class="number">4</span>     Dragoons     <span class="number">1s</span>t     Cooze             <span class="number">3</span>             <span class="number">70</span></span><br><span class="line"><span class="number">5</span>     Dragoons     <span class="number">1s</span>t     Jacon             <span class="number">4</span>             <span class="number">25</span></span><br><span class="line"><span class="number">6</span>     Dragoons     <span class="number">2</span>nd    Ryaner            <span class="number">24</span>             <span class="number">94</span></span><br><span class="line"><span class="number">7</span>     Dragoons     <span class="number">2</span>nd      Sone            <span class="number">31</span>             <span class="number">57</span></span><br><span class="line"><span class="number">8</span>       Scouts     <span class="number">1s</span>t     Sloan             <span class="number">2</span>             <span class="number">62</span></span><br><span class="line"><span class="number">9</span>       Scouts     <span class="number">1s</span>t     Piger             <span class="number">3</span>             <span class="number">70</span></span><br><span class="line"><span class="number">10</span>      Scouts     <span class="number">2</span>nd     Riani             <span class="number">2</span>             <span class="number">62</span></span><br><span class="line"><span class="number">11</span>      Scouts     <span class="number">2</span>nd       Ali             <span class="number">3</span>             <span class="number">70</span></span><br></pre></td></tr></table></figure></p><p>通过groupby函数生成一个groupby对象，如下：<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 当针对特定列（此例是<span class="string">'preTestScore'</span>）进行分组时，需要通过df[<span class="string">'colume_name'</span>](此例是df[<span class="string">'regiment'</span>])来指定键名</span><br><span class="line"><span class="symbol">In</span> [<span class="number">73</span>]: groupby_regiment = df[<span class="string">'preTestScore'</span>].groupby(df[<span class="string">'regiment'</span>])</span><br><span class="line"></span><br><span class="line"># 生成的groupby对象没有做任何计算，只是将数据按键进行分组</span><br><span class="line"><span class="symbol">In</span> [<span class="number">74</span>]: groupby_regiment</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">74</span>]: &lt;pandas.core.groupby.<span class="symbol">SeriesGroupBy</span> object at <span class="number">0x11112cef0</span>&gt;</span><br><span class="line"></span><br><span class="line"># 分组的聚合统计</span><br><span class="line"><span class="symbol">In</span> [<span class="number">75</span>]: groupby_regiment.describe()</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">75</span>]:</span><br><span class="line">            count   mean        std  min   <span class="number">25</span><span class="comment">%   50%    75%   max</span></span><br><span class="line">regiment</span><br><span class="line"><span class="symbol">Dragoons</span>      <span class="number">4.0</span>  <span class="number">15.50</span>  <span class="number">14.153916</span>  <span class="number">3.0</span>  <span class="number">3.75</span>  <span class="number">14.0</span>  <span class="number">25.75</span>  <span class="number">31.0</span></span><br><span class="line"><span class="symbol">Nighthawks</span>    <span class="number">4.0</span>  <span class="number">15.25</span>  <span class="number">14.453950</span>  <span class="number">2.0</span>  <span class="number">3.50</span>  <span class="number">14.0</span>  <span class="number">25.75</span>  <span class="number">31.0</span></span><br><span class="line"><span class="symbol">Scouts</span>        <span class="number">4.0</span>   <span class="number">2.50</span>   <span class="number">0.577350</span>  <span class="number">2.0</span>  <span class="number">2.00</span>   <span class="number">2.5</span>   <span class="number">3.00</span>   <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line"># 也可以针对特定统计单独计算</span><br><span class="line"><span class="symbol">In</span> [<span class="number">76</span>]: groupby_regiment.mean()</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">76</span>]:</span><br><span class="line">regiment</span><br><span class="line"><span class="symbol">Dragoons</span>      <span class="number">15.50</span></span><br><span class="line"><span class="symbol">Nighthawks</span>    <span class="number">15.25</span></span><br><span class="line"><span class="symbol">Scouts</span>         <span class="number">2.50</span></span><br><span class="line"><span class="symbol">Name</span>: preTestScore, dtype: float64</span><br></pre></td></tr></table></figure></p><p>整个分组统计的过程，可以通过下图更清晰地展示：<img src="https://upload-images.jianshu.io/upload_images/3959253-c268458a8035803b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.1-group and aggregate process"></p><h4>聚合函数</h4><p>聚合的时候，既可以使用Pandas内置的函数进行聚合计算，也可以使用自定义的函数进行聚合计算，我们先来看下内置的函数：<img src="https://upload-images.jianshu.io/upload_images/3959253-0b1bee24d432dc9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.2-built-in aggregate functions">另外，我们也可以自定义聚合函数：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[81]</span>: <span class="selector-tag">def</span> <span class="selector-tag">my_agg</span>(<span class="selector-tag">pre_test_score_group</span>):</span><br><span class="line">    ...:     <span class="selector-tag">return</span> <span class="selector-tag">np</span><span class="selector-class">.sum</span>(<span class="selector-tag">np</span><span class="selector-class">.power</span>(<span class="selector-tag">pre_test_score_group</span>, 2))</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[82]</span>: <span class="selector-tag">df</span><span class="selector-attr">['preTestScore']</span><span class="selector-class">.groupby</span>(<span class="selector-tag">df</span><span class="selector-attr">['regiment']</span>)<span class="selector-class">.apply</span>(<span class="selector-tag">my_agg</span>)</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[82]</span>:</span><br><span class="line"><span class="selector-tag">regiment</span></span><br><span class="line"><span class="selector-tag">Dragoons</span>      1562</span><br><span class="line"><span class="selector-tag">Nighthawks</span>    1557</span><br><span class="line"><span class="selector-tag">Scouts</span>          26</span><br><span class="line"><span class="selector-tag">Name</span>: <span class="selector-tag">preTestScore</span>, <span class="selector-tag">dtype</span>: <span class="selector-tag">int64</span></span><br></pre></td></tr></table></figure></p><p>通过上面的例子我们可以看到，通过apply函数也可以完成类似for循环的迭代，在pandas中尽可能使用apply函数来代替for循环迭代，以提高性能。</p><h4>根据多个键进行分组和聚合</h4><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 如果有多个键，将多个键放到一个<span class="selector-tag">list</span>当中，作为<span class="selector-tag">groupby</span>的参数</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[77]</span>: <span class="selector-tag">df</span><span class="selector-attr">['preTestScore']</span><span class="selector-class">.groupby</span>(<span class="selector-attr">[df['regiment']</span>, <span class="selector-tag">df</span><span class="selector-attr">['company']</span>])<span class="selector-class">.mean</span>()</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[77]</span>:</span><br><span class="line"><span class="selector-tag">regiment</span>    <span class="selector-tag">company</span></span><br><span class="line"><span class="selector-tag">Dragoons</span>    1<span class="selector-tag">st</span>         3<span class="selector-class">.5</span></span><br><span class="line">            2<span class="selector-tag">nd</span>        27<span class="selector-class">.5</span></span><br><span class="line"><span class="selector-tag">Nighthawks</span>  1<span class="selector-tag">st</span>        14<span class="selector-class">.0</span></span><br><span class="line">            2<span class="selector-tag">nd</span>        16<span class="selector-class">.5</span></span><br><span class="line"><span class="selector-tag">Scouts</span>      1<span class="selector-tag">st</span>         2<span class="selector-class">.5</span></span><br><span class="line">            2<span class="selector-tag">nd</span>         2<span class="selector-class">.5</span></span><br><span class="line"><span class="selector-tag">Name</span>: <span class="selector-tag">preTestScore</span>, <span class="selector-tag">dtype</span>: <span class="selector-tag">float64</span></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">unstack</span>之后变成表格模式，更加清晰</span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[78]</span>: <span class="selector-tag">df</span><span class="selector-attr">['preTestScore']</span><span class="selector-class">.groupby</span>(<span class="selector-attr">[df['regiment']</span>, <span class="selector-tag">df</span><span class="selector-attr">['company']</span>])<span class="selector-class">.mean</span>()<span class="selector-class">.unstack</span>()</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[78]</span>:</span><br><span class="line"><span class="selector-tag">company</span>      1<span class="selector-tag">st</span>   2<span class="selector-tag">nd</span></span><br><span class="line"><span class="selector-tag">regiment</span></span><br><span class="line"><span class="selector-tag">Dragoons</span>     3<span class="selector-class">.5</span>  27<span class="selector-class">.5</span></span><br><span class="line"><span class="selector-tag">Nighthawks</span>  14<span class="selector-class">.0</span>  16<span class="selector-class">.5</span></span><br><span class="line"><span class="selector-tag">Scouts</span>       2<span class="selector-class">.5</span>   2<span class="selector-class">.5</span></span><br></pre></td></tr></table></figure></p><h2>References</h2><ul><li><a href="https://chrisalbon.com/python/data_wrangling/pandas_apply_operations_to_groups/" target="_blank" rel="noopener">Apply Operations To Groups In Pandas</a></li><li><a href="https://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.groupby.html" target="_blank" rel="noopener">Pandas official doc - groupby </a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对数据进行处理的时候，分组与聚合是非常常用的操作。在Pandas中此类操作主要是通过groupby函数来完成的。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列5-DataFrame之过滤</title>
    <link href="http://yoursite.com/2018/07/06/Pandas%E7%B3%BB%E5%88%975-DataFrame%E4%B9%8B%E8%BF%87%E6%BB%A4/"/>
    <id>http://yoursite.com/2018/07/06/Pandas系列5-DataFrame之过滤/</id>
    <published>2018-07-06T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.902Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas的条件过滤是使用非常频繁的技巧，在这一节我们将看到各种不同的过滤技巧，如果读者有其它过滤技巧，也欢迎告诉我。</p><p><a id="more"></a></p><h2>条件过滤与赋值</h2><p>通过loc进行行过滤，并对过滤后的行进行赋值<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: df</span><br><span class="line">Out[<span class="number">34</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">165</span></span><br><span class="line"><span class="number">1</span>   <span class="number">30</span>    <span class="built_in">red</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   <span class="number">15</span>  <span class="built_in">green</span>     <span class="number">185</span></span><br><span class="line"></span><br><span class="line"># 注意这里赋值需要使用如下方式，而不能使用chained index</span><br><span class="line"># 具体参考http:<span class="comment">//pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy</span></span><br><span class="line">In [<span class="number">38</span>]: df.loc[df.<span class="built_in">color</span> == <span class="string">'blue'</span>,<span class="string">'height'</span>] = <span class="number">199</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: df</span><br><span class="line">Out[<span class="number">39</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">199</span></span><br><span class="line"><span class="number">1</span>   <span class="number">30</span>    <span class="built_in">red</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   <span class="number">15</span>  <span class="built_in">green</span>     <span class="number">185</span></span><br><span class="line"></span><br><span class="line"># 表示列数据除了上例中使用<span class="string">'.'</span>,还可以使用<span class="string">'[]'</span>,如下:</span><br><span class="line">In [<span class="number">40</span>]: df.loc[df2[<span class="string">'color'</span>]==<span class="string">'blue'</span>, <span class="string">'height'</span>] = <span class="number">175</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: df</span><br><span class="line">Out[<span class="number">41</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">175</span></span><br><span class="line"><span class="number">1</span>   <span class="number">30</span>    <span class="built_in">red</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   <span class="number">15</span>  <span class="built_in">green</span>     <span class="number">185</span></span><br></pre></td></tr></table></figure></p><p>除了上述的过滤方式外，还可以通过query method来进行过滤查询，如下：<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">248</span>]: df2</span><br><span class="line">Out[<span class="number">248</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>  black     <span class="number">155</span></span><br><span class="line"><span class="number">1</span>   <span class="number">33</span>  <span class="built_in">green</span>     <span class="number">177</span></span><br><span class="line"><span class="number">2</span>   <span class="number">22</span>    NaN     <span class="number">188</span></span><br><span class="line"><span class="number">3</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">175</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">250</span>]: df2.query(<span class="string">'age&gt;20 &amp; age&lt;40'</span>)</span><br><span class="line">Out[<span class="number">250</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">1</span>   <span class="number">33</span>  <span class="built_in">green</span>     <span class="number">177</span></span><br><span class="line"><span class="number">2</span>   <span class="number">22</span>    NaN     <span class="number">188</span></span><br></pre></td></tr></table></figure></p><h2>空值判断</h2><p>在数据处理的过程中，空值判断是非常常用的技巧，在Pandas中我们主要通过以下几种方式来判断空值。</p><ul><li>isnull函数: 用于针对Series、DataFrame判断是否为null</li><li>notnull函数: 用于判断非null值</li><li>np.isnan函数: 用于针对某个标量值进行判断是否为nan(null)。需要注意的是这个函数不能用于字符串类型的值进行判断，因此如果array中有字符串类型，需要用其它方式进行判断，如isinstance</li></ul><h5>isnull函数</h5><p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">605</span>]: dfx</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">605</span>]:</span><br><span class="line">    <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">a1  <span class="number">2</span>  <span class="number">4</span></span><br><span class="line">a2  <span class="number">5</span>  <span class="number">5</span></span><br><span class="line">b1  <span class="number">5</span>  <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">606</span>]: dfx.iloc[<span class="number">1</span>, <span class="number">1</span>] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">607</span>]: dfx</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">607</span>]:</span><br><span class="line">    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">a1  <span class="number">2</span>  <span class="number">4.0</span></span><br><span class="line">a2  <span class="number">5</span>  NaN</span><br><span class="line">b1  <span class="number">5</span>  <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">608</span>]: dfx.isnull()</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">608</span>]:</span><br><span class="line">        <span class="number">1</span>      <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">a1  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">a2  <span class="literal">False</span>   <span class="literal">True</span></span><br><span class="line">b1  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"># 如果该列所有的值均不为<span class="keyword">null</span>则返回<span class="literal">False</span>，只要有一个值为<span class="keyword">null</span>则返回<span class="literal">True</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">609</span>]: dfx.isnull().any()</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">609</span>]:</span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line"># 针对DataFrame中的所有值进行检查，只要有一个<span class="keyword">null</span>值，则返回<span class="literal">True</span></span><br><span class="line"><span class="keyword">In</span> [<span class="number">610</span>]: dfx.isnull().any().any()</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">610</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"># 返回<span class="keyword">null</span>值的数量</span><br><span class="line"><span class="keyword">In</span> [<span class="number">611</span>]: dfx.isnull().sum().sum()</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">611</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>将isnull用于过滤条件：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[244]</span>: <span class="selector-tag">df2</span></span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[244]</span>:</span><br><span class="line">   <span class="selector-tag">age</span>  <span class="selector-tag">color</span>  <span class="selector-tag">height</span></span><br><span class="line">0   20  <span class="selector-tag">black</span>     155</span><br><span class="line">1   33  <span class="selector-tag">green</span>     177</span><br><span class="line">2   22    <span class="selector-tag">NaN</span>     188</span><br><span class="line">3   20   <span class="selector-tag">blue</span>     165</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[245]</span>: <span class="selector-tag">df2</span><span class="selector-class">.loc</span><span class="selector-attr">[df2['color']</span><span class="selector-class">.isnull</span>(), :]</span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[245]</span>:</span><br><span class="line">   <span class="selector-tag">age</span> <span class="selector-tag">color</span>  <span class="selector-tag">height</span></span><br><span class="line">2   22   <span class="selector-tag">NaN</span>     188</span><br></pre></td></tr></table></figure></p><h5>notnull函数</h5><p>notnull的使用与isnull类似,如下：<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">248</span>]: df2</span><br><span class="line">Out[<span class="number">248</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>  black     <span class="number">155</span></span><br><span class="line"><span class="number">1</span>   <span class="number">33</span>  <span class="built_in">green</span>     <span class="number">177</span></span><br><span class="line"><span class="number">2</span>   <span class="number">22</span>    NaN     <span class="number">188</span></span><br><span class="line"><span class="number">3</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">175</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">249</span>]: df2.loc[df2.<span class="built_in">color</span>.notnull(), :]</span><br><span class="line">Out[<span class="number">249</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>  black     <span class="number">155</span></span><br><span class="line"><span class="number">1</span>   <span class="number">33</span>  <span class="built_in">green</span>     <span class="number">177</span></span><br><span class="line"><span class="number">3</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">175</span></span><br></pre></td></tr></table></figure></p><h5>np.isnan函数</h5><p>需要注意的是判断dataframe中某个值是否为空，不能直接用== np.nan来判断，而需要使用np.isnan函数如下<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">616</span>]: dfx.iloc[<span class="number">1</span>, <span class="number">1</span>] == np.nan</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">616</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">614</span>]: np.isnan(dfx.iloc[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">614</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"># 其它判断方式同样不行</span><br><span class="line"><span class="keyword">In</span> [<span class="number">617</span>]: dfx.iloc[<span class="number">1</span>, <span class="number">1</span>] <span class="keyword">is</span> None</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">617</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">618</span>]: <span class="keyword">if</span> <span class="keyword">not</span> dfx.iloc[<span class="number">1</span>, <span class="number">1</span>]: print(<span class="string">"True"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">619</span>]:</span><br></pre></td></tr></table></figure></p><h2>isin函数</h2><p>使用isin函数<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [764]: df</span><br><span class="line">Out[764]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue   Steak    <span class="number"> 178 </span>   4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb    <span class="number"> 181 </span>   8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 178 </span>   9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple    <span class="number"> 178 </span>   3.3    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 175 </span>   1.8    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 178 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 178 </span>   2.2    TX</span><br><span class="line"></span><br><span class="line">In [765]: df3 = df[df['state'].isin(['NY', 'TX'])]</span><br><span class="line"></span><br><span class="line">In [766]: df3</span><br><span class="line">Out[766]:</span><br><span class="line">           age  color   food  height  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue  Steak    <span class="number"> 178 </span>   4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green   Lamb    <span class="number"> 181 </span>   8.3    TX</span><br><span class="line">Christina  <span class="number"> 33 </span> black  Melon    <span class="number"> 178 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red  Beans    <span class="number"> 178 </span>   2.2    TX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用'~'或者'-'来选择不在列表中的项</span></span><br><span class="line">In [773]: df3 = df[-df['state'].isin(['NY', 'TX'])]</span><br><span class="line"></span><br><span class="line">In [774]: df3</span><br><span class="line">Out[774]:</span><br><span class="line">          age  color    food  height  score state</span><br><span class="line">Aaron     <span class="number"> 12 </span>   red   Mango    <span class="number"> 178 </span>   9.0    FL</span><br><span class="line">Penelope   <span class="number"> 4 </span> white   Apple    <span class="number"> 178 </span>   3.3    AL</span><br><span class="line">Dean      <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 175 </span>   1.8    AK</span><br></pre></td></tr></table></figure></p><h2>多过滤条件</h2><p>当有多个过滤条件时，我们就需要使用逻辑操作符<code>&amp;</code>, <code>|</code>,如下：<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">251</span>]: df2</span><br><span class="line">Out[<span class="number">251</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>  black     <span class="number">155</span></span><br><span class="line"><span class="number">1</span>   <span class="number">33</span>  <span class="built_in">green</span>     <span class="number">177</span></span><br><span class="line"><span class="number">2</span>   <span class="number">22</span>    NaN     <span class="number">188</span></span><br><span class="line"><span class="number">3</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">175</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">254</span>]: df2.loc[(df2.age&gt;<span class="number">20</span>) &amp; (df2.<span class="built_in">color</span>.notnull())]</span><br><span class="line">Out[<span class="number">254</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">1</span>   <span class="number">33</span>  <span class="built_in">green</span>     <span class="number">177</span></span><br><span class="line"></span><br><span class="line"># 注意在逻辑操作符两边的过滤条件必须使用小括号括起来，否则条件过滤不起作用，如下：</span><br><span class="line">In [<span class="number">253</span>]: df2.loc[df2.age&gt;<span class="number">20</span> &amp; df2.<span class="built_in">color</span>.notnull()]</span><br><span class="line">Out[<span class="number">253</span>]:</span><br><span class="line">   age  <span class="built_in">color</span>  <span class="built_in">height</span></span><br><span class="line"><span class="number">0</span>   <span class="number">20</span>  black     <span class="number">155</span></span><br><span class="line"><span class="number">1</span>   <span class="number">33</span>  <span class="built_in">green</span>     <span class="number">177</span></span><br><span class="line"><span class="number">2</span>   <span class="number">22</span>    NaN     <span class="number">188</span></span><br><span class="line"><span class="number">3</span>   <span class="number">20</span>   <span class="built_in">blue</span>     <span class="number">175</span></span><br></pre></td></tr></table></figure></p><h2>过滤后的赋值计算</h2><p>在实际项目中，很多时候我们根据条件选取了一些行之后，我们要针对这些行中的数据需要做些操作（比如针对age进行加1操作），更复杂的我们需要获取本行的其它列的数据共同计算和判断。这里我们可以使用如下技巧:<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">In [256]: df</span><br><span class="line">Out[256]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue   Steak    <span class="number"> 165 </span>   4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb     <span class="number"> 70 </span>   8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 120 </span>   9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple     <span class="number"> 80 </span>   3.3    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 180 </span>   1.8    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 172 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 150 </span>   2.2    TX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用mask作为我们的筛选条件</span></span><br><span class="line">In [258]: mask = (df.color=='blue')</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选出符合条件的行，并对age列的数据进行加1操作</span></span><br><span class="line">In [260]: df.loc[mask, 'age'] = df.loc[mask, 'age'] + 1</span><br><span class="line"></span><br><span class="line">In [261]: df</span><br><span class="line">Out[261]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane       <span class="number"> 31 </span>  blue   Steak    <span class="number"> 165 </span>   4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb     <span class="number"> 70 </span>   8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 120 </span>   9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple     <span class="number"> 80 </span>   3.3    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 180 </span>   1.8    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 172 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 150 </span>   2.2    TX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更复杂的，我们如果需要同一行的其它数据进行计算，那么我们就需要使用apply函数和并选出响应的列，如下:</span></span><br><span class="line">In [262]: df_with_age_height = df.loc[mask, ['age', 'height']]</span><br><span class="line"></span><br><span class="line">In [265]: df.loc[mask, 'score'] = df_with_age_height.apply(lambda row: row['age'] + row['</span><br><span class="line">     ...: height']/100, axis=1)</span><br><span class="line"></span><br><span class="line">In [266]: df</span><br><span class="line">Out[266]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane       <span class="number"> 31 </span>  blue   Steak    <span class="number"> 165 </span> 32.65    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb     <span class="number"> 70 </span>  8.30    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 120 </span>  9.00    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple     <span class="number"> 80 </span>  3.30    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 180 </span>  1.80    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 172 </span>  9.50    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 150 </span>  2.20    TX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用apply仍然是使用迭代的方式，我们可以通过vectorization的方式直接计算，如下</span></span><br><span class="line">In [10]: mask = (df.color == 'red')</span><br><span class="line">In [13]: df_with_age_height = df.loc[mask, ['age', 'height']]</span><br><span class="line">In [14]: df.loc[mask, 'score'] = (df_with_age_height['age'] + df_with_age_height['height'])/100</span><br><span class="line"></span><br><span class="line">In [15]: df</span><br><span class="line">Out[15]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue   Steak    <span class="number"> 165 </span>  1.95    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb     <span class="number"> 70 </span>  8.30    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 120 </span>  1.32    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple     <span class="number"> 80 </span>  3.30    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 180 </span>  1.80    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 172 </span>  9.50    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 150 </span>  2.19    TX</span><br></pre></td></tr></table></figure></p><p>关于vectorization矢量化的相关议题，可以参考文章<a href="https://www.jianshu.com/p/4855c24579b8" target="_blank" rel="noopener">Pandas系列4-数据矢量化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pandas的条件过滤是使用非常频繁的技巧，在这一节我们将看到各种不同的过滤技巧，如果读者有其它过滤技巧，也欢迎告诉我。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python定时任务-schedule vs. Celery vs. APScheduler</title>
    <link href="http://yoursite.com/2018/06/21/Python%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-schedule-vs--Celery-vs--APScheduler/"/>
    <id>http://yoursite.com/2018/06/21/Python定时任务-schedule-vs--Celery-vs--APScheduler/</id>
    <published>2018-06-21T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.904Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细讲述了在Python开发中常用的几种定时任务途径，并重点对比了schedule, Celery和APScheduler</p><p><a id="more"></a></p><p>在Python开发过程中我们经常需要执行定时任务，而此类任务我们通常有如下选项：</p><ul><li>自己造轮子</li><li>使用schedule库</li><li>使用Celery定时任务</li><li>使用APScheduler</li></ul><p>自己造轮子实现，最大的优势就是灵活性，调试方便，对于某些特定系统也许也是一种选择，不过对于大多数应用来说，我们应当尽可能地使用开源的成熟的方案。下面对后三种方案分别讨论：</p><h2>使用schedule库</h2><p>schedule库是一个轻量级的定时任务方案，<strong>优势是使用简单，也不需要做什么配置；缺点是无法动态添加任务，也无法将任务持久化。</strong></p><h5>安装</h5><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> schedule</span><br></pre></td></tr></table></figure></p><h5>使用</h5><p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">schedule</span></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">time</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">def</span> <span class="selector-tag">job</span>():</span><br><span class="line">    <span class="selector-tag">print</span>(<span class="string">"I'm working..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">schedule</span><span class="selector-class">.every</span>(<span class="number">10</span>)<span class="selector-class">.minutes</span><span class="selector-class">.do</span>(job)</span><br><span class="line"><span class="selector-tag">schedule</span><span class="selector-class">.every</span>()<span class="selector-class">.hour</span><span class="selector-class">.do</span>(job)</span><br><span class="line"><span class="selector-tag">schedule</span><span class="selector-class">.every</span>()<span class="selector-class">.day</span><span class="selector-class">.at</span>(<span class="string">"10:30"</span>)<span class="selector-class">.do</span>(job)</span><br><span class="line"><span class="selector-tag">schedule</span><span class="selector-class">.every</span>(<span class="number">5</span>)<span class="selector-class">.to</span>(<span class="number">10</span>)<span class="selector-class">.minutes</span><span class="selector-class">.do</span>(job)</span><br><span class="line"><span class="selector-tag">schedule</span><span class="selector-class">.every</span>()<span class="selector-class">.monday</span><span class="selector-class">.do</span>(job)</span><br><span class="line"><span class="selector-tag">schedule</span><span class="selector-class">.every</span>()<span class="selector-class">.wednesday</span><span class="selector-class">.at</span>(<span class="string">"13:15"</span>)<span class="selector-class">.do</span>(job)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">while</span> <span class="selector-tag">True</span>:</span><br><span class="line">    <span class="selector-tag">schedule</span><span class="selector-class">.run_pending</span>()</span><br><span class="line">    <span class="selector-tag">time</span><span class="selector-class">.sleep</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h2>使用Celery</h2><p>Celery在Python领域可谓大名鼎鼎，我们通常将Celery作为一个任务队列来使用，不过Celery也同时提供了定时任务功能。通常，当我们的解决方案中已经在使用Celery的时候可以考虑同时使用其定时任务功能，但是Celery无法在Flask这样的系统中动态添加定时任务（在Django中有相应的插件可以实现动态添加任务），而且如果对于不使用Celery的项目，单独为定时任务搭建Celery显得过于重量级了。(搭建Celery比较麻烦，还需要配置诸如RabbitMQ之类消息分发程序)。</p><p>Celery安装在此不再赘述，大家可以参考官网的资料</p><h5>使用</h5><p>Celery虽然无法动态添加定时任务，但是可以在程序固定位置添加定时任务，如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">app = Celery()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处on_after_configure装饰符意味着当Celery app配置完成之后调用该hook函数</span></span><br><span class="line"><span class="meta">@app.on_after_configure.connect</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_periodic_tasks</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># Calls test('hello') every 10 seconds.</span></span><br><span class="line">    sender.add_periodic_task(<span class="number">10.0</span>, test.s(<span class="string">'hello'</span>), name=<span class="string">'add every 10'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calls test('world') every 30 seconds</span></span><br><span class="line">    sender.add_periodic_task(<span class="number">30.0</span>, test.s(<span class="string">'world'</span>), expires=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Executes every Monday morning at 7:30 a.m.</span></span><br><span class="line">    sender.add_periodic_task(</span><br><span class="line">        crontab(hour=<span class="number">7</span>, minute=<span class="number">30</span>, day_of_week=<span class="number">1</span>),</span><br><span class="line">        test.s(<span class="string">'Happy Mondays!'</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure></p><ul><li><p>这里调用<code>add_periodic_task</code>用于添加一个定时任务，相当于在Celery config文件中的beat_schedule设置项中添加了一项，如下：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app<span class="selector-class">.conf</span><span class="selector-class">.beat_schedule</span> = &#123;</span><br><span class="line">    <span class="string">'add-every-30-seconds'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'tasks.add'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: <span class="number">30.0</span>,</span><br><span class="line">        <span class="string">'args'</span>: (<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>在<code>add_periodic_task</code>中指定job function时需要用<code>.s()</code>来调用</p></li></ul><h2>使用APScheduler</h2><p>笔者认为APScheduler是在实际项目最好用的一个工具库。<strong>它不仅可以让我们在程序中动态添加和删除我们的定时任务，还支持持久化，且其持久化方案支持很多形式，包括(Memory, MongoDB, SQLAlchemy, Redis, RethinkDB, ZooKeeper), 也可以非常好与一些Python framework集成(包括asyncio, gevent, Tornado, Twisted, Qt).</strong> 笔者所在的项目使用的是Flask框架，也有相应的插件可以供我们直接使用。</p><p>但是笔者没有使用插件，而是直接将APScheduler集成于项目代码中。</p><h5>初始化scheduler</h5><p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以在初始化Flask的时候调用，并将返回的scheduler赋给app</span></span><br><span class="line">def init_scheduler():</span><br><span class="line">    <span class="comment"># 这里用于持久化的设置，代码中演示使用MongoDB</span></span><br><span class="line">    <span class="comment"># client用于设置你自己的MongoDB的handler, 即MongoClient对象</span></span><br><span class="line">    <span class="attr">jobstores</span> = &#123;</span><br><span class="line">        'default': MongoDBJobStore(<span class="attr">client=your_db_handler,</span> <span class="attr">collection="schedule_job")</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">executors</span> = &#123;</span><br><span class="line">        'default': ThreadPoolExecutor(<span class="number">20</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">job_defaults</span> = &#123;</span><br><span class="line">        'coalesce': False,</span><br><span class="line">        'max_instances': <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 这里使用BackgroundScheduler即可</span></span><br><span class="line">    <span class="attr">scheduler</span> = BackgroundScheduler(<span class="attr">jobstores=jobstores,</span> <span class="attr">executors=executors,</span> <span class="attr">job_defaults=job_defaults,</span> <span class="attr">timezone=utc)</span></span><br><span class="line">    <span class="comment"># 注意这里一定要调用start启动scheduler</span></span><br><span class="line">    scheduler.start()</span><br><span class="line">    return scheduler</span><br></pre></td></tr></table></figure></p><h5>添加定时任务</h5><p>APScheduler将定时任务分为三种：</p><ul><li>interval: 比如每隔5分钟执行一次任务</li><li>cron: 比如每天早上5点执行一次任务</li><li>date: 比如在2018年5月5日执行一次任务</li></ul><p>我们以添加cron job为例：<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def test_job(name):</span><br><span class="line">    print <span class="string">"hello, %s"</span> % name</span><br><span class="line">    </span><br><span class="line">def add_daily_job(name):</span><br><span class="line">    <span class="attr">exec_time</span> = datetime.now() + timedelta(<span class="attr">minutes=2)</span></span><br><span class="line">    <span class="attr">hour</span> = exec_time.strftime(<span class="string">"%H"</span>)</span><br><span class="line">    <span class="attr">minute</span> = exec_time.strftime(<span class="string">"%M"</span>)</span><br><span class="line">    <span class="comment"># 这里要选择'cron'</span></span><br><span class="line">    <span class="comment"># 另外，job_id可以根据你自己的情况设定，其会被用于remove_job</span></span><br><span class="line">    current_app.scheduler.add_job(</span><br><span class="line">        test_job, 'cron', <span class="attr">hour=hour,</span> <span class="attr">minute=minute,</span></span><br><span class="line">        <span class="attr">args=[name],</span> <span class="attr">id=job_id)</span></span><br></pre></td></tr></table></figure></p><h5>删除定时任务</h5><p>通过在add_job时使用的job_id可以删除对应的定时任务。实际上在我们添加任务的时候，APScheduler会把相应的任务信息存储于我们jobstore中设置的持久化存储方案，这里使用的是MongoDB，然后当删除的时候会将相应的任务从MongoDB中删除。<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_daily_job</span><span class="params">(job_id)</span></span><span class="symbol">:</span></span><br><span class="line">    current_app.scheduler.remove_job(job_id)</span><br></pre></td></tr></table></figure></p><h2>总结：</h2><p>APScheduler在实际使用过程中拥有最大的灵活性，可以满足我们的大部分定时任务的相关需求；Celery比较重量级，通常如果项目中已有Celery在使用，而且不需要动态添加定时任务时可以考虑使用；schedule非常轻量级，使用简单，但是不支持任务的持久化，也无法动态添加删除任务，所以主要用于简单的小型应用。</p><h2>References</h2><ul><li><a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">Schedule</a></li><li><a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a></li><li><a href="https://apscheduler.readthedocs.io/en/latest/" target="_blank" rel="noopener">APScheduler</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细讲述了在Python开发中常用的几种定时任务途径，并重点对比了schedule, Celery和APScheduler&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列4-数据矢量化</title>
    <link href="http://yoursite.com/2018/06/21/Pandas%E7%B3%BB%E5%88%974-%E6%95%B0%E6%8D%AE%E7%9F%A2%E9%87%8F%E5%8C%96/"/>
    <id>http://yoursite.com/2018/06/21/Pandas系列4-数据矢量化/</id>
    <published>2018-06-21T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.895Z</updated>
    
    <content type="html"><![CDATA[<p>我们在处理数据问题时，经常会遇到的问题是要将原有数据进行转化，比如在原有数据的基础上+1操作，或者将原有数据的字符串全部转化为小写字符，更复杂的是要将原有数据的一部分提取出来使用。这些问题都是数据转化问题，即原有的数据不能直接使用，而要进一步转化后才能使用。</p><p><a id="more"></a></p><h2>问题</h2><p>我们在处理数据问题时，经常会遇到的问题是要将原有数据进行转化，比如在原有数据的基础上+1操作，或者将原有数据的字符串全部转化为小写字符，更复杂的是要将原有数据的一部分提取出来使用。这些问题都是数据转化问题，即原有的数据不能直接使用，而要进一步转化后才能使用。</p><h2>示例</h2><p>这里举一个笔者在实际项目中遇到的例子来说明。</p><p>笔者项目中需要收集的app version信息，原始信息如下：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">In</span> <span class="selector-attr">[167]</span>: <span class="selector-tag">df</span></span><br><span class="line"><span class="selector-tag">Out</span><span class="selector-attr">[167]</span>:</span><br><span class="line">        <span class="selector-tag">app_version</span>  <span class="selector-tag">uid</span></span><br><span class="line">0  7<span class="selector-class">.23</span><span class="selector-class">.1-180522122</span>    1</span><br><span class="line">1  7<span class="selector-class">.20</span><span class="selector-class">.1-180502135</span>    2</span><br><span class="line">2  7<span class="selector-class">.23</span><span class="selector-class">.1-180522122</span>    3</span><br><span class="line">3  7<span class="selector-class">.23</span><span class="selector-class">.1-180522122</span>    4</span><br><span class="line">4  7<span class="selector-class">.16</span><span class="selector-class">.7-180411077</span>    5</span><br></pre></td></tr></table></figure></p><p>但是实际上，我们只需要&quot;-&quot;之前的版本号，而且后续比较的时候要用'-'之前的数字进行比较，因此这样就涉及到了将原版本数据进行转化，即只提取'-'之前的数字，而舍弃后边的数字。</p><h4>迭代</h4><p>一个显而易见的做法是通过遍历的方式来逐行修改，如下图所示：<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">178</span>]: %%timeit</span><br><span class="line">     ...: <span class="keyword">for</span> <span class="keyword">index</span>, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">     ...:     df.iloc[<span class="keyword">index</span>, <span class="number">0</span>] = row[<span class="string">'app_version'</span>].split(<span class="string">'-'</span>)[<span class="number">0</span>]</span><br><span class="line">     ...:</span><br><span class="line"><span class="number">2.34</span> ms ± <span class="number">47.4</span> µs per <span class="keyword">loop</span> (mean ± std. dev. <span class="keyword">of</span> <span class="number">7</span> runs, <span class="number">100</span> loops <span class="keyword">each</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">179</span>]: df</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">179</span>]:</span><br><span class="line">  app_version  uid</span><br><span class="line"><span class="number">0</span>      <span class="number">7.23</span>.<span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">7.20</span>.<span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>      <span class="number">7.23</span>.<span class="number">1</span>    <span class="number">3</span></span><br><span class="line"><span class="number">3</span>      <span class="number">7.23</span>.<span class="number">1</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>      <span class="number">7.16</span>.<span class="number">7</span>    <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>再进一步，我们可以使用apply方法，如下：<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">181</span>]: df</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">181</span>]:</span><br><span class="line">        app_version  uid</span><br><span class="line"><span class="number">0</span>  <span class="number">7.23</span><span class="meta">.1</span>-<span class="number">180522122</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">7.20</span><span class="meta">.1</span>-<span class="number">180502135</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7.23</span><span class="meta">.1</span>-<span class="number">180522122</span>    <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">7.23</span><span class="meta">.1</span>-<span class="number">180522122</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.16</span><span class="meta">.7</span>-<span class="number">180411077</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">182</span>]: %%timeit</span><br><span class="line"><span class="symbol">     ...:</span> df[<span class="string">'app_version'</span>] = df[<span class="string">'app_version'</span>].apply(lambda x: x.split(<span class="string">'-'</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="symbol">     ...:</span></span><br><span class="line"><span class="number">247</span> µs ± <span class="number">11.4</span> µs per <span class="keyword">loop</span> (mean ± <span class="keyword">std</span>. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops <span class="number">each</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">183</span>]: df</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">183</span>]:</span><br><span class="line">  app_version  uid</span><br><span class="line"><span class="number">0</span>      <span class="number">7.23</span><span class="meta">.1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">7.20</span><span class="meta">.1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>      <span class="number">7.23</span><span class="meta">.1</span>    <span class="number">3</span></span><br><span class="line"><span class="number">3</span>      <span class="number">7.23</span><span class="meta">.1</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>      <span class="number">7.16</span><span class="meta">.7</span>    <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>我们可以发现使用<code>apply</code>不仅使得代码更加简洁，而且速度也有了较明显的提升。但是以上方法本质上都是通过迭代的方式一条一条的修改，那么我们能否进一步提升性能呢？</p><h4>矢量化</h4><p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">197</span>]: df</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">197</span>]:</span><br><span class="line">        app_version  uid</span><br><span class="line"><span class="number">0</span>  <span class="number">7.23</span><span class="meta">.1</span>-<span class="number">180522122</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">7.20</span><span class="meta">.1</span>-<span class="number">180502135</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7.23</span><span class="meta">.1</span>-<span class="number">180522122</span>    <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">7.23</span><span class="meta">.1</span>-<span class="number">180522122</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.16</span><span class="meta">.7</span>-<span class="number">180411077</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">198</span>]: %%timeit</span><br><span class="line"><span class="symbol">     ...:</span> df[<span class="string">'app_version'</span>] = df[<span class="string">'app_version'</span>].str.split(<span class="string">'-'</span>).str.get(<span class="number">0</span>)</span><br><span class="line"><span class="symbol">     ...:</span></span><br><span class="line"><span class="number">424</span> µs ± <span class="number">11.3</span> µs per <span class="keyword">loop</span> (mean ± <span class="keyword">std</span>. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops <span class="number">each</span>)</span><br></pre></td></tr></table></figure></p><p>这里发现矢量化貌似不能提高性能啊，这是为什么？</p><blockquote><p>这里我猜测是由于我们的矢量化代码是分为两步操作，且在数据量较小的情况下就会显得慢</p></blockquote><p>为了验证这个假设，我做了如下实验：先将原数据concat为2560条记录，然后再计算时间<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2557</span>  <span class="number">7.23</span><span class="number">.1</span><span class="number">-180522122</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2558</span>  <span class="number">7.23</span><span class="number">.1</span><span class="number">-180522122</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2559</span>  <span class="number">7.16</span><span class="number">.7</span><span class="number">-180411077</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2560</span> rows x <span class="number">2</span> columns]</span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">232</span>]: df3 = df</span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">233</span>]: <span class="comment">%%timeit</span></span><br><span class="line">     ...: df[<span class="string">'app_version'</span>] = df[<span class="string">'app_version'</span>].apply(lambda x: x.split(<span class="string">'-'</span>)[<span class="number">0</span>])</span><br><span class="line">     ...:</span><br><span class="line"><span class="number">1.36</span> ms ± <span class="number">35.4</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br><span class="line"></span><br><span class="line"># 矢量化方式</span><br><span class="line"><span class="symbol">In</span> [<span class="number">250</span>]: <span class="comment">%%timeit</span></span><br><span class="line">     ...: df[<span class="string">'app_version'</span>] = df[<span class="string">'app_version'</span>].str.split(<span class="string">"-"</span>).str.get(<span class="number">0</span>)</span><br><span class="line">     ...:</span><br><span class="line"><span class="number">2.61</span> ms ± <span class="number">113</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br></pre></td></tr></table></figure></p><p>发现单纯的数据量增大并没有影响结果，那么用其它转化来测试下，这里获取字符串长度的转化进行实验<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">253</span>]: %%timeit</span><br><span class="line">     ...: df[<span class="string">'length'</span>] = df[<span class="string">'app_version'</span>].str.len()</span><br><span class="line">     ...:</span><br><span class="line"><span class="number">901</span> µs ± <span class="number">17.5</span> µs per <span class="keyword">loop</span> (mean ± std. dev. <span class="keyword">of</span> <span class="number">7</span> runs, <span class="number">1000</span> loops <span class="keyword">each</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">254</span>]: %%timeit</span><br><span class="line">     ...: df3[<span class="string">'length'</span>] = df3[<span class="string">'app_version'</span>].apply(lambda x: len(x))</span><br><span class="line">     ...:</span><br><span class="line">     ...:</span><br><span class="line"><span class="number">1.16</span> ms ± <span class="number">14.7</span> µs per <span class="keyword">loop</span> (mean ± std. dev. <span class="keyword">of</span> <span class="number">7</span> runs, <span class="number">1000</span> loops <span class="keyword">each</span>)</span><br></pre></td></tr></table></figure></p><p>我们看到在这里就体现出了矢量化的优势，因为这里大家都是一步。</p><p>结论：当矢量化步数只有一步时，其性能还是要比apply方式好的，但当需要多步的时候，不一定好于apply方式。</p><p>那么，我们能否将其转化为一步呢？后发现有extract这样的函数，使用如下：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">312</span>]: df</span><br><span class="line">Out[<span class="number">312</span>]:</span><br><span class="line">        app_version  uid</span><br><span class="line"><span class="number">0</span>  <span class="number">7.23</span>.<span class="number">1</span>-<span class="number">180522122</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">7.20</span>.<span class="number">1</span>-<span class="number">180502135</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7.23</span>.<span class="number">1</span>-<span class="number">180522122</span>    <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">7.23</span>.<span class="number">1</span>-<span class="number">180522122</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.16</span>.<span class="number">7</span>-<span class="number">180411077</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">313</span>]: %%timeit</span><br><span class="line">     ...: df[<span class="string">'app_version'</span>] = df[<span class="string">'app_version'</span>].str.extract(<span class="string">r"([0-9\.]+)-[0-9]+"</span>, expand=Fal</span><br><span class="line">     ...: se)</span><br><span class="line">     ...:</span><br><span class="line"><span class="number">247</span> µs ± <span class="number">8.95</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br></pre></td></tr></table></figure></p><p>通过<code>extract</code>终于实现了一步的矢量化。而且性能上也是最优的。</p><blockquote><p>这里需要注意的是，如果使用timeit, 由于多次操作，会导致后续df中'app_version'的值变为NaN。当我们只操作一次的时候则不存在此问题。</p></blockquote><h2>References</h2><ul><li><a href="https://pandas.pydata.org/pandas-docs/stable/text.html" target="_blank" rel="noopener">Working with text data</a></li><li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/03.10-working-with-strings.html" target="_blank" rel="noopener">Working with strings</a></li><li><a href="https://python.freelycode.com/contribution/detail/1083" target="_blank" rel="noopener">优化Pandas代码执行速度入门指南</a></li><li><a href="https://blog.csdn.net/u010814042/article/details/76401133" target="_blank" rel="noopener">Pandas 中map, applymap and apply的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在处理数据问题时，经常会遇到的问题是要将原有数据进行转化，比如在原有
数据的基础上+1操作，或者将原有数据的字符串全部转化为小写字符，更复杂的是
要将原有数据的一部分提取出来使用。这些问题都是数据转化问题，即原有的数据
不能直接使用，而要进一步转化后才能使用。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列3-DataFrame之增加与删除</title>
    <link href="http://yoursite.com/2018/06/16/Pandas%E7%B3%BB%E5%88%973-DataFrame%E4%B9%8B%E5%A2%9E%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2018/06/16/Pandas系列3-DataFrame之增加与删除/</id>
    <published>2018-06-16T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.901Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Pandas的过程增删改查是频繁使用的操作，这一节主要就是展示DataFrame常用的增加和删除操作</p><p><a id="more"></a></p><h2>增加行和增加列</h2><p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加一列，我们可以有两种方式，如下：</span></span><br><span class="line">In [345]: df</span><br><span class="line">Out[345]:</span><br><span class="line">   one  two</span><br><span class="line">a   <span class="number"> 0 </span>   1</span><br><span class="line">b   <span class="number"> 4 </span>   5</span><br><span class="line">c   <span class="number"> 8 </span>   9</span><br><span class="line">d  <span class="number"> 12 </span>  13</span><br><span class="line"></span><br><span class="line">In [346]: df['three'] = [3, 5, 5, 7]</span><br><span class="line"></span><br><span class="line">In [347]: df</span><br><span class="line">Out[347]:</span><br><span class="line">   one  two  three</span><br><span class="line">a   <span class="number"> 0 </span>  <span class="number"> 1 </span>     3</span><br><span class="line">b   <span class="number"> 4 </span>  <span class="number"> 5 </span>     5</span><br><span class="line">c   <span class="number"> 8 </span>  <span class="number"> 9 </span>     5</span><br><span class="line">d  <span class="number"> 12 </span> <span class="number"> 13 </span>     7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用loc</span></span><br><span class="line">In [369]: df</span><br><span class="line">Out[369]:</span><br><span class="line">   one  two  three</span><br><span class="line">a   <span class="number"> 0 </span>  <span class="number"> 1 </span>     2</span><br><span class="line">b   <span class="number"> 4 </span>  <span class="number"> 5 </span>     6</span><br><span class="line">c   <span class="number"> 8 </span>  <span class="number"> 9 </span>    10</span><br><span class="line">d  <span class="number"> 12 </span> <span class="number"> 13 </span>    14</span><br><span class="line"></span><br><span class="line">In [370]: df.loc[:, "four"] = [1, 4, 5, 9]</span><br><span class="line"></span><br><span class="line">In [371]: df</span><br><span class="line">Out[371]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a   <span class="number"> 0 </span>  <span class="number"> 1 </span>    <span class="number"> 2 </span>    1</span><br><span class="line">b   <span class="number"> 4 </span>  <span class="number"> 5 </span>    <span class="number"> 6 </span>    4</span><br><span class="line">c   <span class="number"> 8 </span>  <span class="number"> 9 </span>   <span class="number"> 10 </span>    5</span><br><span class="line">d  <span class="number"> 12 </span> <span class="number"> 13 </span>   <span class="number"> 14 </span>    9</span><br></pre></td></tr></table></figure></p><p>需要注意的是使用如上两种方式增加一列的时候，其数组的长度必须与原有DataFrame的行数相同，否则会报如下错误<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Length <span class="keyword">of</span> values <span class="keyword">does</span> <span class="keyword">not</span> match <span class="built_in">length</span> <span class="keyword">of</span> index</span><br></pre></td></tr></table></figure></p><p>增加行同样我们也可以使用loc, 如下:<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [376]: df</span><br><span class="line">Out[376]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a   <span class="number"> 0 </span>  <span class="number"> 1 </span>    <span class="number"> 2 </span>    3</span><br><span class="line">b   <span class="number"> 4 </span>  <span class="number"> 5 </span>    <span class="number"> 6 </span>    7</span><br><span class="line">c   <span class="number"> 8 </span>  <span class="number"> 9 </span>   <span class="number"> 10 </span>   11</span><br><span class="line">d  <span class="number"> 12 </span> <span class="number"> 13 </span>   <span class="number"> 14 </span>   15</span><br><span class="line"></span><br><span class="line">In [377]: df.loc['e'] = [3, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">In [378]: df</span><br><span class="line">Out[378]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a   <span class="number"> 0 </span>  <span class="number"> 1 </span>    <span class="number"> 2 </span>    3</span><br><span class="line">b   <span class="number"> 4 </span>  <span class="number"> 5 </span>    <span class="number"> 6 </span>    7</span><br><span class="line">c   <span class="number"> 8 </span>  <span class="number"> 9 </span>   <span class="number"> 10 </span>   11</span><br><span class="line">d  <span class="number"> 12 </span> <span class="number"> 13 </span>   <span class="number"> 14 </span>   15</span><br><span class="line">e   <span class="number"> 3 </span>  <span class="number"> 7 </span>    <span class="number"> 8 </span>    9</span><br></pre></td></tr></table></figure></p><p>但很多时候，我们并不需要row index, 只想自动增加一行，那么可以通过如下的方式</p><p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [379]: df.loc[df.shape[0]+1] = [3, 5, 9, 9]</span><br><span class="line"></span><br><span class="line">In [380]: df</span><br><span class="line">Out[380]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a   <span class="number"> 0 </span>  <span class="number"> 1 </span>    <span class="number"> 2 </span>    3</span><br><span class="line">b   <span class="number"> 4 </span>  <span class="number"> 5 </span>    <span class="number"> 6 </span>    7</span><br><span class="line">c   <span class="number"> 8 </span>  <span class="number"> 9 </span>   <span class="number"> 10 </span>   11</span><br><span class="line">d  <span class="number"> 12 </span> <span class="number"> 13 </span>   <span class="number"> 14 </span>   15</span><br><span class="line">e   <span class="number"> 3 </span>  <span class="number"> 7 </span>    <span class="number"> 8 </span>    9</span><br><span class="line">6   <span class="number"> 3 </span>  <span class="number"> 5 </span>    <span class="number"> 9 </span>    9</span><br></pre></td></tr></table></figure></p><p>另外，我们还可以将数据转化为Series，然后利用concat或者append的方式将其与原有的DataFrame进行合并。这种方式不仅可以添加一行数据，也可以一次性添加多行数据。<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [392]: df = pd.DataFrame(np.arange(16).reshape((4,4)), index=[1, 2, 3, 4], columns=['a',</span><br><span class="line">     ...:  'b', 'c','d'])</span><br><span class="line"></span><br><span class="line">In [393]: df2 = pd.DataFrame(np.arange(16).reshape((4,4)), index=[5, 6, 7, 8], columns=['a'</span><br><span class="line">     ...: , 'b', 'c','d'])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里相当于添加了多行数据</span></span><br><span class="line">In [394]: pd.concat([df, df2])</span><br><span class="line">Out[394]:</span><br><span class="line">    a   b   c   d</span><br><span class="line">1  <span class="number"> 0 </span> <span class="number"> 1 </span> <span class="number"> 2 </span>  3</span><br><span class="line">2  <span class="number"> 4 </span> <span class="number"> 5 </span> <span class="number"> 6 </span>  7</span><br><span class="line">3  <span class="number"> 8 </span> <span class="number"> 9 </span><span class="number"> 10 </span> 11</span><br><span class="line">4 <span class="number"> 12 </span><span class="number"> 13 </span><span class="number"> 14 </span> 15</span><br><span class="line">5  <span class="number"> 0 </span> <span class="number"> 1 </span> <span class="number"> 2 </span>  3</span><br><span class="line">6  <span class="number"> 4 </span> <span class="number"> 5 </span> <span class="number"> 6 </span>  7</span><br><span class="line">7  <span class="number"> 8 </span> <span class="number"> 9 </span><span class="number"> 10 </span> 11</span><br><span class="line">8 <span class="number"> 12 </span><span class="number"> 13 </span><span class="number"> 14 </span> 15</span><br></pre></td></tr></table></figure></p><p>更多关于concat和append将在后续的章节详细讲解。</p><h2>删除行和删除列</h2><p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">In [751]: df</span><br><span class="line">Out[751]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue   Steak    <span class="number"> 178 </span>   4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb    <span class="number"> 181 </span>   8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 178 </span>   9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple    <span class="number"> 178 </span>   3.3    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 175 </span>   1.8    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 178 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 178 </span>   2.2    TX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用drop删除index为'Dean'的行</span></span><br><span class="line">In [752]: df.drop(['Dean'])</span><br><span class="line">Out[752]:</span><br><span class="line">           age  color   food  height  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue  Steak    <span class="number"> 178 </span>   4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green   Lamb    <span class="number"> 181 </span>   8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red  Mango    <span class="number"> 178 </span>   9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white  Apple    <span class="number"> 178 </span>   3.3    AL</span><br><span class="line">Christina  <span class="number"> 33 </span> black  Melon    <span class="number"> 178 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red  Beans    <span class="number"> 178 </span>   2.2    TX</span><br><span class="line"></span><br><span class="line">In [749]: df</span><br><span class="line">Out[749]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue   Steak    <span class="number"> 178 </span>   4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb    <span class="number"> 181 </span>   8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 178 </span>   9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple    <span class="number"> 178 </span>   3.3    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 175 </span>   1.8    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 178 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 178 </span>   2.2    TX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用drop删除名为'height'的列，注意需要使用axis=1</span></span><br><span class="line"><span class="comment"># 使用inplace来空值是在同一块内存还是copy</span></span><br><span class="line">In [750]: df.drop(['height'], axis=1, inplace=True)</span><br><span class="line">Out[750]:</span><br><span class="line">           age  color    food  score state</span><br><span class="line">Jane       <span class="number"> 30 </span>  blue   Steak    4.6    NY</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb    8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple    3.3    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    1.8    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    2.2    TX</span><br><span class="line"></span><br><span class="line"><span class="comment"># drop多列</span></span><br><span class="line">df.drop(['height', 'food'], axis=1, inplace=True)</span><br></pre></td></tr></table></figure></p><h2>条件删除</h2><p>由于在数据清洗的过程中经常需要删除不符合条件的record，所以以下这种条件过滤行就非常有用。<strong>需要注意的是，这里是重新生成了一个DataFrame，而不是直接在原有的DataFrame上修改</strong><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [755]: df2 = df[df.color!='blue']</span><br><span class="line"></span><br><span class="line">In [756]: df2</span><br><span class="line">Out[756]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Nick        <span class="number"> 2 </span> green    Lamb    <span class="number"> 181 </span>   8.3    TX</span><br><span class="line">Aaron      <span class="number"> 12 </span>   red   Mango    <span class="number"> 178 </span>   9.0    FL</span><br><span class="line">Penelope    <span class="number"> 4 </span> white   Apple    <span class="number"> 178 </span>   3.3    AL</span><br><span class="line">Dean       <span class="number"> 32 </span>  gray  Cheese    <span class="number"> 175 </span>   1.8    AK</span><br><span class="line">Christina  <span class="number"> 33 </span> black   Melon    <span class="number"> 178 </span>   9.5    TX</span><br><span class="line">Cornelia   <span class="number"> 69 </span>   red   Beans    <span class="number"> 178 </span>   2.2    TX</span><br></pre></td></tr></table></figure></p><h2>去重</h2><p>使用<code>drop_duplicates</code>，我们可以去掉重复项，这是一个非常有用的函数，下面我们来详细分析下</p><ul><li>通过参数subset,指定去重比较时用哪些column。如果不指定则所有的数据都会比较，只有所有列的数据都一致的时候才会去掉，否则不会去掉，如下：<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">In</span> [<span class="number">459</span>]: df_con2</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">459</span>]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line"><span class="number">0</span>  <span class="built_in">a1</span>     <span class="number">1</span>   <span class="number">4</span>.<span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="built_in">a2</span>     <span class="number">3</span>   <span class="number">5</span>.<span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">b1 </span>    <span class="number">5</span>   <span class="number">7</span>.<span class="number">0</span></span><br><span class="line"><span class="number">0</span>  <span class="built_in">a1</span>     <span class="number">2</span>   <span class="number">4</span>.<span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="built_in">a2</span>     <span class="number">5</span>   NaN</span><br><span class="line"><span class="number">2</span>  <span class="built_in">a3</span>     <span class="number">2</span>   <span class="number">2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">460</span>]: df_drop = df_con2.drop_duplicates()</span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">461</span>]: df_drop</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">461</span>]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line"><span class="number">0</span>  <span class="built_in">a1</span>     <span class="number">1</span>   <span class="number">4</span>.<span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="built_in">a2</span>     <span class="number">3</span>   <span class="number">5</span>.<span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">b1 </span>    <span class="number">5</span>   <span class="number">7</span>.<span class="number">0</span></span><br><span class="line"><span class="number">0</span>  <span class="built_in">a1</span>     <span class="number">2</span>   <span class="number">4</span>.<span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="built_in">a2</span>     <span class="number">5</span>   NaN</span><br><span class="line"><span class="number">2</span>  <span class="built_in">a3</span>     <span class="number">2</span>   <span class="number">2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><p>我们可以让两个dataframe只比较uid列，只要这一列的数据重复，我们就认为重复，如下：<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">In</span> [<span class="number">462</span>]: df_drop2 = df_con2.drop_duplicates(<span class="keyword">subset='uid')</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">In </span>[<span class="number">463</span>]: df_drop2</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">463</span>]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line"><span class="number">0</span>  <span class="built_in">a1</span>     <span class="number">1</span>   <span class="number">4</span>.<span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="built_in">a2</span>     <span class="number">3</span>   <span class="number">5</span>.<span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">b1 </span>    <span class="number">5</span>   <span class="number">7</span>.<span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="built_in">a3</span>     <span class="number">2</span>   <span class="number">2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure></p><ul><li>另外从上边的例子可以看出，其去重是去掉了后边出现的重复的项，我们也可以保留后边的项，将前边的项去掉，那么就需要使用keep参数。另外，我们也可以直接在DataFrame中进行去重，而不需要再另外copy一份数据，这可以通过<code>inplace=True</code>来实现，示例如下：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [453]: df_con</span><br><span class="line">Out[453]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line">0  a1     1   4.0</span><br><span class="line">1  a2     3   5.0</span><br><span class="line">2  b1     5   7.0</span><br><span class="line">0  a1     2   4.0</span><br><span class="line">1  a2     5   NaN</span><br><span class="line">2  a3     2   2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里没有赋值操作，因为使用了inplace=True</span></span><br><span class="line"><span class="comment"># 使用keep='last'用于保存后边的数据，删除前边的重复项</span></span><br><span class="line"><span class="keyword">In</span> [454]: df_con.drop_duplicates(<span class="attribute">subset</span>=<span class="string">'uid'</span>, <span class="attribute">keep</span>=<span class="string">'last'</span>, <span class="attribute">inplace</span>=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [455]: df_con</span><br><span class="line">Out[455]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line">2  b1     5   7.0</span><br><span class="line">0  a1     2   4.0</span><br><span class="line">1  a2     5   NaN</span><br><span class="line">2  a3     2   2.0</span><br></pre></td></tr></table></figure></li></ul><h2>References</h2><ul><li><a href="https://stackoverflow.com/questions/10715965/add-one-row-in-a-pandas-dataframe" target="_blank" rel="noopener">StackOverflow</a></li><li><a href="https://www.jianshu.com/p/67e67c7034f6" target="_blank" rel="noopener">删除行和列</a></li><li><a href="http://pandas.pydata.org/pandas-docs/stable/merging.html" target="_blank" rel="noopener">Merging</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Pandas的过程增删改查是频繁使用的操作，这一节主要就是展示DataFrame常用的增加和删除操作&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列2-DataFrame之数据定位</title>
    <link href="http://yoursite.com/2018/06/15/Pandas%E7%B3%BB%E5%88%972-DataFrame%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/06/15/Pandas系列2-DataFrame之数据定位/</id>
    <published>2018-06-15T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.903Z</updated>
    
    <content type="html"><![CDATA[<p>在Pandas中我们往往需要先定位数据才能进行相应的赋值、修改等后续操作，因此定位是Pandas中非常重要的一环，本文将详解Pandas中的各种定位方式。</p><p><a id="more"></a></p><p>在Pandas中我们主要通过以下几个函数来定位DataFrame中的特定数据</p><ul><li>iloc</li><li>loc</li><li>iat</li><li>at</li></ul><p>总的来说，分为两种：</p><ol><li><p>一种是通过lables(即row index和column names，这里row index可以字符，日期等非数字index)(使用loc, at);</p></li><li><p>另一种通过index(这里特指数字位置index)(使用iloc, iat)</p></li></ol><p>loc和at的区别在于， loc可以选择特定的行或列，但是at只能定位某个特定的值，标量值。一般情况下，我们iloc和loc更加通用，而at, iat有一定的性能提升。</p><p>具体示例可以参考Reference中StackOverflow的示例下面展示一些特别的：<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">630</span>]: df</span><br><span class="line">Out[<span class="number">630</span>]:</span><br><span class="line">           age  <span class="built_in">color</span>    food  <span class="built_in">height</span>  score state</span><br><span class="line">Jane        <span class="number">30</span>   <span class="built_in">blue</span>   Steak     <span class="number">165</span>    <span class="number">4.6</span>    NY</span><br><span class="line">Nick         <span class="number">2</span>  <span class="built_in">green</span>    Lamb      <span class="number">70</span>    <span class="number">8.3</span>    TX</span><br><span class="line">Aaron       <span class="number">12</span>    <span class="built_in">red</span>   Mango     <span class="number">120</span>    <span class="number">9.0</span>    FL</span><br><span class="line">Penelope     <span class="number">4</span>  white   Apple      <span class="number">80</span>    <span class="number">3.3</span>    AL</span><br><span class="line">Dean        <span class="number">32</span>   gray  Cheese     <span class="number">180</span>    <span class="number">1.8</span>    AK</span><br><span class="line">Christina   <span class="number">33</span>  black   Melon     <span class="number">172</span>    <span class="number">9.5</span>    TX</span><br><span class="line">Cornelia    <span class="number">69</span>    <span class="built_in">red</span>   Beans     <span class="number">150</span>    <span class="number">2.2</span>    TX</span><br><span class="line"></span><br><span class="line"># 选择某一行数据</span><br><span class="line">In [<span class="number">631</span>]: df.loc[<span class="string">'Dean'</span>]</span><br><span class="line">Out[<span class="number">631</span>]:</span><br><span class="line">age           <span class="number">32</span></span><br><span class="line"><span class="built_in">color</span>       gray</span><br><span class="line">food      Cheese</span><br><span class="line"><span class="built_in">height</span>       <span class="number">180</span></span><br><span class="line">score        <span class="number">1.8</span></span><br><span class="line">state         AK</span><br><span class="line">Name: Dean, dtype: object</span><br><span class="line"></span><br><span class="line"># 选择某一列数据，逗号前面是行的label，逗号后边是列的label，使用<span class="string">":"</span>来表示选取所有的，本例是选取所有的行，当<span class="string">':'</span>在逗号后边时表示选取所有的列，但通常我们可以省略。</span><br><span class="line">In [<span class="number">241</span>]: df.loc[:, <span class="string">'color'</span>]</span><br><span class="line">Out[<span class="number">241</span>]:</span><br><span class="line">Jane          <span class="built_in">blue</span></span><br><span class="line">Nick         <span class="built_in">green</span></span><br><span class="line">Aaron          <span class="built_in">red</span></span><br><span class="line">Penelope     white</span><br><span class="line">Dean          gray</span><br><span class="line">Christina    black</span><br><span class="line">Cornelia       <span class="built_in">red</span></span><br><span class="line">Name: <span class="built_in">color</span>, dtype: object</span><br><span class="line"># 也可以如下选取一列，但是与前者是有区别的，具体参考Reference中的《Returning a view versus a <span class="built_in">copy</span>》</span><br><span class="line">In [<span class="number">632</span>]: df.loc[:][<span class="string">'color'</span>]</span><br><span class="line">Out[<span class="number">632</span>]:</span><br><span class="line">Jane          <span class="built_in">blue</span></span><br><span class="line">Nick         <span class="built_in">green</span></span><br><span class="line">Aaron          <span class="built_in">red</span></span><br><span class="line">Penelope     white</span><br><span class="line">Dean          gray</span><br><span class="line">Christina    black</span><br><span class="line">Cornelia       <span class="built_in">red</span></span><br><span class="line">Name: <span class="built_in">color</span>, dtype: object</span><br><span class="line"></span><br><span class="line"># 选择某几行数据，注意无论选择多行还是多列，都需要将其label放在一个数组当中，而选择单个行或列，则不需要放在数组当中</span><br><span class="line">In [<span class="number">634</span>]: df.loc[[<span class="string">'Nick'</span>, <span class="string">'Dean'</span>]]</span><br><span class="line">Out[<span class="number">634</span>]:</span><br><span class="line">      age  <span class="built_in">color</span>    food  <span class="built_in">height</span>  score state</span><br><span class="line">Nick    <span class="number">2</span>  <span class="built_in">green</span>    Lamb      <span class="number">70</span>    <span class="number">8.3</span>    TX</span><br><span class="line">Dean   <span class="number">32</span>   gray  Cheese     <span class="number">180</span>    <span class="number">1.8</span>    AK</span><br><span class="line"></span><br><span class="line"># 注意以下这种用法不行，这是由于Pandas会认为逗号后边是列的label</span><br><span class="line">df.loc[<span class="string">'Nick'</span>, <span class="string">'Dean'</span>]</span><br><span class="line"></span><br><span class="line"># 选择范围</span><br><span class="line">In [<span class="number">636</span>]: df.loc[<span class="string">'Nick'</span>:<span class="string">'Christina'</span>]</span><br><span class="line">Out[<span class="number">636</span>]:</span><br><span class="line">           age  <span class="built_in">color</span>    food  <span class="built_in">height</span>  score state</span><br><span class="line">Nick         <span class="number">2</span>  <span class="built_in">green</span>    Lamb      <span class="number">70</span>    <span class="number">8.3</span>    TX</span><br><span class="line">Aaron       <span class="number">12</span>    <span class="built_in">red</span>   Mango     <span class="number">120</span>    <span class="number">9.0</span>    FL</span><br><span class="line">Penelope     <span class="number">4</span>  white   Apple      <span class="number">80</span>    <span class="number">3.3</span>    AL</span><br><span class="line">Dean        <span class="number">32</span>   gray  Cheese     <span class="number">180</span>    <span class="number">1.8</span>    AK</span><br><span class="line">Christina   <span class="number">33</span>  black   Melon     <span class="number">172</span>    <span class="number">9.5</span>    TX</span><br><span class="line"></span><br><span class="line"># iloc的特定用法, 可以用<span class="number">-1</span>这样index来获取最后一行的数据</span><br><span class="line">In [<span class="number">637</span>]: df.iloc[[<span class="number">1</span>, <span class="number">-1</span>]]</span><br><span class="line">Out[<span class="number">637</span>]:</span><br><span class="line">          age  <span class="built_in">color</span>   food  <span class="built_in">height</span>  score state</span><br><span class="line">Nick        <span class="number">2</span>  <span class="built_in">green</span>   Lamb      <span class="number">70</span>    <span class="number">8.3</span>    TX</span><br><span class="line">Cornelia   <span class="number">69</span>    <span class="built_in">red</span>  Beans     <span class="number">150</span>    <span class="number">2.2</span>    TX</span><br></pre></td></tr></table></figure></p><p>数据定位是后续条件过滤、赋值以及各种转换的基础，一定要熟练掌握。</p><p>另外，在定位某一个具体的元素的时候，loc和at并不完全相同</p><p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># loc支持以下两种定位方式</span></span><br><span class="line">In [<span class="number">726</span>]: df.loc[<span class="string">'Jane'</span>, <span class="string">'score'</span>]</span><br><span class="line">Out[<span class="number">726</span>]: <span class="number">4.6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">727</span>]: df.loc[<span class="string">'Jane'</span>][<span class="string">'score'</span>]</span><br><span class="line">Out[<span class="number">727</span>]: <span class="number">4.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是at只支持第一种定位方式</span></span><br><span class="line">In [<span class="number">729</span>]: df.at[<span class="string">'Nick'</span>, <span class="string">'height'</span>]</span><br><span class="line">Out[<span class="number">729</span>]: <span class="number">181</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">730</span>]: df.at[<span class="string">'Nick'</span>][<span class="string">'height'</span>]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-<span class="number">730</span>-<span class="number">948408</span>df1727&gt; <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> df.at[<span class="string">'Nick'</span>][<span class="string">'height'</span>]</span><br><span class="line"></span><br><span class="line">~<span class="regexp">/.pyenv/versions</span><span class="regexp">/3.6.4/envs</span><span class="regexp">/data_analysis/lib</span><span class="regexp">/python3.6/site</span>-packages/pandas/core/indexing.py <span class="keyword">in</span> __getitem_<span class="number">_</span>(<span class="keyword">self</span>, key)</span><br><span class="line">   <span class="number">1867</span></span><br><span class="line">   <span class="number">1868</span>         key = <span class="keyword">self</span>._convert_key(key)</span><br><span class="line">-&gt; <span class="number">1869</span>         <span class="keyword">return</span> <span class="keyword">self</span>.obj._get_value(*key, takeable=<span class="keyword">self</span>._takeable)</span><br><span class="line">   <span class="number">1870</span></span><br><span class="line">   <span class="number">1871</span>     <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span></span>(<span class="keyword">self</span>, key, value)<span class="symbol">:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">TypeError:</span> _get_value() missing <span class="number">1</span> required positional <span class="symbol">argument:</span> <span class="string">'col'</span></span><br></pre></td></tr></table></figure></p><p>有两点需要说明：</p><ul><li>在针对特定元素赋值的时候最好使用at来进行操作，性能提升还是很明显的。</li><li>loc的两种方式并不等同，<code>df.loc['Jane', 'score']</code>是在同一块内存中对数据进行操作，而<code>df.loc['Jane']['score']</code>是在另一个copy上进行操作，具体参考<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy" target="_blank" rel="noopener">Returning a view versus a copy</a></li></ul><h2>References</h2><ul><li><a href="https://stackoverflow.com/questions/28757389/loc-vs-iloc-vs-ix-vs-at-vs-iat" target="_blank" rel="noopener">StackOverflow: iloc vs. loc vs. iat vs. at</a></li><li><a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy" target="_blank" rel="noopener">Returning a view versus a copy</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Pandas中我们往往需要先定位数据才能进行相应的赋值、修改等后续操作，因此定位是Pandas中非常重要的一环，本文将详解Pandas中的各种定位方式。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列1-DataFrame之初始化</title>
    <link href="http://yoursite.com/2018/06/08/Pandas%E7%B3%BB%E5%88%971-DataFrame%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2018/06/08/Pandas系列1-DataFrame之初始化/</id>
    <published>2018-06-08T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.903Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas中如果要初始化DataFrame对象，实际又很多种方式，本文将详解Pandas初始化的几种不同方式。</p><p><a id="more"></a></p><p>DataFrame有多种初始化方法，主要分为以下几种情况：</p><ul><li>通过Object初始化</li><li>通过文件初始化</li><li>通过SQL查询结果初始化</li><li>通过NoSQL数据库查询结果初始化</li></ul><p>下面分别介绍：</p><h2>通过object初始化</h2><p>这又分为以下几种方式</p><ul><li>Dict of 1D ndarrays, lists, dicts, or Series</li><li>2-D numpy.ndarray</li><li>Structured or record ndarray</li><li>A Series</li><li>Another DataFrame</li></ul><h4>通过list</h4><p>通过1D data series初始化的时候，如果有多列，那么需要等长<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># columns参数是通过一个list参数来指定column labels</span><br><span class="line">df = pd.<span class="symbol">DataFrame</span>([[<span class="string">'a1'</span>, <span class="number">1</span>], [<span class="string">'a2'</span>, <span class="number">4</span>]], columns=[<span class="string">'uid'</span>, <span class="string">'score'</span>])</span><br><span class="line"><span class="symbol">In</span> [<span class="number">477</span>]: df</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">477</span>]:</span><br><span class="line">  uid  score</span><br><span class="line"><span class="number">0</span>  a1      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  a2      <span class="number">4</span></span><br></pre></td></tr></table></figure></p><h4>通过Dict of 1D ndarray</h4><p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">298</span>]: df = pd.DataFrame(&#123;<span class="symbol">'col1</span>': np.arange(<span class="number">3</span>), <span class="symbol">'col2</span>': np.arange(<span class="number">5</span>, <span class="number">8</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">299</span>]: df</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">299</span>]:</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">0</span>     <span class="number">5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">6</span></span><br><span class="line"><span class="number">2</span>     <span class="number">2</span>     <span class="number">7</span></span><br></pre></td></tr></table></figure></p><h4>通过Dict of lists</h4><p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">In</span> [<span class="number">294</span>]: df = pd.<span class="symbol">DataFrame</span>(&#123;<span class="string">'col1'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'col2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">295</span>]: df</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">295</span>]:</span><br><span class="line">   col1 col2</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>    a</span><br><span class="line"><span class="number">1</span>     <span class="number">2</span>    b</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>    c</span><br><span class="line"><span class="number">3</span>     <span class="number">4</span>    d</span><br></pre></td></tr></table></figure></p><h4>通过list of dicts</h4><p>注意与上边的dict of lists区分，如果最外层是dict，那么key值默认是column label。而在list of dicts中，每个dict都是一个record，或者说一行<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 可以不等长，缺失值自动设为<span class="symbol">NaN</span></span><br><span class="line"><span class="symbol">In</span> [<span class="number">49</span>]: data2 = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">20</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">50</span>]: pd.<span class="symbol">DataFrame</span>(data2)</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">50</span>]: </span><br><span class="line">   a   b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="symbol">NaN</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">51</span>]: pd.<span class="symbol">DataFrame</span>(data2, index=[<span class="string">'first'</span>, <span class="string">'second'</span>])</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">51</span>]: </span><br><span class="line">        a   b     c</span><br><span class="line">first   <span class="number">1</span>   <span class="number">2</span>   <span class="symbol">NaN</span></span><br><span class="line">second  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">In</span> [<span class="number">52</span>]: pd.<span class="symbol">DataFrame</span>(data2, columns=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="symbol">Out</span>[<span class="number">52</span>]: </span><br><span class="line">   a   b</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure></p><h4>通过Dict of Series</h4><p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">314</span>]: s = pd.Series(<span class="keyword">range</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">315</span>]: s</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">315</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">316</span>]: p = pd.Series(<span class="keyword">range</span>(<span class="number">8</span>, <span class="number">13</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">317</span>]: p</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">317</span>]:</span><br><span class="line"><span class="number">0</span>     <span class="number">8</span></span><br><span class="line"><span class="number">1</span>     <span class="number">9</span></span><br><span class="line"><span class="number">2</span>    <span class="number">10</span></span><br><span class="line"><span class="number">3</span>    <span class="number">11</span></span><br><span class="line"><span class="number">4</span>    <span class="number">12</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">318</span>]: df = pd.DataFrame(&#123;<span class="string">'a'</span>: s, <span class="string">'b'</span>: p&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">319</span>]: df</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">319</span>]:</span><br><span class="line">   a   b</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>   <span class="number">8</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>   <span class="number">9</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2</span>  <span class="number">10</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">11</span></span><br><span class="line"><span class="number">4</span>  <span class="number">4</span>  <span class="number">12</span></span><br></pre></td></tr></table></figure></p><h4>通过2-D numpy.ndarray</h4><p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">289</span>]: df = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>,<span class="number">4</span>)), columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>,</span><br><span class="line">     ...:  <span class="string">'four'</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">290</span>]: df</span><br><span class="line">Out[<span class="number">290</span>]:</span><br><span class="line">   <span class="literal">one</span>  <span class="literal">two</span>  <span class="literal">three</span>  <span class="literal">four</span></span><br><span class="line"><span class="keyword">a</span>    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">b    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">c    <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">d   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure></p><h2>通过文件初始化</h2><p>pandas通过各种数据文件也可以初始化，比如csv文件，excel文件，json文件，html文件等，详见下图<img src="https://upload-images.jianshu.io/upload_images/3959253-4ebb77efcd970e59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO Tools"></p><p>下面以<code>read_csv</code>详细解释下读取csv文件以及初始化的过程<code>read_csv</code>的完整文档参考<a href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.read_csv.html#pandas.read_csv" target="_blank" rel="noopener">read_csv api</a>，下面通过示例对常用的parameter进行解释：</p><p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csv_path = <span class="string">"./test.csv"</span></span><br><span class="line"><span class="attribute">columns</span> = [<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line">dtype = &#123;<span class="string">'id'</span>: int, <span class="string">'name'</span>: <span class="selector-tag">object</span>, <span class="string">'age'</span>: int&#125;</span><br><span class="line">pd.read_csv(csv_path, header=None, names=<span class="attribute">columns</span>, dtype=dtype)</span><br></pre></td></tr></table></figure></p><ul><li>filepath_or_buffer, 这个是最基本的参数，用以指明文件的路径(路径可以是字符串，也可以是各种path对象，详见文档)或者文件对象(也可以接收类文件对象, 即提供read method， 如StringIO对象)。另外，这个参数也可以是一个URL，而这个URL可以http, ftp, 或者s3的url.</li></ul><blockquote><p>对于没有权限限制的url，直接使用read_csv可以大大简化代码，但是通过我们的数据不会放置到公开的url地址上，因此这就涉及权限的问题，通常还是通过其它手段将文件下载到本地后再读取。</p></blockquote><ul><li>header, 这个参数用于设置第几行为column names, 默认是'infer'，即Pandas会自动推断哪一行是column names。当文件中没有column names时，相当于设定header=0。很多时候想要忽略原始的column names而自己设定column names，那么可以将这个参数设置为None, 然后通过names参数来设定column names</li><li>names, 用于设定column names</li><li>dtype, 用于设定每一列对应的数据类型，需要注意的是对string类型需要设置为object</li><li>nrows, 要读取多少行，通过这个参数我们可以部分读取文件</li><li>usecols, 用于选定列，即指定哪些列load进DataFrame中，通过这个参数可以只读取我们需要的数据，从而减少内存占用，加快load速度。</li></ul><h2>通过SQL查询结果初始化</h2><p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas.io.sql <span class="keyword">as</span> sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># conn是数据库的连接对象</span></span><br><span class="line">sql.read_frame('select * <span class="keyword">from</span> test', conn)</span><br></pre></td></tr></table></figure></p><h2>NoSQL查询结果初始化</h2><p>这里以MongoDB为例<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从MongoDB中查询年龄大于20岁的用户，查询返回一个cursor对象</span></span><br><span class="line"><span class="attr">user_results</span> = user.find(&#123;<span class="string">"age"</span>: &#123;<span class="string">"$gt"</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将cursor对象转化为list，然后初始化</span></span><br><span class="line"><span class="comment"># columns可以用于选取相应的field的数据，只有在这个列表中的field才会被load进DataFrame对象当中，如果没有对应的数据，会被填入NaN</span></span><br><span class="line"><span class="attr">df</span> = pd.DataFrame(list(user_results), columns=[<span class="string">'id'</span>, <span class="string">'age'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是如果不指定columns参数，有可能导致某些为空的field没有对应的列，如果指定了列名称，则如果相对应的域没有数据的话，就会自动置为nan</p><h2>References</h2><ul><li><a href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.read_csv.html#pandas.read_csv" target="_blank" rel="noopener">read_csv API</a></li><li><a href="https://pandas.pydata.org/pandas-docs/version/0.22/io.html#io-read-csv-table" target="_blank" rel="noopener">IO Tools</a></li><li>《利用Python进行数据分析》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pandas中如果要初始化DataFrame对象，实际又很多种方式，本文将详解Pandas初始化的几种不同方式。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB大批量读写数据优化记录</title>
    <link href="http://yoursite.com/2018/04/20/MongoDB%E5%A4%A7%E6%89%B9%E9%87%8F%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/04/20/MongoDB大批量读写数据优化记录/</id>
    <published>2018-04-20T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.902Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要阐述了MongoDB大批量数据读写过程中的一些优化技巧</p><p><a id="more"></a></p><h2>用批量写入代替单个写入</h2><p>最开始，我的代码逻辑是这样的：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> uid, <span class="keyword">data</span> <span class="keyword">in</span> user_dict.items():</span><br><span class="line">    user_collection.insert_one(&#123;<span class="string">'uid'</span>:uid, <span class="string">'user_data'</span>: <span class="keyword">data</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>这种方法在数据量较小时可以很好的工作，但是当数据量非常大时，此种操作会非常慢，我们需要通过批量写入的方式来写入数据。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_data = (&#123;<span class="string">'uid'</span>: uid, <span class="string">'user_data'</span>: <span class="keyword">data</span>&#125; <span class="keyword">for</span> uid, <span class="keyword">data</span> <span class="keyword">in</span> user_dict.items())</span><br><span class="line">user_collection.insert_many(user_data)</span><br></pre></td></tr></table></figure></p><h2>调整insert_many参数</h2><p>再来看是否可以通过调整insert_many参数来进一步优化性能。</p><ul><li>ordered: 这个参数为True时，迫使MongoDB按顺序同步插入数据；而如果为False，则MongoDB会并发的不按固定顺序进行批量插入。显然当我们对性能有要求时，将该参数设为False是非常必要的。</li><li>bypass_document_validation: MongoDB3.2之后加入了document validation功能，用于验证写入的文档是否符合collection制定的规则，具体可以参考reference中的链接。而既然是验证就肯定需要花费时间，当我们对性能有极致要求时，也可以将此参数设为True，从而越过验证，直接写入。</li><li>session: 关于session，请参考References中的Client Session链接。</li></ul><p>修改后的代码如下：<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_data = (&#123;<span class="string">'uid'</span>: uid, <span class="string">'user_data'</span>: <span class="built_in">data</span>&#125; for uid, <span class="built_in">data</span> <span class="keyword">in</span> user_dict.items())</span><br><span class="line">user_collection.insert_many(user_data, ordere=<span class="literal">False</span>, bypass_document_validation=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><p>最终性能的提升是非常明显的，时间量级从天降为分钟。</p><h2>批量更新</h2><p>前面的例子在插入操作时非常有效，但是对于更新操作由于update_many无法针对每一个doc进行更新，如本例中针对每一个uid进行更新，那么就需要使用<code>bulk_write</code>操作。<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo import UpdateOne</span><br><span class="line"></span><br><span class="line">update_operations = []</span><br><span class="line"><span class="keyword">for</span> uid, user_data <span class="built_in">in</span> user_dict.<span class="built_in">items</span>():</span><br><span class="line">    op = UpdateOne(&#123;<span class="string">'uid'</span>: uid&#125;, &#123;<span class="string">'$set'</span>: &#123;<span class="string">'user_data'</span>: user_data&#125;&#125;, upsert=<span class="literal">True</span>)</span><br><span class="line">    update_operations.<span class="built_in">append</span>(op)</span><br><span class="line"></span><br><span class="line">user_collection.bulk_write(update_operations, ordered=<span class="literal">False</span>, bypass_document_validation=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h2>批量读取</h2><p>批量读取我们可以使用<code>$in</code>操作符，但是需要注意的是如果<code>$in</code>针对的list过大，那么可能会导致报错<code>pymongo.errors.DocumentTooLarge</code>, 目前我的做法是将大的list分割成1000个一段，然后分段查询<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">list_length</span> = len(uid_list)</span><br><span class="line"><span class="attr">iter_size</span> = <span class="number">1000</span></span><br><span class="line"><span class="attr">current</span> = <span class="number">0</span></span><br><span class="line">while current &lt; list_length:</span><br><span class="line">    <span class="attr">end</span> = current + iter_size</span><br><span class="line">    <span class="attr">uid_segment</span> = uid_list[current: end]</span><br><span class="line">    <span class="attr">result_cursor</span> = mongo_collection.find(&#123;<span class="string">"uid"</span>: &#123;<span class="string">"$in"</span>: uid_segment&#125;&#125;)</span><br><span class="line">    for user_info <span class="keyword">in</span> result_cursor:</span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="attr">current</span> = current + iter_size</span><br></pre></td></tr></table></figure></p><h2>异常处理</h2><p>在实践过程中，会遇到异常的情况，尤其是写入的时候，可能由于各种原因导致写入失败，因此需要catch exception，并打印详细信息，如下：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    user_collection.insert_many(</span><br><span class="line">        data_iter, <span class="attribute">ordered</span>=<span class="literal">False</span>, <span class="attribute">bypass_document_validation</span>=<span class="literal">True</span>)</span><br><span class="line">except BulkWriteError as e:</span><br><span class="line">    lg.<span class="builtin-name">error</span>(e.details)</span><br></pre></td></tr></table></figure></p><h2>References:</h2><ul><li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html" target="_blank" rel="noopener">PyMongo API</a></li><li><a href="http://www.shangyang.me/2017/08/22/mongodb-basic-09-document-validation/" target="_blank" rel="noopener">MongoDB document validation</a></li><li><a href="https://docs.mongodb.com/manual/core/read-isolation-consistency-recency/#sessions" target="_blank" rel="noopener">Client Session</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要阐述了MongoDB大批量数据读写过程中的一些优化技巧&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在Flask中使用Celery的最佳实践</title>
    <link href="http://yoursite.com/2018/02/22/flask_celery/"/>
    <id>http://yoursite.com/2018/02/22/flask_celery/</id>
    <published>2018-02-22T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.902Z</updated>
    
    <content type="html"><![CDATA[<p>主要是笔者在项目实践中总结的关于Celery使用的一些最佳实践，欢迎补充</p><p><a id="more"></a></p><h2>写在前面</h2><p>本最佳实践是基于作者有限的经验，欢迎大家共同讨论，可以持续维护此最佳实践。另本文中所使用的环境为Mac&amp;Ubuntu环境，软件版本如下：</p><ul><li>Celery (4.1.0)</li><li>Flask (0.12.1)</li><li>RabbitMQ(3.6.9)</li><li>librabbitmq (1.6.1)</li></ul><h2>介绍</h2><p>简单来说Celery是一个异步的任务队列，当我们需要将一些任务(比如一些需要长时间操作的任务)异步操作的时候，这时候Celery就可以帮到我们，另外Celery还支持定时任务(类似Crontab)。详细的介绍可以参考<a href="http://www.celeryproject.org/" target="_blank" rel="noopener">官网</a></p><h2>使用RabbitMQ作为Broker</h2><p>RabbitMQ是官方推荐使用的Broker，它实际是一个消息中间件，负责消息的路由分发，安装RabbitMQ如下：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install on Ubuntu</span></span><br><span class="line">apt-<span class="builtin-name">get</span> update</span><br><span class="line">apt-<span class="builtin-name">get</span> install rabbitmq-server -yq</span><br></pre></td></tr></table></figure></p><p>需要注意的是，线上环境我们需要创建新的账号，并将guest账号删除，操作如下：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl <span class="keyword">add_user </span>myuser mypassword  <span class="comment"># 新增用户</span></span><br><span class="line">rabbitmqctl <span class="keyword">add_vhost </span>myvhost  <span class="comment"># 新增vhost，以使用不同的命名空间</span></span><br><span class="line">rabbitmqctl set_permissions -p myvhost myuser <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span>  <span class="comment"># 设置权限</span></span><br><span class="line">rabbitmqctl  delete_user guest  <span class="comment"># 安全原因，删除guest</span></span><br></pre></td></tr></table></figure></p><p>注意：vhost是一个虚拟空间，用于区分不同类型的消息然后，在Celery的配置中配置broker URL<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CELERY_BROKER_URL</span> = <span class="string">'amqp://myuser:mypassword@localhost:5672/myvhost'</span></span><br></pre></td></tr></table></figure></p><p>注意：当使用amqp协议头时，如果安装有<code>librabbitmq</code>则使用<code>librabbitmq</code>，否则使用pyamqp</p><h2>Celery的日志输出</h2><p>在task中想要输出日志，最好的方法是通过如下方式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.utils.log <span class="keyword">import</span> get_task_logger</span><br><span class="line"></span><br><span class="line">lg = get_task_logger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_test</span><span class="params">()</span>:</span></span><br><span class="line">    lg.debug(<span class="string">"in log_test()"</span>)</span><br></pre></td></tr></table></figure></p><p>但是仅如此会发现所有的日志最后都跑到shell窗口的stdout当中，原来必须得在启动celery的时候使用-f option来指定输出文件，如下：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A main<span class="selector-class">.celery</span> worker -l debug -f log/celery/celery_task<span class="selector-class">.log</span> &amp;</span><br></pre></td></tr></table></figure></p><p>-A：指定celery实例worker: 启动worker进程-l：指定log level，这里指定log level为debug level-f：指定输出的日志文件</p><h2>使用Redis作为backend</h2><p>当使用Redis作为存储后端的时候，我们可以通过设置DB number来使得Celery的结果存储与其它数据存储隔离开来，比如在笔者的项目中，redis还用作缓存的存储后端，因此为了区分，Celery在使用Redis的时候使用的DB number是1（默认是0），关于Redis DB number可以参考<a href="http://blog.teeceepee.com/blog/2015/02/14/redis-db-number/" target="_blank" rel="noopener">这里</a>.因此我们的backend设置如下：<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CELERY_RESULT_BACKEND = 'redis://localhost:<span class="number">6379</span>/1' <span class="meta"># 最后的数字1代表DB number</span></span><br></pre></td></tr></table></figure></p><p>查看Celery任务的结果可以通过Redis-cli连接Redis数据库进行查看<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> redis-cli</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select 1 <span class="comment"># 这里选择DB 1， 也可以在使用redis-cli -n 1来进入指定的DB</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get key <span class="comment"># 获取指定key对应的结果</span></span></span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-5674ca727b61be6d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis-cli.jpg"></p><h2>调试代码</h2><p>我认为此处是非常重要的一个技巧，即在调试代码的时候，我们可以将<code>delay</code>或者<code>apply_async</code>先去掉，直接调用worker的函数进行同步调试，调试成功后再加上<code>delay</code>或者<code>apply_async</code> method</p><h2>Celery可能会遇到的坑</h2><h4>Celery4.x版本使用librabbitmq的问题</h4><p>Celery 4.x版本在使用librabbitmq时，会出现类似这样的错误<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Received <span class="keyword">and</span> deleted unknown <span class="keyword">message</span>.  Wrong destination?!?</span><br></pre></td></tr></table></figure></p><p>完整错误如图：<img src="http://upload-images.jianshu.io/upload_images/3959253-43eac6585498fc34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="celeryerror"></p><p>解决这个问题有两个方式：</p><ol><li>推荐方式，更改配置项<em>task_protocol</em>为1。Github上Robert Kopaczewski详细解释了这个问题，原文如下：</li></ol><blockquote><p>Apparently librabbitmq issue is related to new default protocol in celery 4.x. You can switch to previous protocol version by either putting CELERY_TASK_PROTOCOL = 1 in your settings if you're using Django or settings app.conf.task_protocol = 1 in celeryconf.py.</p></blockquote><ol start="2"><li>另一种方式是不使用librabbitmq, 通过pip uninstall librabbitmq, 并且更改broker配置的协议头为'pyamqp',如下，也可以解决这个问题。<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BROKER_URL</span> = <span class="string">'pyamqp://guest:guest@localhost:5672/%2F'</span></span><br></pre></td></tr></table></figure></li></ol><p>由于librabbitmq的性能优势，我们还是推荐方式1来解决该问题。</p><h4>RabbitMQ远程连接问题</h4><p>如果RabbitMQ与Celery不在同一台机器上，除在Celery配置的时候要将<code>BROKER_URL</code>设置为正确的IP地址外，还需要将Rabbitmq的配置文件<code>/usr/local/etc/rabbitmq/rabbitmq-env.conf</code>中的<code>NODE_IP_ADDRESS</code>更改为0.0.0.0<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_IP_ADDRESS=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p><h4>Celery import问题</h4><p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">The message has been ignored and discarded.</span><br><span class="line"></span><br><span class="line">Did you remember to import the module containing this task?</span><br><span class="line">Or maybe you're using relative imports?</span><br><span class="line"></span><br><span class="line">Please see</span><br><span class="line">http://docs.celeryq.org/en/latest/internals/protocol.html</span><br><span class="line">for more information.</span><br><span class="line"></span><br><span class="line">The full contents of the message body was:</span><br><span class="line">'<span class="tag">\<span class="name">x</span></span>8e<span class="tag">\<span class="name">xa</span></span>7expires<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>3utc<span class="tag">\<span class="name">xc</span></span>3<span class="tag">\<span class="name">xa</span></span>4args<span class="tag">\<span class="name">x</span></span>91<span class="tag">\<span class="name">x</span></span>85<span class="tag">\<span class="name">xa</span></span>3tid<span class="tag">\<span class="name">xb</span></span>85971a43d47f84bb278f77fc2<span class="tag">\<span class="name">xa</span></span>3sen<span class="tag">\<span class="name">xa</span></span>2A1<span class="tag">\<span class="name">xa</span></span>2tt<span class="tag">\<span class="name">xa</span></span>2ar<span class="tag">\<span class="name">xa</span></span>2co<span class="tag">\<span class="name">xc</span></span>4<span class="tag">\<span class="name">x</span></span>00<span class="tag">\<span class="name">xa</span></span>1t<span class="tag">\<span class="name">xa</span></span>4like<span class="tag">\<span class="name">xa</span></span>5chord<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>9callbacks<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>8errbacks<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>7taskset<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>2id<span class="tag">\<span class="name">xc</span></span>4<span class="formula">$c133dbf8-2c89-4311-b7cf-c377041058ec<span class="tag">\<span class="name">xa</span></span>7retries<span class="tag">\<span class="name">x</span></span>00<span class="tag">\<span class="name">xa</span></span>4task<span class="tag">\<span class="name">xd</span></span>9$</span>tasks.messageTasks.send_like_message<span class="tag">\<span class="name">xa</span></span>5group<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>9timelimit<span class="tag">\<span class="name">x</span></span>92<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>3eta<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>6kwargs<span class="tag">\<span class="name">x</span></span>80' (239b)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/Users/liufeng/.pyenv/versions/2.7.13/envs/kaopu_backend/lib/python2.7/site-packages/celery/worker/consumer/consumer.py", line 561, in on_task_received</span><br><span class="line">    strategy = strategies[type_]</span><br><span class="line">KeyError: u'tasks.messageTasks.send_like_message'</span><br></pre></td></tr></table></figure></p><p>出现这条错误是由于我们的tasks跟celery并不是在同一个文件中，即不是同一个module，当我们通过如下命令启动task worker时，实际只加载了app module，而没有加载tasks相关的module<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">celery</span> -A app.celery worker -l <span class="literal">info</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>要解决这个问题，必须为celery配置文件添加import参数，如下<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config[<span class="string">'imports'</span>] = [<span class="string">'tasks.messageTasks'</span>]</span><br></pre></td></tr></table></figure></p><h4>Celery unregistered task问题</h4><p>在开发过程中遇到了这样一个问题<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[2017-08-31 15:38:19,605: ERROR/MainProcess] Received unregistered task of type u'app.tasks.messageTasks.send_follow_message'.</span><br><span class="line">The message has been ignored and discarded.</span><br><span class="line"></span><br><span class="line">Did you remember to import the module containing this task?</span><br><span class="line">Or maybe you're using relative imports?</span><br><span class="line"></span><br><span class="line">Please see</span><br><span class="line">http://docs.celeryq.org/en/latest/internals/protocol.html</span><br><span class="line">for more information.</span><br><span class="line"></span><br><span class="line">The full contents of the message body was:</span><br><span class="line">'<span class="tag">\<span class="name">x</span></span>8e<span class="tag">\<span class="name">xa</span></span>7expires<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>3utc<span class="tag">\<span class="name">xc</span></span>3<span class="tag">\<span class="name">xa</span></span>4args<span class="tag">\<span class="name">x</span></span>91<span class="tag">\<span class="name">x</span></span>86<span class="tag">\<span class="name">xa</span></span>6sender<span class="tag">\<span class="name">xa</span></span>5Jenny<span class="tag">\<span class="name">xa</span></span>9target_id<span class="tag">\<span class="name">xb</span></span>859a5313847f84be534ad7d46<span class="tag">\<span class="name">xabtarget</span></span>_type<span class="tag">\<span class="name">xa</span></span>4user<span class="tag">\<span class="name">xa</span></span>7content<span class="tag">\<span class="name">xc</span></span>4<span class="tag">\<span class="name">x</span></span>00<span class="tag">\<span class="name">xa</span></span>8receiver<span class="tag">\<span class="name">xb</span></span>859a5313847f84be534ad7d46<span class="tag">\<span class="name">xa</span></span>4type<span class="tag">\<span class="name">xa</span></span>6follow<span class="tag">\<span class="name">xa</span></span>5chord<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>9callbacks<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>8errbacks<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>7taskset<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>2id<span class="tag">\<span class="name">xc</span></span>4<span class="formula">$a4d40c14-1976-41a6-a753-d2a495929920<span class="tag">\<span class="name">xa</span></span>7retries<span class="tag">\<span class="name">x</span></span>00<span class="tag">\<span class="name">xa</span></span>4task<span class="tag">\<span class="name">xd</span></span>9*app.tasks.messageTasks.send_follow_message<span class="tag">\<span class="name">xa</span></span>5group<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>9timelimit<span class="tag">\<span class="name">x</span></span>92<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>3eta<span class="tag">\<span class="name">xc</span></span>0<span class="tag">\<span class="name">xa</span></span>6kwargs<span class="tag">\<span class="name">x</span></span>80' (312b)</span></span><br><span class="line"><span class="formula">Traceback (most recent call last):</span></span><br><span class="line"><span class="formula">  File "/Users/liufeng/.pyenv/versions/2.7.13/envs/kaopu_backend/lib/python2.7/site-packages/celery/worker/consumer/consumer.py", line 561, in on_task_received</span></span><br><span class="line"><span class="formula">    strategy = strategies[type_]</span></span><br><span class="line"><span class="formula">KeyError: u'app.tasks.messageTasks.send_follow_message'</span></span><br></pre></td></tr></table></figure></p><p>解决这个问题，最开始是根据提示，将所有涉及到task的module全部加上<code>from __future__ import absolute_import</code> 之后运行之后还是不行，后来发现是由于之前启动时使用的是app module， 但是我的代码已经改成了main.py，所以重新启动了celery，最后问题解决</p><h4>使用镜像迁移系统也依然需要重新添加rabbitmq的用户</h4><p>问题最开始是发现无法点赞，也无法Follow用户，通过http消息发现出现502错误，于是登录到服务器检查，发现应用服务本身没有任何报错，于是又去查看Celery的日志，结果发现出现如下错误：<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2017</span>-<span class="number">11</span>-<span class="number">13</span> <span class="number">16</span>:<span class="number">32</span>:<span class="number">01</span>,<span class="number">243</span>: <span class="literal">ERROR</span>/MainProcess] consumer: Cannot connect <span class="keyword">to</span> amqp://celeryuser:**@loc      alhost:<span class="number">5672</span>/celeryvhost: Couldn<span class="symbol">'t</span> log <span class="keyword">in</span>: a socket <span class="literal">error</span> occurred.</span><br></pre></td></tr></table></figure></p><p>经过一番搜索发现网上的评论主要是说URL不对的情况下会出现这种情况，但是我的URL没有改过啊，那又会是什么问题呢？继续看，发现有人提到了权限问题，于是又是一番检查，发现RabbitMQ中并没有原先设置的用户（我使用的是原系统的镜像，原以为用户也是已经设置好的）<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看有哪些用户</span></span><br><span class="line"><span class="attribute">rabbitmqctl</span>  list_users</span><br></pre></td></tr></table></figure></p><p>然后就简单了，按照步骤创建用户，vhost，再赋予权限，删除guest，然后就终于都连好了</p><p>另外，发现从镜像复制系统后，RabbitMQ并不能正常工作，必须杀掉原先的进程，重新启动</p><h4>更改task的代码后，重启Celery</h4><p>需要注意的是，在更改task的代码后，必须重新启动Celery，否则代码改动无法生效，可能导致一些意外的问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是笔者在项目实践中总结的关于Celery使用的一些最佳实践，欢迎补充&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Flask/"/>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="celery" scheme="http://yoursite.com/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>Python collections.deque vs. Queue.Queue vs. multiprocessing.Queue</title>
    <link href="http://yoursite.com/2018/02/12/Python-collections-deque-vs--Queue-Queue-vs--multiprocessing-Queue/"/>
    <id>http://yoursite.com/2018/02/12/Python-collections-deque-vs--Queue-Queue-vs--multiprocessing-Queue/</id>
    <published>2018-02-12T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.906Z</updated>
    
    <content type="html"><![CDATA[<p>总体上来说，当需要在进程间通信的时候需要使用multiprocessing.Queue; 当在同一个进程当中，而需要多线程之间通信的时候，可以使用Queue.Queue；而至于collections.deque一般就是在同一个线程当中，作为一种数据结构来使用的。下面分别讲述一下它们的用法：</p><p><a id="more"></a></p><h3>multiprocessing.Queue</h3><p>multiprocessing提供了两种进程间通信机制，一种是我们要说的Queue，另外一种是Pipe。而实际上Queue也是通过Pipe来实现的。具体可以参考<a href="https://docs.python.org/2/library/multiprocessing.html#exchanging-objects-between-processes" target="_blank" rel="noopener">进程间通信</a>Queue常用methods：</p><ul><li>Queue.qsize(): 返回queue中item的数量，注意这个数量并不准确,  not reliable</li><li>Queue.empty(): return True if queue is empty,  not reliable</li><li>Queue.full(): return True if queue is full,  not reliable</li><li>Queue.put(item[, block[, timeout]]): block表示是否阻塞，默认为True即阻塞，如果设定了timeout，则阻塞timeout时长，如果仍然没有空余的slot，则raise Queue.full exception。如果block=False，那么就不阻塞，当queue full时，直接报Queue.full exception。</li><li>Queue.put_nowait(item): Equivalent to put(item, False)</li><li>Queue.get([block[, timeout]])</li><li>Queue.get_nowait(): Equivalent to get(False)</li></ul><p>示例：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing <span class="keyword">import</span> <span class="built_in">Process</span>, Queue</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.<span class="built_in">put</span>([<span class="number">42</span>, None, <span class="string">'hello'</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = <span class="built_in">Process</span>(target=f, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span> q.<span class="built_in">get</span>()    <span class="meta"># prints <span class="meta-string">"[42, None, 'hello']"</span></span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><p><strong>需要注意的是Queue不提供join()和task_done()，因此在producer process中无法确保所有的task均已经被处理, 如果需要join and task_done就需要使用multiprocessing.JoinableQueue，详情参看<a href="https://docs.python.org/2/library/multiprocessing.html?highlight=multiprocessing#multiprocessing.JoinableQueue" target="_blank" rel="noopener">JoinableQueue</a></strong></p><h3>Queue.Queue</h3><p>Queue.Queue通常用于同一个进程中的不同线程间的通信，其提供的方法与multiprocessing.Queue类似，但是多出了两个methods如下：</p><ul><li>task_done(): 用于告知任务完成</li><li>join(): 用于等待队列中所有的任务完成。具体使用见下图<img src="http://upload-images.jianshu.io/upload_images/3959253-0e780f8002f768ac.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="queue"></li></ul><h3>collections.deque</h3><p>主要用于队列这种数据结构，通过append和popleft来实现队列的FIFO机制。常用方法如下：</p><ul><li>extendleft</li><li>appendleft</li><li>popleft</li><li>extend</li><li>append</li><li>pop具体参考<a href="https://docs.python.org/2/library/collections.html?highlight=deque#deque-objects" target="_blank" rel="noopener">官网</a>示例：<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; from collections import deque</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d = deque(<span class="string">'ghi'</span>)                 <span class="comment"># make a new deque with three items</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; for elem in <span class="symbol">d:</span>                   <span class="comment"># iterate over the deque's elements</span></span><br><span class="line">...     print elem.upper()</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">I</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.append(<span class="string">'j'</span>)                    <span class="comment"># add a new entry to the right side</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.appendleft(<span class="string">'f'</span>)                <span class="comment"># add a new entry to the left side</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d                                <span class="comment"># show the representation of the deque</span></span><br><span class="line">deque([<span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.pop()                          <span class="comment"># return and remove the rightmost item</span></span><br><span class="line"><span class="string">'j'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.popleft()                      <span class="comment"># return and remove the leftmost item</span></span><br><span class="line"><span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; list(d)                          <span class="comment"># list the contents of the deque</span></span><br><span class="line">[<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d[<span class="number">0</span>]                             <span class="comment"># peek at leftmost item</span></span><br><span class="line"><span class="string">'g'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d[-<span class="number">1</span>]                            <span class="comment"># peek at rightmost item</span></span><br><span class="line"><span class="string">'i'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; list(reversed(d))                <span class="comment"># list the contents of a deque in reverse</span></span><br><span class="line">[<span class="string">'i'</span>, <span class="string">'h'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'h'</span> in d                         <span class="comment"># search the deque</span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.extend(<span class="string">'jkl'</span>)                  <span class="comment"># add multiple elements at once</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d</span><br><span class="line">deque([<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.rotate(<span class="number">1</span>)                      <span class="comment"># right rotation</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d</span><br><span class="line">deque([<span class="string">'l'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.rotate(-<span class="number">1</span>)                     <span class="comment"># left rotation</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d</span><br><span class="line">deque([<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; deque(reversed(d))               <span class="comment"># make a new deque in reverse order</span></span><br><span class="line">deque([<span class="string">'l'</span>, <span class="string">'k'</span>, <span class="string">'j'</span>, <span class="string">'i'</span>, <span class="string">'h'</span>, <span class="string">'g'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.clear()                        <span class="comment"># empty the deque</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.pop()                          <span class="comment"># cannot pop from an empty deque</span></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;pyshell#6&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> -toplevel-</span><br><span class="line">    d.pop()</span><br><span class="line"><span class="symbol">IndexError:</span> pop from an empty deque</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d.extendleft(<span class="string">'abc'</span>)              <span class="comment"># extendleft() reverses the input order</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; d</span><br><span class="line">deque([<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总体上来说，当需要在进程间通信的时候需要使用multiprocessing.Queue; 当在同一个进程当中，而需要多线程之间通信的时候，可以使用Queue.Queue；而至于collections.deque一般就是在同一个线程当中，作为一种数据结构来使用的。下面分别讲述一下它们的用法：&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="queue" scheme="http://yoursite.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB Sharding</title>
    <link href="http://yoursite.com/2018/02/03/MongoDB-Sharding/"/>
    <id>http://yoursite.com/2018/02/03/MongoDB-Sharding/</id>
    <published>2018-02-03T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.905Z</updated>
    
    <content type="html"><![CDATA[<p>详细介绍MongoDB sharding</p><p><a id="more"></a></p><h2>介绍</h2><h2>Sharding Key</h2><ul><li>Sharding key必须是在对应的collection当中所有的文档都存在的field，比如我要sharding我的user collection，我就可以找nick_name这种所有documents中都存在的field来做为sharding key，当然还要考虑其它因素，但是这个是一个必要条件。</li><li>sharding key可以一个或者多个fields组成，还以user document为例，除了可以使用nick_name还可以加一个created time一起作为sharding key。当然具体使用什么field要根据系统的实际情况来综合考虑。</li><li>sharding只能有一个，而且设定后不可更改</li><li>针对已经有数据的collections做sharding时，原collections必须有以sharding key开头的索引；如果是空的collection，则MongoDB会自动创建对应的索引</li></ul><h2>Sharding的优势</h2><h3>读写效率</h3><p>由于我们可以将相应的写操作分布在不同的shard上，可以更加均匀分担写压力，因此写的性能一般情况下会得到提高。读取操作时，如果query中包含shard key对应的field，或者以这个field为prefix的compound index key</p><h3>存储容量</h3><p>由于是水平分割，因此几乎可以无限扩容，不需要担心某个collection过大而无法单机存储的问题</p><h3>高可用</h3><p>从MongoDB3.2开始，config server已经支持replicaset模式，这样的话sharding节点和config节点均可以通过replicaset来保证高可用。</p><h2>关于Sharding的考虑</h2><p>由于sharding的不可逆性，所以最好是先不使用sharding，在业务运行一段时间后，根据业务的情况来做决定，这主要需要考虑如下因素：</p><ul><li>某个collection的数据是否非常大，达到未来可能一台机器的存储容量都无法解决该collection的存储。</li><li>是否有些collection存在性能问题，希望通过sharding来解决</li><li>由于具有不可逆性，我们可以只针对需要做sharding的collection做sharding，而其它collection不需要sharding。不做sharding的collection会存储于primary shard之上（所以可见这个shard应该有更大的容量）</li><li>针对需要分片的collection，需要确定满足以下几个条件：<ul><li>选取的key可以使得collection的数据能均衡地分布在不同的shard上</li><li>写请求的时候也能均匀分布，比如时间戳作为key时，虽然也能将key均匀分布到不同的shard上，但是同一时间段，写请求就会持续在一个shard上，这样就不是均匀写了</li><li>我们针对该collection的查询主要是使用哪个field来作为查询条件，那么这个field最好是作为shard key</li><li>作为sharding key的field需要有索引，或者是作为compound索引的prefix。</li><li>尽量避免会导致jumbo chunk的key，比如通过age来作为key，同一个age的数据均会放到同一个chunk，这就可能导致chunk不断变大，当超过chunk size时，就会变成jumbo chunk</li></ul></li></ul><h2>Sharding策略</h2><p>Sharding有两种策略：一种是ranged sharding; 另一种是hashed sharding。</p><ul><li>如果选择的key，其值域非常接近，尤其是单调递增或者递减(increase or decrease monotonically, 也可以翻译成单向递增递减)，就会导致所有的新增操作都会集中在最大的range的shard上（如果是递增）；或者集中在最小range的那个shard上（如果是递减）。这就导致无法均匀地进行写操作（因为所有的写操作都集中在一个shard甚至一个chunk上）。而那个最大或最小range的shard将成为系统的瓶颈。具体参考<a href="https://docs.mongodb.com/manual/core/sharding-shard-key/#shard-key-monotonic" target="_blank" rel="noopener">shard-key-monotonic</a>。在这种情况下，我们应当选择hashed sharding.</li><li>hashed sharding。MongoDB通过hash算法(MD5)来计算key的hash值，然后将数据存储于对应范围的chunk上。由于算法的原因，即使非常&quot;近&quot;的key通过hash之后的值可能会有很大的差异，从而可以更加均匀的分布在不同的chunk之上。hashed sharding的缺点在于当我们的业务有很多范围查询时，（比如uid 5~20)，此时由于可能分布在很多不同的chunk上，所以就必须进行广播时操作，即要求所有的shard都进行查询，看是否有在这个范围内的数据，如果有就会交给mongos，mongos再负责将这些数据组合成一个完整的答案给客户端。这种情况下，势必会影响到查询性能。所以具体使用什么样的策略，需要综合考虑很多因素。</li></ul><h2>Splitting and Migration</h2><h3>Splitting</h3><p>splitting就是当chunk中存储的数据量超过设定的chunk size时(默认64M)，将其分裂成两个chunk，具体参考<a href="https://docs.mongodb.com/manual/core/sharding-data-partitioning/#chunk-splits" target="_blank" rel="noopener">chunk split</a><img src="http://upload-images.jianshu.io/upload_images/3959253-e563c219fc51aa4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Splitting"></p><h3>Migration</h3><p>数据迁移，是将某一个shard中的chunk数据迁移到另一个shard上。迁移有两种方式，一种是手动迁移，一种自动迁移。大部分时候，MongoDB会通过balancer进行自动迁移，以保持chunk在shard上能够均匀分布。手动迁移仅用于某些特定场景如bulk insert。</p><h4>关于balancer</h4><p>balancer是一个后台进程，它会自动判断含有最多chunk的shard和最少chunk的shard之间的chunk数量差达到了设定的threshold，如果达到了，就会自动进行数据迁移。<img src="http://upload-images.jianshu.io/upload_images/3959253-2700a7cbe0745a9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Balancing"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详细介绍MongoDB sharding&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB的事务、ACID和一致性</title>
    <link href="http://yoursite.com/2018/01/10/MongoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E3%80%81ACID%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/2018/01/10/MongoDB的事务、ACID和一致性/</id>
    <published>2018-01-10T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.905Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇<a href="http://localhost:4000/2018/01/08/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%8CACID%EF%BC%8CCAP%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/" target="_blank" rel="noopener">《理解数据库的事务，ACID，CAP和一致性》</a>我已经将数据库的一些基本概念包括事务，ACID，CAP，一致性，隔离性等都深入的介绍了一遍，而此篇主要是针对MongoDB数据库系统做一下深入的了解，主要希望弄清楚如下几个问题：</p><p><a id="more"></a></p><ul><li>MongoDB是如何实现事务的？有哪些局限？</li><li>MongoDB的一致性是如何保证的？</li></ul><h2>MongoDB的事务</h2><p>首先我们需要知道MongoDB是有多种存储引擎的，不同的存储引擎在实现ACID的时候，使用不同的机制。而Mongodb从3.0开始默认使用的是WiredTiger引擎，本文后续所有文字均是针对WiredTiger引擎。WiredTiger引擎可以针对单个文档来保证ACID特性，但是当需要操作多个文档的时候无法保证ACID，也即无法提供事务支持。但是，我们是否就无法实现事务呢？实际上，MongoDB本身虽然不支持跨文档的事务，但是我们依然可以可以在应用层来获取类似事务的支持。这其中有很多方式，MongoDB公司的Antoine Girbal曾经撰写过文章详细阐释了五种方式来支持事务，可以参考Reference中的链接。不过在此之前，让我们先了解下MongoDB在单文档上是如何实现ACID特性的。</p><h4>单文档的ACID是如何实现的？</h4><p>MongoDB在更新单个文档时，会对该文档加锁，而要理解MongoDB的锁机制，需要先了解以下几个概念：</p><ul><li><p>Intent Lock（我把它翻译为<em>意图锁</em>): 意图锁表明读写方(reader-writer)意图针对更细粒度的资源进行读取或写入操作。比如：如果当某个Collection被加了intent lock，那么说明读写方意图针对该Collection中的某个文档进行读或写的操作。如下图所示：<img src="http://upload-images.jianshu.io/upload_images/3959253-1d185d143c10acfe.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1:MongoDB Lock">上图展示了当reader or writer需要操作文档时，相对更高的层级都需要加intent lock.</p></li><li><p>Multiple granularity locking (我把它翻译为<em>多粒度锁机制</em>): MongoDB采用的是所谓的MGL多粒度锁机制，具体可以参考文末的wiki链接。简单来说就是结合了多种不同粒度的锁，包括S锁（Shared lock），X锁（Exclusive lock), IS锁(Intent Share lock), IX(Intent Exclusive lock)，这几种锁的互斥关系如下表所示：<img src="http://upload-images.jianshu.io/upload_images/3959253-537623996ad86ac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lockrelation.png"></p></li></ul><p>下面，我用一个例子来简单说明下。假设我要更改name为Jim的document<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_collection.<span class="keyword">update</span>(&#123;<span class="string">'name'</span>: <span class="string">'Jim'</span>&#125;, &#123;$set: &#123;<span class="string">'age'</span>: <span class="number">26</span>, <span class="string">'score'</span>: <span class="number">50</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>此时，如图1所示，MongoDB会为name为Jim的document加上X锁，同时为包含该document的Collection，Database和instance都加上IX锁，这时，针对该文档的操作就保证了原子性。需要注意的是：</p><ul><li>如果当<code>age</code>修改成功，而<code>score</code>没有修改成功时，MongoDB会自动回滚，因此我们可以说针对单个文档，MongoDB是支持事务，保证ACID的（严格来说，要想保证Durability，需要在写操作时使用特殊的write concern，这个后边再谈）</li><li>所有的锁都是平等的，它们是排在一个队列里，符合FIFO原则。但是，MongoDB做了优化，即当一个锁被采用时，所有与它兼容的锁（即上表为yes的锁）都会被采纳，从而可以并发操作。举个例子，当你针对Collection A中的Document a使用S锁时，其它reader可以同时使用S锁来读取该Document a，也可以同时读取同一个Collection的Document b.因为所有的S锁都是兼容的。那么，如果此时针对Collection A中的Document c进行写操作是否可以呢？显然需要为Document c赋予x锁，此时Collection A就需要IX锁，而由于IX和IS是兼容的，所以没有问题。简单来说，只要不是同一个Document，读写操作是可以并发的；如果是同一个Document，读可以并发，但写不可以。</li><li>WiredTiger针对global, db, collection level只能使用intent lock。另外，针对冲突的情况，WiredTiger会自动重试。</li></ul><h4>跨文档的事务支持</h4><p>前面已经说过，针对多文档，MongoDB是不支持事务的，但是我们的应用却可以自己去实现类事务的功能，这里只针对其中最常用的两步提交方式来做详细阐释。假设我们有两个账户A和B，现在我们要让账户A转账100元给账户B，我们需要将整个过程放在一个事务当中，来保证数据的一致性。在这个应用模拟的事务当中，需要涉及两个Collection，一个是accounts collection，另一个是transaction collection（用于存储交易的信息和状态）。先来看下transaction最终成功的大体流程：如图2所示<img src="http://upload-images.jianshu.io/upload_images/3959253-1f43175f98bf3140.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 success transaction">伪代码如下：</p><h4>initial accounts</h4><p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bulk_result = db.accounts.insert(</span><br><span class="line">   [</span><br><span class="line">     &#123; <span class="string">_id:</span> <span class="string">"A"</span>, <span class="string">balance:</span> <span class="number">1000</span>, <span class="string">pendingTransactions:</span> [] &#125;,</span><br><span class="line">     &#123; <span class="string">_id:</span> <span class="string">"B"</span>, <span class="string">balance:</span> <span class="number">1000</span>, <span class="string">pendingTransactions:</span> [] &#125;</span><br><span class="line">   ]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> bulk_result.nInserted != <span class="number">2</span>:</span><br><span class="line">   print <span class="string">"insert account failed."</span></span><br><span class="line">  <span class="keyword">return</span> False</span><br></pre></td></tr></table></figure></p><h4>add a transaction</h4><p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write_result = db.transactions.insert(</span><br><span class="line">    &#123; <span class="string">_id:</span> <span class="number">1</span>, <span class="string">source:</span> <span class="string">"A"</span>, <span class="string">destination:</span> <span class="string">"B"</span>, <span class="string">value:</span> <span class="number">100</span>, <span class="string">state:</span> <span class="string">"initial"</span>, <span class="string">lastModified:</span> <span class="keyword">new</span> Date() &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> write_result.nInserted != <span class="number">1</span>:</span><br><span class="line">  print <span class="string">"transaction failed"</span></span><br><span class="line">  <span class="keyword">return</span> False</span><br></pre></td></tr></table></figure></p><h4>update transaction to pending</h4><p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = db.transactions.findOne( &#123; <span class="keyword">state</span>: <span class="string">"initial"</span> &#125; )</span><br><span class="line">result = db.transactions.update(</span><br><span class="line">    &#123; _id: t._id, <span class="keyword">state</span>: <span class="string">"initial"</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">$set</span>: &#123; <span class="keyword">state</span>: <span class="string">"pending"</span> &#125;,</span><br><span class="line">      <span class="variable">$currentDate</span>: &#123; lastModified: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">if result.nModified != <span class="number">1</span>:</span><br><span class="line">  print <span class="string">"transaction failed"</span></span><br><span class="line">  return False</span><br></pre></td></tr></table></figure></p><h4>update accounts &amp; push transaction id</h4><p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result_source = <span class="keyword">db</span>.accounts.<span class="keyword">update</span>(</span><br><span class="line">   &#123; _id: t.source, pendingTransactions: &#123; <span class="variable">$ne</span>: t._id &#125; &#125;,</span><br><span class="line">   &#123; <span class="variable">$inc</span>: &#123; balance: -t.value &#125;, <span class="variable">$push</span>: &#123; pendingTransactions: t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line">result_destination = <span class="keyword">db</span>.accounts.<span class="keyword">update</span>(</span><br><span class="line">   &#123; _id: t.destination, pendingTransactions: &#123; <span class="variable">$ne</span>: t._id &#125; &#125;,</span><br><span class="line">   &#123; <span class="variable">$inc</span>: &#123; balance: t.value &#125;, <span class="variable">$push</span>: &#123; pendingTransactions: t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> result_source.nModified != 1 or result_destination.nModified != 1:</span><br><span class="line">   # 进入回滚的流程</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">return</span> False</span><br></pre></td></tr></table></figure></p><h4>update transaction to applied</h4><p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = db.transactions.update(</span><br><span class="line">   &#123; _id: t._id, <span class="keyword">state</span>: <span class="string">"pending"</span> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="variable">$set</span>: &#123; <span class="keyword">state</span>: <span class="string">"applied"</span> &#125;,</span><br><span class="line">     <span class="variable">$currentDate</span>: &#123; lastModified: true &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">if result.nModified != <span class="number">1</span>:</span><br><span class="line">  <span class="comment"># 重新update accounts &amp; push transaction id</span></span><br><span class="line">  <span class="comment"># 注意：如果上一步是成功的，pendingTransactions列表中会有相应的Transaction，那么就不会重复更新账户</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><h4>pull transaction id</h4><p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result_source = db.accounts.<span class="keyword">update</span>(</span><br><span class="line">   &#123; _id: t.<span class="keyword">source</span>, pendingTransaction<span class="variable">s:</span> t._id &#125;,</span><br><span class="line">   &#123; $pul<span class="variable">l:</span> &#123; pendingTransaction<span class="variable">s:</span> t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line">result_destination = db.accounts.<span class="keyword">update</span>(</span><br><span class="line">   &#123; _id: t.destination, pendingTransaction<span class="variable">s:</span> t._id &#125;,</span><br><span class="line">   &#123; $pul<span class="variable">l:</span> &#123; pendingTransaction<span class="variable">s:</span> t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> result_source.nModified != <span class="number">1</span> <span class="built_in">or</span> result_destination.nModified != <span class="number">1</span>:</span><br><span class="line">  # 重新执行pull transaction id</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><h4>update transaction to done</h4><p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = db.transactions.update(</span><br><span class="line">   &#123; _id: t._id, <span class="keyword">state</span>: <span class="string">"applied"</span> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="variable">$set</span>: &#123; <span class="keyword">state</span>: <span class="string">"done"</span> &#125;,</span><br><span class="line">     <span class="variable">$currentDate</span>: &#123; lastModified: true &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">if result.nModified != <span class="number">1</span>:</span><br><span class="line">  <span class="comment"># 重新从pull transaction id执行</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>包含回滚和失败的整体流程如图3：<img src="http://upload-images.jianshu.io/upload_images/3959253-f9054cb97e7a5e3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 whole transaction procedure">从上图可以看出，任何一步失败都有相应的应对措施来保证事务或者执行完毕或者回滚。当然所有的实现都需要应用程序自己实现，更何况如果涉及多个应用并发的情况时，会更加复杂，如何保证多个事务不互相影响，又会进一步增加复杂度，这也就是为什么如果需要此类跨文档事务支持的时候推荐使用关系数据库。</p><h2>MongoDB的一致性</h2><p>当我们说外部一致性时，是针对分布式系统所说的CAP理论中的一致性，简单来说就是如何使得多台机器的副本保持一致，实际上Mongodb只能做到最终一致性，总会有“不一致时间窗口”，这是由于Mongodb在更新操作的时候，需要将同样的更新复制到副本节点当中，而这段时间无法保证reader读到的一定是最新数据，即使ReadConcern设置为<em>majority</em>，也只能保证返回目前大多数节点的所持有的数据，而不一定是最新的数据（比如，只有primary节点更新完成，其它所有secondary节点都还没有更新完成）。当我们说内部一致性时，是针对ACID中的一致性，这里主要针对如何避免脏读，当Mongodb无法在大多数节点成功的更新操作时，会导致回滚操作，这时如果Reader已经读取了更改后的数据，就会产生脏读现象。而避免脏读，可以通过设置Read Concern和Write Concer来实现，关于Write Concern和Read Concern，请参考Reference中链接，已经讲的很详细了，不再赘述。当我们设置Read Concern为majority时，可以保证返回的数据是大多数节点所持有的数据，这种情况是不会发生回滚的，也就避免了脏读。还有一种情况可能出现脏读，就是当writer写数据时，虽然已经写入到了内存当中，但是并没有写入到磁盘中，这时reader读取到了更新后的数据，但当Mongodb将内存中的数据写入磁盘时可能会产生错误，从而导致磁盘写入失败，这时就可能导致该数据丢失，这种情况下也会产生脏读，而为了避免这种情况，我们需要在Write Concern设置的时候使用<code>j:1</code>，这样实际是在写入journal之后才返回写入成功，保证不会出现上述的脏读现象。当然这种情况下，性能势必会受到影响。所以还是要根据业务情况来决定，非关键业务不需要很强的一致性的情况下，也不需要此种设置。</p><h2>Reference</h2><ul><li><a href="http://www.csdn.net/article/2014-08-07/2821104-Implement-Robust-and-Scalable-Transactions-with-MongoDB" target="_blank" rel="noopener">五个解决方案让MongoDB拥有RDBMS的鲁棒性事务</a></li><li><a href="https://en.wikipedia.org/wiki/Multiple_granularity_locking" target="_blank" rel="noopener">Wiki: multiple granularity locking</a></li><li><a href="https://docs.mongodb.com/manual/faq/concurrency/#faq-concurrency-locking" target="_blank" rel="noopener">mongodb locking</a></li><li><a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" target="_blank" rel="noopener">MongoDB 2 phase commits</a></li><li><a href="http://www.ywnds.com/?p=3688" target="_blank" rel="noopener">MongoDW Write Concern机制</a></li><li><a href="http://vincentwang.top/2017/08/02/MongoDB-%E5%86%99%E5%AE%89%E5%85%A8-Write-Concern/" target="_blank" rel="noopener">MongoDB 写安全(Write Concern)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前一篇&lt;a href=&quot;http://localhost:4000/2018/01/08/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%8CACID%EF%BC%8CCAP%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《理解数据库的事务，ACID，CAP和一致性》&lt;/a&gt;我已经将数据库的一些基本概念包括事务，ACID，CAP，一致性，隔离性等都深入的介绍了一遍，而此篇主要是针对MongoDB数据库系统做一下深入的了解，主要希望弄清楚如下几个问题：&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解数据库的事务，ACID，CAP和一致性</title>
    <link href="http://yoursite.com/2018/01/08/db_acid_cap/"/>
    <id>http://yoursite.com/2018/01/08/db_acid_cap/</id>
    <published>2018-01-08T10:18:18.000Z</published>
    <updated>2018-10-06T05:29:01.895Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细阐述了数据库常用的一些概念如事务、ACID、CAP等</p><p><a id="more"></a></p><h2>什么是事务</h2><p>事务是指由一系列数据库操作组成的一个完整的逻辑过程，这个过程中的所有操作要么都成功，要么都不成功。比如：常见的例子就是银行转账的例子，一次转账操作会包含多个数据库操作，而这些数据库操作需要放到一个事务当中，保证其要么都成功，要么都不成功。</p><h2>什么是ACID</h2><p>ACID是事务的四个特性，指的是atomicity，原子性；consistency，一致性；isolation，隔离性；durability，持久性。</p><ol><li>原子性(atomicity): 指所有在事务中的操作要么都成功，要么都不成功，所有的操作都不可分割，没有中间状态。一旦某一步执行失败，就会全部回滚到初始状态。</li><li>一致性(consistency): 指的是逻辑上的一致性，即所有操作是符合现实当中的期望的。具体参考下一节</li><li>隔离性(isolation): 即不同事务之间的相互影响和隔离的程度。比如，不同的隔离级别，事务的并发程度也不同，最强的隔离状态是所有的事务都是串行化的（serializable）（即一个事务完成之后才能进行下一个事务），这样并发性也会降到最低，在保证了强一致性的情况下，性能也会受很大影响，所以在实际工程当中，往往会折中一下。</li><li>持久性(durability): 可以简单地理解为事务执行完毕后数据不可逆并持久化存储于存储系统当中</li></ol><h2>理解一致性</h2><p>实际上我们通常说的数据库事务的一致性和分布式系统的一致性并不是一个概念。这里可以区分成“内部一致性”和“外部一致性”。“内部一致性”搞数据库的人很少这么说，一般就直接说一致性，更准确的说是“Consistency in ACID”（“事务 ACID 属性中的一致性”）；“外部一致性”是针对分布式系统而言的，分布式领域提及的 Consistency 表示系统的正确性模型，著名的也是臭名昭著的 CAP 理论中的 C 就是这个范畴的。这主要是由于分布式系统写入和读取都可能不在同一台机器上，而这必然会有一段时间导致不同机器上所存的数据不一致的情况，这就是所谓的“不一致时间窗口”。</p><h4>内部一致性</h4><p>要理解内部一致性也就是我们通常所说的ACID中的一致性，就必须从反面考虑什么情况下是不一致的。不一致的情况主要有以下几种情况：<img src="http://upload-images.jianshu.io/upload_images/3959253-604e246793805ad0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丢失修改、不可重复读、脏读"></p><ul><li>修改丢失：丢失修改是事务A和B先后更改数据数据x（假设初始是x0)，但是在A未正式更改前，B已经读取了原先的数据x0，最后A更改后为x1，B更改的并不是A更新后的x1，而是更改的x0，更改后假设为x2，这时x2将x1覆盖了，相当于事务A针对x的更改丢失了。</li><li>脏读： 事务T1读取了T2更改的x，但是T2在实际存储数据时可能出错回滚了，这时T1读取的实际是无效的数据，这种情况下就是脏读</li><li>不可重复读：是说在T1读取x时，由于中间T2更改了x，所以T1前后两次读取的x值不相同，这就是所谓的不可重复读</li><li>幻读：在T1读取符合某个条件的所有记录时，T2增加了一条符合该条件的记录，这就导致T1执行过程中前后读取的记录可能不一致，即T2之后读取时会多出一条记录。</li></ul><p>其中前三种（丢失修改、不能重复读、脏读）都是由于并发事务在修改同一份数据的时候导致的问题，此类问题可以通过对同一个资源加锁的方式来解决，而最后一种情况是由于不同事务并发时，新增数据导致的问题，对于新增的记录是无法加锁的，此种情况只能通过事务的串行化来解决。而串行化与并发是矛盾的，所以要在性能和事务的一致性强度上取得一个平衡，就涉及到不同的隔离等级，关于隔离等级，详见<em>理解隔离性</em>一节。</p><h4>外部一致性</h4><p>在分布式系统中我们所说的一致性，也就是外部一致性，通常会分为强一致性，弱一致性，还有最终一致性，而要理解外部一致性，需要对CAP理论（Consistency，Availability和Partition Tolerance）有所了解，关于CAP详见<em>CAP定理</em>一节。</p><ul><li>强一致性：指系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值</li><li>弱一致性：弱一致性是相对于强一致性而言，它不保证总能得到最新的值；</li><li>最终一致性：是弱一致性的特殊形式，即保证在没有新的更新的条件下，经过一段“不一致时间窗口”，最终所有的访问都是最后更新的值。最常见的是DNS服务，更新域名指向的机器后，多级缓存要等到expiration time的时候才会更新，但是随着时间的推移，最终数据会趋于一致。</li></ul><h2>理解隔离性</h2><p>事务的隔离级别从低到高有读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</p><ul><li>Read Uncommitted：事务读数据时不会加锁，写数据时会有行级共享锁。假设事务1先于事务2，当事务1更新数据的时候，事务2可以读取事务1未提交的数据，但是不能更新事务1正在更新的数据。而如果事务1只是读数据，那么事务2既可以读数据，也可以更新数据。这种情况下无法规避脏读，不可重复读的问题。</li><li>Read Committed：即在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据，或者说只能读取committed的数据。事务读数据的瞬间会加行级共享锁，一旦读完该行，立即释放该行级共享锁；而写数据的瞬间会加行级排它锁，直到事务结束。这种情况下就避免了脏读，但是却不能避免不可重复读的问题</li><li>Repeatable Read：当然就再升一级，为的就是避免不可重复读的问题，所以名字叫repeatable read。怎么实现的呢，我们知道read committed是，事务读操作只在读的一瞬间加锁，读完这行就释放锁了，而repeatable read级别是读的一瞬间加锁，但是一直到事务结束才释放锁。但是repeatable read不能解决幻读的问题，因为幻读是增加记录，并不是更改原先的记录。</li><li>Serialization：到达这一级别的隔离，可以彻底解决一致性的所有问题。一般来说是通过加表锁来解决串行化的问题。</li></ul><h2>CAP定理</h2><p>CAP理论主要是针对分布式存储系统的，C是指Consistency一致性，A是指Availability可用性，P是指Partition tolerance分区容忍性。CAP定理认为分布式系统中这三个特性最多只能同时满足两个特性。下面我们来分别看下这三个特性究竟是什么意思。<img src="http://upload-images.jianshu.io/upload_images/3959253-184c37c7dc01d4d5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAP"></p><ul><li>一致性(Consistency): 指在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性(Availability): 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性(Partition tolerance): 即当节点之间无法正常通信时，就产生了分区，而分区产生后，依然能够保证服务可用，那么我们就说系统是分区容忍的。显然如果节点越多，且备份越多，分区容忍度就越高（因为即便是其中一个或多个节点挂了，仍然有其它节点和备份可用）。</li></ul><p>那么，为什么说三个特性无法全部保证呢？首先，假如我们要保证分区容忍性，必然要做多个副本节点，而这必然会带来一致性的问题，即保证多个节点的数据是相同的，但是，要让多个节点数据相同，就必须要花时间去复制数据，这还是能够正常通信的情况下，那么在数据复制的过程中为了保持一致性，就不能对外提供服务，所以这段时间就无法满足可用性的问题。实际工程通常会采取一些折中措施，比如并不保证强一致性，只保证最终一致性，什么意思呢？比如，有三个数据节点互为备份，某份数据在节点A更改后，需要将更改复制到节点B和C，假设复制过程中，有客户访问该数据，那么此时不保证是一致的，即访问A节点的用户得到的是最新数据，而访问B和C节点的用户得到是老数据，但是最终，数据会复制完成，所以最终A、B、C三个节点的数据是一致的。（比如像文章点赞这种数据，延迟下也没有关系啦）</p><h2>Reference</h2><ul><li><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="noopener">深入分析事务的隔离级别</a></li><li><a href="https://www.zhihu.com/question/56073588/answer/253106572" target="_blank" rel="noopener">如何理解数据库的内部一致性和外部一致性？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细阐述了数据库常用的一些概念如事务、ACID、CAP等&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
      <category term="acid" scheme="http://yoursite.com/tags/acid/"/>
    
  </entry>
  
  <entry>
    <title>Flask-Login详解</title>
    <link href="http://yoursite.com/2017/10/12/Flask-Login/"/>
    <id>http://yoursite.com/2017/10/12/Flask-Login/</id>
    <published>2017-10-12T10:18:18.000Z</published>
    <updated>2018-10-06T05:33:02.243Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要通过源码分析Flask-Login插件，并详述其使用方法</p><p><a id="more"></a></p><p>关于Flask登录认证的详细过程请参见拙作<a href="http://geekpy.github.io/2016/12/06/flask_login_detail/" target="_blank" rel="noopener">&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;</a>一文，而本文则偏重于详细介绍Flask-Login的原理，代码的解析。</p><h3>首次登陆</h3><p>我们首先来看一下首次登录验证的流程图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-b34989af4a0d0b2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首次登陆"></p><p>Flask-Login在登录过程中主要负责：</p><ul><li>将用户对象存入request context中</li><li>将用户ID，Session ID等信息存入Session中在<a href="http://www.jianshu.com/p/06bd93e21945" target="_blank" rel="noopener">&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;</a>中我们已经介绍过如何通过Flask-Login来实现登录的过程，其中最重要的代码就是login_user，如下：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">login_user</span><span class="params">(user, remember=remember_me)</span></span></span><br></pre></td></tr></table></figure></li></ul><p>那么login_user具体做了什么呢？我们来看下源码<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def login_user(user, remember=<span class="literal">False</span>, force=<span class="literal">False</span>, fresh=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">not</span> force <span class="built_in">and</span> <span class="built_in">not</span> user.is_active:</span><br><span class="line">        return <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    user_id = getattr(user, current_app.login_manager.id_attribute)()</span><br><span class="line">    session[<span class="string">'user_id'</span>] = user_id</span><br><span class="line">    session[<span class="string">'_fresh'</span>] = fresh</span><br><span class="line">    session[<span class="string">'_id'</span>] = current_app.login_manager.<span class="variable">_session_identifier_generator</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> remember:</span><br><span class="line">        session[<span class="string">'remember'</span>] = <span class="string">'set'</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">_request_ctx_stack</span>.top.user = user</span><br><span class="line">    user_logged_in.send(current_app.<span class="variable">_get_current_object</span>(), user=<span class="variable">_get_user</span>())</span><br><span class="line">    return <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><ul><li><code>getattr(user, current_app.login_manager.id_attribute)()</code> 这里<code>login_manager.id_attribute</code>是一个字符串<code>'get_id'</code>。因此这句的意思是获取User对象的get_id method，然后执行，从而获取到用户的ID</li><li>通过<code>session['user_id'] = user_id</code>来将用户的ID存储进Session当中，后面紧跟着将fresh信息，session id信息，remember信息存储进session。</li></ul><blockquote><p>注意：Flask的session是以cookie为基础，但是是在Server端使用secret key并使用AES之类的对称加密算法进行加密的，然后将加密后的cookie发送给客户端。由于是加密后的数据，客户端无法篡改数据，也无法获知session中的信息，只能保存该session信息，在之后的请求中携带该session信息</p></blockquote><ul><li><code>_request_ctx_stack.top.user = user</code>这里是将user对象存储进当前的request context中，_request_ctx_stack是一个LocalStack对象，top属性指向的就是当前的request context。关于LocalStack及相关技术，请参考拙作<a href="http://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt;</a></li><li><code>user_logged_in.send(current_app._get_current_object(), user=_get_user())</code> 此句中<code>user_logged_in</code>是Flask-Login定义的signal，此处通过send来发射此signal，当注册监听此signal的回调函数收到此signal之后就会执行函数。这里send有两个参数，第一个参数是sender对象，此处通过<code>current_app._get_current_object()</code>来获取当前的app对象，即此signal的sender设为当前的应用；第二个参数是该signal携带的数据，此处将user对象做为signal的数据传递给相应的回调函数。关于signal的详细解释请参考拙作<a href="http://www.jianshu.com/p/756ed0267f53" target="_blank" rel="noopener">&lt;&lt;Flask Signals详解&gt;&gt;</a></li></ul><h3>非首次登陆</h3><p>非首次登陆流程图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-7ea20e139da6e2ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非首次登陆"></p><p>在这个流程图中，Flask-Login主要起如下作用：</p><ol><li>从session中获取用户ID</li><li>当用户的请求访问的是受登录保护的路由时，就要通过用户ID重新load user，如果load user失败则进入鉴权失败处理流程，如果成功，则允许正常处理请求那么Flask-Login究竟是如何保护路由的呢？我们来看个例子：<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@app</span>.route(<span class="string">'/'</span>)</span><br><span class="line"><span class="variable">@app</span>.route(<span class="string">'/main'</span>)</span><br><span class="line"><span class="variable">@login_required</span></span><br><span class="line">def main():</span><br><span class="line">    return render_template(</span><br><span class="line">        <span class="string">'main.html'</span>, username=current_user.username)</span><br></pre></td></tr></table></figure></li></ol><p>我们看到只要给路由函数加一个<code>@login_required</code>装饰器就可以了，那么这个装饰器究竟是怎么做到的呢？来看下源码：<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># flask_login/utils.py</span></span><br><span class="line">def login_required(<span class="function"><span class="keyword">func</span>):</span></span><br><span class="line">    <span class="symbol">@wraps</span>(<span class="function"><span class="keyword">func</span>)</span></span><br><span class="line">    def decorated_view(*args, **kwargs):</span><br><span class="line">        <span class="meta"># 如果request method为例外method，即在EXEMPT_METHODS中的method，可以不必鉴权</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> EXEMPT_METHODS:</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(*args, **kwargs)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta"># 如果_login_disabled为True则不必鉴权</span></span><br><span class="line">        elif current_app.login_manager._login_disabled:</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(*args, **kwargs)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta"># 正常鉴权</span></span><br><span class="line">        elif <span class="literal">not</span> current_user.is_authenticated:</span><br><span class="line">            <span class="keyword">return</span> current_app.login_manager.unauthorized()</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(*args, **kwargs)</span></span></span><br><span class="line">    <span class="keyword">return</span> decorated_view</span><br></pre></td></tr></table></figure></p><ul><li>默认情况下只有<em>OPTIONS</em> method在EXEMPT_METHODS set中，而GET、PUT、POST等常见的methods都需要鉴权</li><li><code>_login_disabled</code>默认为False</li><li>正常鉴权的关键在于<code>current_user.is_authenticated</code>是否为True，为True则正常处理请求，为False则进入unauthorized处理流程。那么这个current_user到底怎么就能鉴权了？它是怎么来的呢？来看下定义：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># flask_login/utils.py</span></span><br><span class="line"><span class="attr">current_user</span> = LocalProxy(lambda: _get_user())</span><br></pre></td></tr></table></figure></li></ul><p>原来current_user是一个LocalProxy对象，其代理的对象需要通过<code>_get_user()</code>来获取，简单来说_get_user()会返回两种用户，一种是正常的用户对象(鉴权成功)，一种是anonymous用户对象(鉴权失败)。而正常的用户对象其<code>is_authenticated</code>属性总是为True，相对的anonymous用户对象的<code>is_authenticated</code>属性总是为False</p><blockquote><p>LocalProxy对象每次操作都会重新获取代理的对象从而实现动态更新，关于LocalProxy的详细说明请参考拙作<a href="http://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt;</a></p></blockquote><p>而要实现动态更新的关键就在于<code>_get_user</code>函数，接下来我们看下<code>_get_user</code>函数是如何获取user对象的：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># flask_login/utils.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> has_request_context() <span class="keyword">and</span> <span class="keyword">not</span> hasattr(_request_ctx_stack.top, <span class="string">'user'</span>):</span><br><span class="line">        current_app.login_manager._load_user()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getattr(_request_ctx_stack.top, <span class="string">'user'</span>, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>在之前的首次登陆那小节中，我们已经知道用户鉴权成功后，会将User对象保存在当前的request context当中，这时我们调用<code>_get_user</code>函数时就会直接从request context中获取user对象<code>return getattr(_request_ctx_stack.top, 'user', None)</code>但如果是非首次登陆，当前request context中并没有保存user对象，就需要调用<code>current_app.login_manager._load_user()</code>来去load user对象，接下来再看看如何去load：<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># flask_login/login_manager.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_load_user</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">''</span><span class="string">'Loads user from session or remember_me cookie as applicable'</span><span class="string">''</span></span><br><span class="line">        user_accessed.send(current_app._get_current_object())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># first check SESSION_PROTECTION</span></span><br><span class="line">        config = current_app.config</span><br><span class="line">        <span class="keyword">if</span> config.get(<span class="string">'SESSION_PROTECTION'</span>, <span class="keyword">self</span>.session_protection)<span class="symbol">:</span></span><br><span class="line">            deleted = <span class="keyword">self</span>._session_protection()</span><br><span class="line">            <span class="keyword">if</span> <span class="symbol">deleted:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.reload_user()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If a remember cookie is set, and the session is not, move the</span></span><br><span class="line">        <span class="comment"># cookie user ID to the session.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># However, the session may have been set if the user has been</span></span><br><span class="line">        <span class="comment"># logged out on this request, 'remember' would be set to clear,</span></span><br><span class="line">        <span class="comment"># so we should check for that and not restore the session.</span></span><br><span class="line">        is_missing_user_id = <span class="string">'user_id'</span> <span class="keyword">not</span> <span class="keyword">in</span> session</span><br><span class="line">        <span class="keyword">if</span> <span class="symbol">is_missing_user_id:</span></span><br><span class="line">            cookie_name = config.get(<span class="string">'REMEMBER_COOKIE_NAME'</span>, COOKIE_NAME)</span><br><span class="line">            header_name = config.get(<span class="string">'AUTH_HEADER_NAME'</span>, AUTH_HEADER_NAME)</span><br><span class="line">            has_cookie = (cookie_name <span class="keyword">in</span> request.cookies <span class="keyword">and</span></span><br><span class="line">                          session.get(<span class="string">'remember'</span>) != <span class="string">'clear'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="symbol">has_cookie:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>._load_from_cookie(request.cookies[cookie_name])</span><br><span class="line">            elif <span class="keyword">self</span>.<span class="symbol">request_callback:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>._load_from_request(request)</span><br><span class="line">            elif header_name <span class="keyword">in</span> request.<span class="symbol">headers:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>._load_from_header(request.headers[header_name])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.reload_user()</span><br></pre></td></tr></table></figure></p><ul><li><code>_load_user</code>大体的过程是首先检查<em>SESSION_PROTECTION</em>设置，如果<em>SESSION_PROTECTION</em> 为strong或者basic类型，那么就会执行<code>_session_protection()</code>动作，否则不执行此操作。<code>_session_protection</code>在session_id不一致的时候(比如IP变化会导致session id的变化)才真正有用，这时，如果为basic类型或者session permanent为True时，只标注session为非新鲜的(not fresh)；而如果为strong，则会删除session中的用户信息，并重新load user，即调用<code>reload_user</code>。</li></ul><blockquote><p>session permanent为True时，用户退出浏览器不会删除session，其会保留permanent_session_lifetime s(默认是31天)，但是当其为False且<em>SESSION_PROTECTION</em> 设为strong时，用户的session就会被删除。</p></blockquote><ul><li>接下来的代码是说当session中没有用户信息时(这里通过是否能获取到<code>user_id</code>来判断)，如果有则直接<code>reload_user</code>,如果没有，则有三种方式来load user，一种是通过remember cookie，一种通过request，一种是通过request header，依次尝试。</li></ul><blockquote><p>remember cookie是指，当用户勾选'remember me'复选框时，Flask-Login会将用户信息放入到指定的cookie当中，同样也是加密的。这就是为什么当session中没有携带用户信息时，我们可以通过remember cookie来获取用户的信息</p></blockquote><p>而<code>reload_user</code>是如何获取用户的呢，来看下源代码：<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># flask_login/login_manager.py</span></span><br><span class="line">def reload_user(self, <span class="attr">user=</span>None):</span><br><span class="line">        ctx = _request_ctx_stack.top</span><br><span class="line"></span><br><span class="line">        if <span class="keyword">user</span> <span class="title">is</span> None:</span><br><span class="line">            user_id = session.get('user_id')</span><br><span class="line">            if user_id is None:</span><br><span class="line">                <span class="comment"># 当无法获取到有效的用户id时，就认为是anonymous user</span></span><br><span class="line">                ctx.<span class="keyword">user</span> <span class="title">= self</span>.anonymous_user()</span><br><span class="line">            else:</span><br><span class="line">                <span class="comment"># user callback就是我们通过@login_manager.user_loader装饰的函数，用于获取user object</span></span><br><span class="line">                if self.user_callback is None:</span><br><span class="line">                    raise Exception(</span><br><span class="line">                        <span class="string">"No user_loader has been installed for this "</span></span><br><span class="line">                        <span class="string">"LoginManager. Add one with the "</span></span><br><span class="line">                        <span class="string">"'LoginManager.user_loader' decorator."</span>)</span><br><span class="line">                <span class="keyword">user</span> <span class="title">= self</span>.user_callback(user_id)</span><br><span class="line">                if <span class="keyword">user</span> <span class="title">is</span> None:</span><br><span class="line">                    ctx.<span class="keyword">user</span> <span class="title">= self</span>.anonymous_user()</span><br><span class="line">                else:</span><br><span class="line">                    ctx.<span class="keyword">user</span> <span class="title">= user</span></span><br><span class="line">        else:</span><br><span class="line">            ctx.<span class="keyword">user</span> <span class="title">= user</span></span><br></pre></td></tr></table></figure></p><ul><li>首先获取user id，如果获取不到有效的id，就将user设为anonymous user</li><li>获取到id后，再通过@login_manager.user_loader装饰的函数获取到user对象，如果没有获取到有效的user对象，就认为是anonymous user</li><li>最后将user保存于request context中（无论是正常的用户还是anonymous用户）</li></ul><p>至此，我们已经将Flask-Login的核心代码剖析了一遍，如果你有收获，不妨点个赞鼓励一下吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要通过源码分析Flask-Login插件，并详述其使用方法&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
  </entry>
  
</feed>
