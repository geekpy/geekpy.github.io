<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geekpy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-01T12:26:44.937Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>geekpy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>史上最详解Python日期和时间处理（下）</title>
    <link href="http://yoursite.com/2018/08/25/python_time2/"/>
    <id>http://yoursite.com/2018/08/25/python_time2/</id>
    <published>2018-08-25T03:52:56.000Z</published>
    <updated>2018-09-01T12:26:44.937Z</updated>
    
    <content type="html"><![CDATA[<p>此下篇主要讲解跟时区相关的概念和程序中经常使用的场景，希望通过此文大家可以搞定所有时区相关的编程问题（如果还有不明白的地方，请联系我，我将进一步补充）。</p><p>本文的目录结构如下：</p><ul><li><a href="#%E6%97%B6%E5%8C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">时区基本概念</a><ul><li><a href="#%E6%97%B6%E5%8C%BA">时区</a></li><li><a href="#GMT%E5%92%8CUTC">GMT和UTC</a></li><li><a href="#%E6%97%B6%E5%8C%BA%E5%81%8F%E7%A7%BB">时区偏移(Offset)</a></li><li><a href="#%E5%A4%8F%E4%BB%A4%E6%97%B6">夏令时(DST)</a></li><li><a href="#%E6%A8%A1%E7%B3%8A%E6%97%B6%E9%97%B4">模糊时间(Ambiguous Time)</a></li></ul></li><li><a href="#%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA">设置时区</a><ul><li><a href="#tzinfo">tzinfo</a></li><li><a href="#dateutil">dateutil</a></li><li><a href="#pytz">pytz</a></li></ul></li><li><a href="#%E6%97%B6%E5%8C%BA%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">时区处理的最佳实践</a></li></ul><h2>时区基本概念</h2><h4>时区</h4><p>由于地球自转导致不同地区的人看到太阳升起和落下的时间不同，于是人们就定义了时区的概念，将全球分为24个时区，其中位于英国的本初子午线作为零时区中线，然后向东划分出十二个时区（分别为+1， +2....+12)，向西也划分成十二个时区(分别为-1, -2 .....-12)。其中最早进入新的一天的是+12时区，当+12时区为中午12点时，正好零时区进入第二天（它们相差12小时，所以+12）</p><h4>GMT和UTC</h4><p>GMT(Greenwich Mean Time)，即格林尼治标准时间，也就是本初子午线所在的时区。UTC(Universal Time Coordinated)，即标准世界时间。GMT和UTC虽然表示的时间相同，但是两个是不同的概念，大家注意区分，实践过程中，我们通常使用UTC时间作为标准时间。</p><h4>时区偏移Offset</h4><p>时区偏移(Offset)是指所处时区时间相对于UTC时间的偏移量，比如中国的CST时间其偏移量就是+8，即相对于UTC时间需要+8小时。有些程序会使用秒或者分钟来替代小时，所以使用的偏移量计算时间的时候需要注意具体使用的时间单位。具体可以参考<a href="https://en.wikipedia.org/wiki/UTC_offset" target="_blank" rel="noopener">wiki时区偏移</a></p><h4>夏令时(DST)</h4><p>关于夏令时我觉得<a href="https://blog.jijiechen.com/post/time-zone-and-dst-basics/#%E5%A4%8F%E4%BB%A4%E6%97%B6-dst" target="_blank" rel="noopener">这篇文章</a>已经讲解比较详细了, 大家可以直接参考，在此不再赘述。但是夏令时进一步增加了复杂度，这意味着即使同一个时区，一年中也会随着夏令时和非夏令时而导致offset的变化。</p><h4>模糊时间(Ambiguous Time)</h4><p>指的是在夏令时转换过程中的一段时间，在夏令时转换时，会有两个正确的时间，那么到底应该如何显示呢，所以要让程序知道到底选择哪个时间，就必须要有一个参数来确定这件事情。关于模糊时间的操作，Python2和Python3是不同的，具体可以参考Paul Ganssle的这篇文章<a href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html" title="Permalink to pytz: The Fastest Footgun in the West" target="_blank" rel="noopener">pytz: The Fastest Footgun in the West</a></p><h2>设置时区</h2><h4>tzinfo</h4><p>在《上篇》中我们已经说过Python用于表示时间的对象会分为原始的(naive)和有知的(aware)两种，而要表示有知的时间，就必须给相应的对象传递tzinfo参数。tzinfo参数主要用在datetime.datetime对象和datetime.time对象，其类初始化函数定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># datetime.datetime</span><br><span class="line">class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])</span><br><span class="line"></span><br><span class="line"># datetime.time</span><br><span class="line">class datetime.time([hour[, minute[, second[, microsecond[, tzinfo]]]]])</span><br></pre></td></tr></table></figure></p><p>可以看到初始化datetime和time对象时，都有一个tzinfo参数，当我们传递一个tzinfo对象给这个参数的时候我们就可以初始化一个有知的时间对象。</p><p>那么这个tzinfo对象到底是怎么来的呢？先来看下Python官网的定义：</p><blockquote><p>This is an abstract base class, meaning that this class should not be instantiated directly. You need to derive a concrete subclass, and (at least) supply implementations of the standard <a href="https://docs.python.org/2/library/datetime.html#datetime.tzinfo" title="datetime.tzinfo" target="_blank" rel="noopener"><code>tzinfo</code></a> methods needed by the <a href="https://docs.python.org/2/library/datetime.html#datetime.datetime" title="datetime.datetime" target="_blank" rel="noopener"><code>datetime</code></a> methods you use. The <a href="https://docs.python.org/2/library/datetime.html#module-datetime" title="datetime: Basic date and time types." target="_blank" rel="noopener"><code>datetime</code></a> module does not supply any concrete subclasses of <a href="https://docs.python.org/2/library/datetime.html#datetime.tzinfo" title="datetime.tzinfo" target="_blank" rel="noopener"><code>tzinfo</code></a>.</p></blockquote><p>从这段定义我们可以看出，tzinfo只是一个抽象类，而且官网已经明确说了不提供相应的实现，那我们怎么做呢？有两种做法：一是自己实现，Python官网还给出了示例代码，参考<a href="https://docs.python.org/2/library/datetime.html#tzinfo-objects" target="_blank" rel="noopener">这里</a>；另一种就是使用我们下边要讲到的dateutil模块。</p><h4>dateutil</h4><ul><li><p>安装dateutil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-dateutil</span><br></pre></td></tr></table></figure></p></li><li><p>简介官网对dateutil的介绍就一句话</p></li></ul><blockquote><p>The dateutil module provides powerful extensions to the standard datetime module, available in Python.</p></blockquote><p>看到了吧，专门为拓展datetime而开发的，其中我们感兴趣的主要是如何构造时区tzinfo。</p><ul><li>常见的使用场景：</li></ul><h5>1.转换为相应时区的时间</h5><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dateutil.tz <span class="keyword">as</span> tz</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">my_tz = tz.gettz(<span class="string">'Asia/Shanghai'</span>)</span><br><span class="line">d = datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">20</span>, tzinfo=my_tz)</span><br><span class="line"><span class="comment"># datetime.datetime(2018, 8, 20, 0, 0, tzinfo=tzfile('/usr/share/zoneinfo/Asia/Shanghai'))</span></span><br></pre></td></tr></table></figure></p><p>也就是说通过<code>tz.gettz()</code>我们可以得到一个tzinfo对象从而可以将其作为参数传递给datetime初始化函数。通过这种方式，我们就可以表示一个本地时间了，比如我们获取了当前时间后想要表示成NewYork时间（换句话说就是要表示不同地方的当前时间），该怎么处理呢？先看正确的做法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NYC = tz.gettz(&apos;America/New_York&apos;)</span><br><span class="line"></span><br><span class="line">now_utc = datetime.now(tz.tzutc())</span><br><span class="line"># datetime.datetime(2018, 8, 25, 8, 15, 53, 143709, tzinfo=tzutc())</span><br><span class="line"></span><br><span class="line">now_utc.astimezone(NYC)</span><br><span class="line"># datetime.datetime(2018, 8, 25, 4, 15, 53, 143709, tzinfo=tzfile(&apos;/usr/share/zoneinfo/America/New_York&apos;))</span><br></pre></td></tr></table></figure></p><p>错误的做法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now = datetime.utcnow()</span><br><span class="line"># datetime.datetime(2018, 8, 25, 8, 17, 21, 161843)</span><br><span class="line">now.astimezone(NYC)  </span><br><span class="line"># datetime.datetime(2018, 8, 24, 20, 17, 21, 161843, tzinfo=tzfile(&apos;/usr/share/zoneinfo/America/New_York&apos;))</span><br></pre></td></tr></table></figure></p><p>为什么会出现这种情况呢，因为单纯的使用的utcnow()得到是一个原始naive time对象，而根据时区转换时，该时间会先从本地时区(+8 Shanghai)转换成UTC时区时间，然后再转化为NewYork时间，因此导致最终多减了8小时。</p><p>另外，有的时候我们获取到的是offset信息而不是时区信息，那么我们也可以将UTC时间转换成对应的当地时间，如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过tzoffset也可以构筑tzinfo对象</span><br><span class="line">now_utc.astimezone(tz.tzoffset(&apos;NewYork&apos;, -14400))</span><br><span class="line"># datetime.datetime(2018, 8, 25, 4, 15, 53, 143709, tzinfo=tzoffset(&apos;NewYork&apos;, -14400))</span><br></pre></td></tr></table></figure></p><h5>2.获取当前的时区信息，并可以做相应转换</h5><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.tz <span class="keyword">import</span> tzlocal</span><br><span class="line"></span><br><span class="line">tz_local = tzlocal()</span><br><span class="line">type(tz_local)</span><br><span class="line"><span class="comment">#  dateutil.tz.tz.tzlocal</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, tzinfo=tz_local)</span><br><span class="line"><span class="comment"># datetime.datetime(2018, 8, 20, 9, 10, 5, tzinfo=tzlocal())</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.astimezone(tz.UTC)</span><br><span class="line"><span class="comment">#  datetime.datetime(2018, 8, 20, 1, 10, 5, tzinfo=tzutc())</span></span><br></pre></td></tr></table></figure></p><h4>pytz</h4><p>在时间处理的时候，我们还经常能看到pytz这个库，这个库比较有意思的是，<strong>它与datetime的tzinfo并不完全兼容</strong>，很多时候它是独立的一套处理时间的库。我们来看下如下代码(代码来自Paul Ganssle的文章，Paul是dateutil的核心开发者)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pytz</span><br><span class="line">from datetime import datetime, timedelta</span><br><span class="line"></span><br><span class="line">NYC = pytz.timezone(&apos;America/New_York&apos;)</span><br><span class="line"># 将timezone直接传入datetime初始化函数</span><br><span class="line">dt = datetime(2018, 2, 14, 12, tzinfo=NYC)</span><br><span class="line">print(dt)</span><br><span class="line"># 2018-02-14 12:00:00-04:56</span><br></pre></td></tr></table></figure></p><p>可以看到实际的offset成了-04:56，这就不对了，正确使用pytz的姿势如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要使用localize方法来转化datetime对象</span><br><span class="line">dt = NYC.localize(datetime(2018, 2, 14, 12))</span><br><span class="line">print(dt)</span><br><span class="line"># 2018-02-14 12:00:00-05:00</span><br></pre></td></tr></table></figure></p><p>再进行一些操作，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from datetime import timedelta</span><br><span class="line"></span><br><span class="line">dt_spring = dt + timedelta(days=60)</span><br><span class="line">print(dt_spring)</span><br><span class="line"># 2018-04-15 12:00:00-05:00</span><br></pre></td></tr></table></figure></p><p>注意，这里的offset是-5:00，而考虑到夏令时，应当是-4:00，这是由于pytz在之前localize的时候就已经将offset设定好了，其在做其它运算之后也无法改变其offset，所以导致无法针对夏令时调整offset，所以针对pytz，每一次做类似timedelta的运算之后，都需要使用normalize函数进行调整，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(NYC.normalize(dt_spring))</span><br><span class="line"># 2018-04-15 13:00:00-04:00</span><br></pre></td></tr></table></figure></p><p>在项目实践除非对性能有极端要求，并不推荐使用pytz，毕竟不是每个人都熟悉这个库，项目协作过程中很难避免误用。关于pytz和dateutil的性能比较，可以参考Paul Ganssle的这篇文章<a href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html" title="Permalink to pytz: The Fastest Footgun in the West" target="_blank" rel="noopener">pytz: The Fastest Footgun in the West</a></p><h2>时区处理的最佳实践</h2><h4>所有中间步骤均使用UTC时间或者时间戳</h4><p>所有中间的存储或者计算均应当使用UTC时间或者Timestamp，只有在最终显示的时候如果需要转换成本地时间，那么再将时间转换为特定时区的时间进行显示。</p><h4>存储timezone信息，而不是offset</h4><p>如果需要针对用户本地时区做时间转换，需要存储timezone的信息，如timezone名称，而不是offset。这是由于有些地区可能有夏令时，offset会改变，所以最好是存时区名称之类的信息，这样通过tzinfo会自动进行调整。</p><h2>Reference</h2><ul><li><a href="https://docs.python.org/2/library/time.html" target="_blank" rel="noopener">time module document</a></li><li><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="noopener">datetime module document</a></li><li><a href="http://pytz.sourceforge.net/#introduction" target="_blank" rel="noopener">pytz</a></li><li><a href="https://dateutil.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">dateutil</a></li><li><a href="https://medium.com/@eleroy/10-things-you-need-to-know-about-date-and-time-in-python-with-datetime-pytz-dateutil-timedelta-309bfbafb3f7" target="_blank" rel="noopener">10 things you need to know about Date and Time in Python</a></li><li><a href="https://blog.jijiechen.com/post/time-zone-and-dst-basics/" target="_blank" rel="noopener">时区和夏令时相关的基本知识</a></li><li><a href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html" title="Permalink to pytz: The Fastest Footgun in the West" target="_blank" rel="noopener">pytz: The Fastest Footgun in the West</a></li><li><a href="https://stackoverflow.com/questions/13218506/how-to-get-system-timezone-setting-and-pass-it-to-pytz-timezone/17365806" target="_blank" rel="noopener">StackOverflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此下篇主要讲解跟时区相关的概念和程序中经常使用的场景，希望通过此文大家可以搞定所有时区相关的编程问题（如果还有不明白的地方，请联系我，我将进一步补充）。&lt;/p&gt;
&lt;p&gt;本文的目录结构如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%B6%E5%8C%BA%
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>史上最详解Python日期和时间处理（上）</title>
    <link href="http://yoursite.com/2018/08/12/python_time/"/>
    <id>http://yoursite.com/2018/08/12/python_time/</id>
    <published>2018-08-12T03:52:56.000Z</published>
    <updated>2018-08-12T10:02:05.327Z</updated>
    
    <content type="html"><![CDATA[<p>好吧，我承认这有标题党的嫌疑，不过看了那么多文章，的确没有找到一篇让我满意的关于日期和时间处理的详解文章，于是决心自己动手亲写一篇，希望能对得起这个霸气的标题。言归正传，在Python编程中，日期和时间处理是非常繁琐的一块，不仅概念众多，且有很多不同的module, 尤其涉及时区处理的时候会将问题进一步复杂化。本文将对Python在日期和时间处理上进行一步步详细讲解，总共会分为上下两篇，其中时区处理是较为棘手的一块内容，单独拿出来作为下篇。此上篇将主要讲解时间和日期处理中的基本概念，和常用的场景。</p><p>&lt;!--more--&gt;</p><p>本篇目录如下：</p><ul><li><a href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9A%84%E8%A1%A8%E7%A4%BA">时间和日期的表示</a><ul><li><a href="#%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1">时间、日期对象</a></li><li><a href="#%E6%97%B6%E9%97%B4%E6%88%B3">时间戳</a></li><li><a href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2">日期时间字符串</a></li></ul></li><li><a href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF">日期时间处理场景</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4">获取当前时间</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4">获取特定时间</a></li><li><a href="#%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E8%A1%A8%E7%A4%BA%E7%9A%84%E8%BD%AC%E5%8C%96">不同时间表示的转化</a></li></ul></li></ul><h2>时间和日期的表示</h2><p>在Python中表示日期和时间，最基本的有三种形式：</p><ul><li>时间、日期对象(Object)</li><li>时间戳(Timestamp)</li><li>字符串(String)</li></ul><p>在这三种基本形式中又会衍生出一些其它的概念，下面来分别讲解下：</p><p>先看张脑图来理清它们之间的关系<img src="https://upload-images.jianshu.io/upload_images/3959253-06d2eac8083f8c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.1-python日期与时间的表示"></p><h4>时间、日期对象</h4><p>Python中用于表示日期和时间的对象有很多种，在详细讲解这些对象之前先要明确一个概念，<strong>即这些对象都分为两种：一种是&quot;原始的(naive)&quot;，另一种是&quot;有知的(aware)&quot;</strong>。区别在于原始的时间没有时区概念，只是单纯的表示一个日期和时间，而有知的时间会包含一些额外信息，如时区，是否夏令时等信息，而这些信息会通过tzinfo子类来进行封装，我们将在（下）中详细讲解。</p><ul><li><p>datetime对象：这个是最常用的日期时间对象，可以即表示日期又表示时间。datetime对象可以直接用于日期和时间相关的计算（比如计算5天之前的时间）。另外，datetime既可以表示原始时间，也可以表示有知时间，如果要表示有知时间，则在初始化时需要传递tzinfo类型的参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [16]: import datetime</span><br><span class="line"></span><br><span class="line">In [17]: datetime.datetime.now() # 返回一个datetime对象</span><br><span class="line">Out[17]: datetime.datetime(2018, 7, 28, 11, 17, 38, 972555)</span><br><span class="line"></span><br><span class="line"># 也可以直接初始化一个datetime对象</span><br><span class="line">In [20]: datetime.datetime(2018, 7, 5, 10, 20)</span><br><span class="line">Out[20]: datetime.datetime(2018, 7, 5, 10, 20)</span><br></pre></td></tr></table></figure></p></li><li><p>time对象：与datetime类似，但只用于表示时间，不表示日期<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里初始化一个datetime.time对象用于表示时间11点28分05秒</span><br><span class="line">In [19]: datetime.time(11, 28, 5)</span><br><span class="line">Out[19]: datetime.time(11, 28, 5)</span><br></pre></td></tr></table></figure></p></li><li><p>date对象：与datetime类似，但只表示日期，不表示时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [23]: datetime.date(2018, 07, 10)</span><br><span class="line">Out[23]: datetime.date(2018, 7, 10)</span><br></pre></td></tr></table></figure></p></li><li><p>time tuple: time tuple又叫struct time，是一种用于表示日期和时间的数据结构，此数据结构主要用于time module中的相关函数。time tuple中有9个元素，如下表所示：</p><table><thead><tr><th>索引(Index)</th><th>属性(Attribute)</th><th>值(Values)</th></tr></thead><tbody><tr><td>0</td><td>tm_year(年)</td><td>比如2011</td></tr><tr><td>1</td><td>tm_mon(月)</td><td>1 - 12</td></tr><tr><td>2</td><td>tm_mday(日)</td><td>1 - 31</td></tr><tr><td>3</td><td>tm_hour(时)</td><td>0 - 23</td></tr><tr><td>4</td><td>tm_min(分)</td><td>0 - 59</td></tr><tr><td>5</td><td>tm_sec(秒)</td><td>0 - 61</td></tr><tr><td>6</td><td>tm_wday(weekday)</td><td>0 - 6(0表示周日)</td></tr><tr><td>7</td><td>tm_yday(一年中的第几天)</td><td>1 - 366</td></tr><tr><td>8</td><td>tm_isdst(是否是夏令时)</td><td>默认为-1</td></tr></tbody></table><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [21]: import time</span><br><span class="line"></span><br><span class="line">In [22]: time.localtime()  # 返回一个time tuple用于表示当前时间的local time</span><br><span class="line">Out[22]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=11,   tm_min=26, tm_sec=19, tm_wday=5, tm_yday=209, tm_isdst=0)</span><br></pre></td></tr></table></figure></p></li></ul><p>总结：以上前三个对象(datetime, date, time)均来自datetime module（注意区分datetime module和datetime 对象），而最后一个time tuple主要用于time module中的相关操作。</p><h4>时间戳</h4><p>时间戳(Timestamp)是表示当前时间距离元年时间(epoch, 1970年1月1日00:00:00 UTC)的偏移量，这个偏移量在Python中用秒数来计算，但有些编程语言如JavaScript是用毫秒来计算的，需要注意。**另外需要知道时间戳没有时区概念，是不分时区的。**这就是为什么我们在数据库中通常存储的是时间戳，当需要向用户显示时间的时候，再转化为对应时区的时间。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前时间的时间戳</span><br><span class="line">In [24]: time.time()</span><br><span class="line">Out[24]: 1532750668.210267</span><br></pre></td></tr></table></figure></p><h4>日期时间字符串</h4><p>通常在需要向用户展示时间的时候，我们都需要将时间戳或者时间对象转化为字符串形式，从而在标准输出中能够打印出相应的时间。我们可以通过将时间戳或者对象进行转化和格式化来得到相应的字符串。需要说明的是，字符串表示时间有一个标准形式称为<a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO8601</a>，可以通过专门的函数来获得。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [29]: dt = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"># 获取ISO8601标准时间字符串</span><br><span class="line">In [30]: dt.isoformat()</span><br><span class="line">Out[30]: &apos;2018-07-28T12:11:33.582380&apos;</span><br><span class="line"></span><br><span class="line"># 自定义格式的时间字符串</span><br><span class="line">In [31]: dt.strftime(&quot;%Y%m%d-%H:%M:%S&quot;)</span><br><span class="line">Out[31]: &apos;20180728-12:11:33&apos;</span><br></pre></td></tr></table></figure></p><h2>日期时间处理场景</h2><p>时间处理主要有以下几个场景：</p><ul><li>获取当前时间</li><li>获取特定时间：例如获取5天前的时间。</li><li>不同时间表示的转化：例如将datetime对象转化为时间字符串</li><li>时区处理：这个将在《下篇》中详细讲述</li></ul><p>下面分别介绍下这几种处理场景：</p><h4>获取当前时间</h4><p>获取当前时间可以通过获取datetime对象、时间戳或time tuple三种方式来获取。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 最常用的获取当前日期时间的方法，其有一个tz参数用于设置时区，默认为None，所以最终获取的是一个原始naive时间</span><br><span class="line">In [36]: dt = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"># 注意获取的是当地时间的时间表示，但其本身是一个原始naive时间</span><br><span class="line">In [37]: dt</span><br><span class="line">Out[37]: datetime.datetime(2018, 7, 28, 12, 58, 57, 676468)</span><br><span class="line"></span><br><span class="line"># 获取当前时间的UTC时间表示，注意这仍然是一个原始naive时间，也就是用当前的UTC时间4点59分32秒来构造一个naive时间对象，但这个对象并没有包含时区信息</span><br><span class="line">In [38]: utc_now = datetime.datetime.utcnow()</span><br><span class="line"></span><br><span class="line">In [39]: utc_now</span><br><span class="line">Out[39]: datetime.datetime(2018, 7, 28, 4, 59, 32, 258087)</span><br><span class="line"></span><br><span class="line"># 获取当前时间的时间戳</span><br><span class="line">In [40]: time.time()</span><br><span class="line">Out[40]: 1532753948.563503</span><br><span class="line"></span><br><span class="line"># 获取当地时间的time tuple</span><br><span class="line">In [41]: time.localtime()</span><br><span class="line">Out[41]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=13, tm_min=0, tm_sec=2, tm_wday=5, tm_yday=209, tm_isdst=0)</span><br></pre></td></tr></table></figure></p><h4>获取特定时间</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [42]: dt</span><br><span class="line">Out[42]: datetime.datetime(2018, 7, 28, 12, 58, 57, 676468)</span><br><span class="line"></span><br><span class="line"># 获取两天前的时间</span><br><span class="line">In [43]: dt - datetime.timedelta(days=2)</span><br><span class="line">Out[43]: datetime.datetime(2018, 7, 26, 12, 58, 57, 676468)</span><br><span class="line"></span><br><span class="line"># 获取一周前的时间</span><br><span class="line">In [44]: dt - datetime.timedelta(weeks=1)</span><br><span class="line">Out[44]: datetime.datetime(2018, 7, 21, 12, 58, 57, 676468)</span><br><span class="line"></span><br><span class="line"># 获取3小时前的时间</span><br><span class="line">In [45]: dt - datetime.timedelta(hours=3)</span><br><span class="line">Out[45]: datetime.datetime(2018, 7, 28, 9, 58, 57, 676468)</span><br></pre></td></tr></table></figure></p><p>通过timedelta基本可以满足我们获取特定时间的需求，但是这里不涉及时区相关的转化。而且只是原始naive时间之间的转化</p><h4>不同时间表示的转化</h4><p>先来看一张关系图：<img src="https://upload-images.jianshu.io/upload_images/3959253-837fe6ec315f069e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.2-不同时间表示的关系图"></p><p>从上图可以看出总共有5对关系，每对关系都是可以双向转化的(除timetuple无法直接转化为datetime，需要先转化为timestamp或者time string)，所以总共有9种转化，下面将分别介绍下它们之间是如何互相转化的。</p><h5>datetime object &amp; timestamp</h5><p>从时间戳timestamp ==&gt; datetime object<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [2]: import time</span><br><span class="line"></span><br><span class="line">In [3]: from datetime import datetime</span><br><span class="line"></span><br><span class="line">In [4]: ts = time.time()</span><br><span class="line"></span><br><span class="line"># 直接通过fromtimestamp就可以获得时间戳对应的datetime对象</span><br><span class="line">In [5]: dt = datetime.fromtimestamp(ts)</span><br><span class="line"></span><br><span class="line">In [6]: ts</span><br><span class="line">Out[6]: 1532775234.192805</span><br><span class="line"></span><br><span class="line"># 注意这个datetime对象获取的是本地时间的表示，但是仍然是原始naive time</span><br><span class="line">In [7]: dt</span><br><span class="line">Out[7]: datetime.datetime(2018, 7, 28, 18, 53, 54, 192805)</span><br><span class="line"></span><br><span class="line"># 获取对应utc的时间表示，仍然是原始naive时间</span><br><span class="line">In [11]: utc_dt = datetime.utcfromtimestamp(ts)</span><br><span class="line">In [12]: utc_dt</span><br><span class="line">Out[12]: datetime.datetime(2018, 7, 28, 10, 53, 54, 192805)</span><br></pre></td></tr></table></figure></p><p>从datetime object ==&gt;时间戳timestamp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个函数用于返回datetime object对应的时间戳</span><br><span class="line">In [8]: def get_timestamp(datetime_obj):</span><br><span class="line">   ...:     if not isinstance(datetime_obj, datetime):</span><br><span class="line">   ...:         raise ValueError()</span><br><span class="line">   ...:     return (datetime_obj - datetime(1970, 1, 1)).total_seconds()</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [9]: get_timestamp(dt)</span><br><span class="line">Out[9]: 1532804034.192805</span><br><span class="line"></span><br><span class="line"># 也可以先转化为time tuple，再通过mktime函数转化为timestamp，但是精度不如上一版高</span><br><span class="line">In [13]: def get_timestamp_v2(datetime_obj):</span><br><span class="line">    ...:     if not isinstance(datetime_obj, datetime):</span><br><span class="line">    ...:         raise ValueError()</span><br><span class="line">    ...:     return time.mktime(datetime_obj.timetuple())</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [14]: get_timestamp_v2(dt)</span><br><span class="line">Out[14]: 1532775234.0</span><br></pre></td></tr></table></figure></p><h5>datetime object &amp; time string</h5><p>datetime object ==&gt; time string关于格式化的说明可以参考<a href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior" target="_blank" rel="noopener">官网文档</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [15]: dt</span><br><span class="line">Out[15]: datetime.datetime(2018, 7, 28, 18, 53, 54, 192805)</span><br><span class="line"></span><br><span class="line"># 自定义格式</span><br><span class="line">In [16]: dt.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)</span><br><span class="line">Out[16]: &apos;2018-07-28T18:53:54&apos;</span><br><span class="line"></span><br><span class="line"># 转化为ISO8601格式字符串的快捷方式</span><br><span class="line">In [17]: dt.isoformat()</span><br><span class="line">Out[17]: &apos;2018-07-28T18:53:54.192805&apos;</span><br></pre></td></tr></table></figure></p><p>time string ==&gt; datetime object<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [18]: time_str = &apos;2018-07-28T18:53:54&apos;</span><br><span class="line"></span><br><span class="line">In [19]: dt2 = datetime.strptime(time_str, &quot;%Y-%m-%dT%H:%M:%S&quot;)</span><br><span class="line"></span><br><span class="line">In [20]: dt2</span><br><span class="line">Out[20]: datetime.datetime(2018, 7, 28, 18, 53, 54)</span><br></pre></td></tr></table></figure></p><h5>datetime object &amp; time tuple</h5><p>datetime object ==&gt; time tuple<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [21]: dt.timetuple()</span><br><span class="line">Out[21]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=-1)</span><br></pre></td></tr></table></figure></p><p>time tuple ==&gt; datetime object无法直接转化，需要先转化为time str或者timestamp</p><h5>time tuple &amp; timestamp</h5><p>time tuple ==&gt; timestamp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [25]: time_tuple</span><br><span class="line">Out[25]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=-1)</span><br><span class="line"></span><br><span class="line"># 注意：该函数精度只能到秒</span><br><span class="line">In [26]: ts = time.mktime(time_tuple)</span><br><span class="line"></span><br><span class="line">In [27]: ts</span><br><span class="line">Out[27]: 1532775234.0</span><br></pre></td></tr></table></figure></p><p>timestamp ==&gt; time tuple<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [27]: ts</span><br><span class="line">Out[27]: 1532775234.0</span><br><span class="line"></span><br><span class="line"># 转为本地时间的time tuple表示，</span><br><span class="line">In [29]: tt = time.localtime(ts)</span><br><span class="line"></span><br><span class="line">In [30]: tt</span><br><span class="line">Out[30]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=0)</span><br><span class="line"></span><br><span class="line"># 转为UTC时间的time tuple表示</span><br><span class="line">In [31]: utc_tt = time.gmtime(ts)</span><br><span class="line"></span><br><span class="line">In [32]: utc_tt</span><br><span class="line">Out[32]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=10, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=0)</span><br></pre></td></tr></table></figure></p><h5>time tuple &amp; time string</h5><p>time tuple ==&gt; time string<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [33]: tt</span><br><span class="line">Out[33]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=0)</span><br><span class="line"></span><br><span class="line"># 注意：这里strftime并非time tuple的方法，而是time module下的函数</span><br><span class="line">In [34]: tt.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-34-1be0f512fc77&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 tt.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)</span><br><span class="line"></span><br><span class="line">AttributeError: &apos;time.struct_time&apos; object has no attribute &apos;strftime&apos;</span><br><span class="line"></span><br><span class="line"># 如下是正解</span><br><span class="line">In [35]: time.strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;, tt)</span><br><span class="line">Out[35]: &apos;2018-07-28T18:53:54&apos;</span><br></pre></td></tr></table></figure></p><p>time string ==&gt; time tuple<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [36]: time_str</span><br><span class="line">Out[36]: &apos;2018-07-28T18:53:54&apos;</span><br><span class="line"></span><br><span class="line">In [37]: tt = time.strptime(time_str, &quot;%Y-%m-%dT%H:%M:%S&quot;)</span><br><span class="line"></span><br><span class="line">In [38]: tt</span><br><span class="line">Out[38]: time.struct_time(tm_year=2018, tm_mon=7, tm_mday=28, tm_hour=18, tm_min=53, tm_sec=54, tm_wday=5, tm_yday=209, tm_isdst=-1)</span><br></pre></td></tr></table></figure></p><h5>timestamp &amp; time string</h5><p>无法相互转化，只能通过先转化为datetime object或者time tuple之后才能再转化</p><h2>References</h2><ul><li><a href="https://docs.python.org/2/library/time.html" target="_blank" rel="noopener">time module document</a></li><li><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="noopener">datetime module document</a></li><li><a href="https://medium.com/@eleroy/10-things-you-need-to-know-about-date-and-time-in-python-with-datetime-pytz-dateutil-timedelta-309bfbafb3f7" target="_blank" rel="noopener">10 things you need to know about Date and Time in Python</a></li><li><a href="http://www.wklken.me/posts/2015/03/03/python-base-datetime.html" target="_blank" rel="noopener">PYTHON-基础-时间日期处理小结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好吧，我承认这有标题党的嫌疑，不过看了那么多文章，的确没有找到一篇让我满意的关于日期和时间处理的详解文章，于是决心自己动手亲写一篇，希望能对得起这个霸气的标题。言归正传，在Python编程中，日期和时间处理是非常繁琐的一块，不仅概念众多，且有很多不同的module, 尤其涉
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis数据类型和常用命令</title>
    <link href="http://yoursite.com/2018/07/27/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/27/Redis数据类型和常用命令/</id>
    <published>2018-07-27T10:18:18.000Z</published>
    <updated>2018-08-12T10:03:01.516Z</updated>
    
    <content type="html"><![CDATA[<p>Redis相较于其它的数据库虽然简单，但是要熟记所有命令的用法也并非易事。一个简单的技巧是通过要操作的数据类型来将这些命令进行结构化。</p><p>&lt;!--more--&gt;</p><h2>数据类型和对应命令</h2><p>所有存储于redis中的数据都对应于一个键值对(key-value pair), key可以是任意二进制序列，通常我们使用字符串来标记一个特定的key。在redis中我们通常称这个key为name或者就叫key, 而对于value，redis支持如下几种类型：</p><ul><li>strings</li><li>lists: list内容只能是string</li><li>sets: set中存储非重复的string</li><li>sorted sets: 与sets类似，但是每个string都会对应一个float类型的score，从而用于排序</li><li>hashes: 键值对hash类型，也就是Python中的dict，注意在redis中最外层的key一般叫做name或者key，而value中数据类型如果是dict，那么这个dict中的key通常被称为field。</li><li>Bit arrays (or simply bitmaps): 实际存储的仍然是string，但是可以针对bit进行操作</li><li>HyperLogLogs: 用于估计unique value的数量</li></ul><p>针对不同的数据类型，会有不同的命令，通过如下脑图可以更加清晰地记忆redis的命令<img src="https://upload-images.jianshu.io/upload_images/3959253-6c756bf39ad702c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Redis数据类型与常用命令"></p><h4>strings</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set strtest xyz</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get strtest</span><br><span class="line">&quot;xyz&quot;</span><br><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget a b c</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line"># 注意以下增减操作只能针对整数数字(虽然类型仍然是string类型)</span><br><span class="line">127.0.0.1:6379&gt; incr a</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incrby b 5</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; decr b</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; decrby b 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><h4>lists</h4><p>lists类型中存储的仍然是string类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># left push用于从左将item压入到list当中</span><br><span class="line">127.0.0.1:6379&gt; lpush list_test 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"># 注意如果想看list中的内容，无法通过get直接去看，get只是针对string，而必须使用lrange</span><br><span class="line">127.0.0.1:6379&gt; get list_test </span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line"></span><br><span class="line"># 这里0 -1均为list index，表示从index 0 开始到-1结束，-1即从右数最后一个item</span><br><span class="line">127.0.0.1:6379&gt; lrange list_test 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush list_test 5 7</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list_test 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;7&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list_test</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list_test 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">4) &quot;7&quot;</span><br><span class="line"></span><br><span class="line"># 从左trim截断list，以下是截取index 0 到index 2 的item作为新的list</span><br><span class="line">127.0.0.1:6379&gt; ltrim list_test 0 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list_test 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;5&quot;</span><br></pre></td></tr></table></figure></p><h4>hashes (dict)</h4><p>哈希类型，在python中也就是dict类型。这也是非常常用的数据类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset htest a 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget htest a</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hmset htest a 1 b 2 c 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget htest a b c</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall htest</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; hkeys htest</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals htest</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure></p><p>在python程序中使用redis-py driver的时候，通过dict进行操作会非常清晰和简单。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import redis</span><br><span class="line"></span><br><span class="line">In [2]: r = redis.StrictRedis(host=&apos;localhost&apos;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line">In [3]: d = &#123;&quot;a&quot;: 2, &quot;b&quot;: 3&#125;</span><br><span class="line"></span><br><span class="line">In [4]: key = &quot;test:2&quot;</span><br><span class="line"></span><br><span class="line">In [5]: r.hmset(key, d)</span><br><span class="line">Out[5]: True</span><br><span class="line"></span><br><span class="line">In [6]: r.hgetall(key)</span><br><span class="line">Out[6]: &#123;&apos;a&apos;: &apos;2&apos;, &apos;b&apos;: &apos;3&apos;&#125;</span><br></pre></td></tr></table></figure></p><h4>sets</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set_test a b 33</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd set_test c a b 22</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 可以看到不会有重复的item</span><br><span class="line">127.0.0.1:6379&gt; smembers set_test</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;33&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line"></span><br><span class="line"># 用于测试set中是否包含指定的item，如有则返回1，没有返回0</span><br><span class="line">127.0.0.1:6379&gt; sismember set_test a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember set_test xx</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd set_test2 a b 56 66</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set_test2</span><br><span class="line">1) &quot;56&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;66&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line"></span><br><span class="line"># 求交集</span><br><span class="line">127.0.0.1:6379&gt; sinter set_test set_test2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line"></span><br><span class="line"># 求并集</span><br><span class="line">127.0.0.1:6379&gt; sunion set_test set_test2</span><br><span class="line">1) &quot;33&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;56&quot;</span><br><span class="line">4) &quot;c&quot;</span><br><span class="line">5) &quot;66&quot;</span><br><span class="line">6) &quot;22&quot;</span><br><span class="line">7) &quot;b&quot;</span><br></pre></td></tr></table></figure></p><h4>sorted sets</h4><p>sorted sets与sets类似，可以保证item不重复，区别在于sorted sets中每个item对应一个float类型的score<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd sort_set 2.2 a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sort_set 2 bb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd sort_set 10 x</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 获取index 从0 到-1的(即所有) items</span><br><span class="line">127.0.0.1:6379&gt; zrange sort_set 0 -1</span><br><span class="line">1) &quot;bb&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;x&quot;</span><br><span class="line"></span><br><span class="line"># 获取item bb对应的index</span><br><span class="line">127.0.0.1:6379&gt; zrank sort_set bb</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrank sort_set x</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zscore sort_set x</span><br><span class="line">&quot;10&quot;</span><br><span class="line"></span><br><span class="line"># 用于获取对应score set中item的数量</span><br><span class="line">127.0.0.1:6379&gt; zcard sort_set</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><h4>bit arrays</h4><p>用于针对指定的key设置位数据为0 或 1。当我们对存储有较高要求，且对于统计为1的item的数量时，使用bit array是一个好的办法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 针对bit 7进行设置，设置为1，返回该位之前存储的值</span><br><span class="line">127.0.0.1:6379&gt; setbit bit_test 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bit_test 7 0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get bit_test</span><br><span class="line">&quot;\x00&quot;</span><br><span class="line">127.0.0.1:6379&gt; setbit bit_test 8 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bit_test 9 1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"># 统计有多少位为1</span><br><span class="line">127.0.0.1:6379&gt; bitcount bit_test</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p><h4>HyperLogLogs</h4><p>redis实现了相应算法可以估计hyperloglog中存储的所有item中非重复的item的数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd loglog 1 3 5 7 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount loglog</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></p><h2>通用的命令</h2><ul><li>keys pattern: pattern可以为glob风格的通配符格式，最常用的是<code>keys *</code>查询所有的keys</li><li>exists key: 查询该key是否存在</li><li>del key: 删除该key对应的数据</li><li>type key: 查询该key对应的value的数据类型</li><li>expire key: 定义多长时间后key对应的数据过期，过期后数据会被自动删除</li><li>ttl key: 查询该key对应的剩余存活时间</li><li>flushdb/flushall: flushdb用于清除当前db的所有数据，flushall清除所有数据库的数据</li></ul><h2>References</h2><ul><li><a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">Redis Type Introduction</a></li><li><a href="https://redis.io/commands#" target="_blank" rel="noopener">Redis Commands</a></li><li><a href="https://segmentfault.com/a/1190000010999677" target="_blank" rel="noopener">Redis 常用命令</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis相较于其它的数据库虽然简单，但是要熟记所有命令的用法也并非易事。一个简单的技巧是通过要操作的数据类型来将这些命令进行结构化。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h2&gt;数据类型和对应命令&lt;/h2&gt;
&lt;p&gt;所有存储于redis中的数据都对应于
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列6-DataFrame的分组与聚合</title>
    <link href="http://yoursite.com/2018/07/23/Pandas%E7%B3%BB%E5%88%976-DataFrame%E7%9A%84%E5%88%86%E7%BB%84%E4%B8%8E%E8%81%9A%E5%90%88/"/>
    <id>http://yoursite.com/2018/07/23/Pandas系列6-DataFrame的分组与聚合/</id>
    <published>2018-07-23T10:18:18.000Z</published>
    <updated>2018-08-12T10:06:16.879Z</updated>
    
    <content type="html"><![CDATA[<p>在对数据进行处理的时候，分组与聚合是非常常用的操作。在Pandas中此类操作主要是通过groupby函数来完成的。</p><p>&lt;!--more--&gt;</p><p>先看一个实际的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个原始的DataFrame</span><br><span class="line">In [70]: raw_data = &#123;&apos;regiment&apos;: [&apos;Nighthawks&apos;, &apos;Nighthawks&apos;, &apos;Nighthawks&apos;, &apos;Nighthawk</span><br><span class="line">    ...: s&apos;, &apos;Dragoons&apos;, &apos;Dragoons&apos;, &apos;Dragoons&apos;, &apos;Dragoons&apos;, &apos;Scouts&apos;, &apos;Scouts&apos;, &apos;Scou</span><br><span class="line">    ...: ts&apos;, &apos;Scouts&apos;],</span><br><span class="line">    ...:         &apos;company&apos;: [&apos;1st&apos;, &apos;1st&apos;, &apos;2nd&apos;, &apos;2nd&apos;, &apos;1st&apos;, &apos;1st&apos;, &apos;2nd&apos;, &apos;2nd&apos;,&apos;1</span><br><span class="line">    ...: st&apos;, &apos;1st&apos;, &apos;2nd&apos;, &apos;2nd&apos;],</span><br><span class="line">    ...:         &apos;name&apos;: [&apos;Miller&apos;, &apos;Jacobson&apos;, &apos;Ali&apos;, &apos;Milner&apos;, &apos;Cooze&apos;, &apos;Jacon&apos;, &apos;Ry</span><br><span class="line">    ...: aner&apos;, &apos;Sone&apos;, &apos;Sloan&apos;, &apos;Piger&apos;, &apos;Riani&apos;, &apos;Ali&apos;],</span><br><span class="line">    ...:         &apos;preTestScore&apos;: [4, 24, 31, 2, 3, 4, 24, 31, 2, 3, 2, 3],</span><br><span class="line">    ...:         &apos;postTestScore&apos;: [25, 94, 57, 62, 70, 25, 94, 57, 62, 70, 62, 70]&#125;</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [71]: df = pd.DataFrame(raw_data, columns = [&apos;regiment&apos;, &apos;company&apos;, &apos;name&apos;, &apos;preTes</span><br><span class="line">    ...: tScore&apos;, &apos;postTestScore&apos;])</span><br><span class="line"></span><br><span class="line">In [72]: df</span><br><span class="line">Out[72]:</span><br><span class="line">      regiment company      name  preTestScore  postTestScore</span><br><span class="line">0   Nighthawks     1st    Miller             4             25</span><br><span class="line">1   Nighthawks     1st  Jacobson            24             94</span><br><span class="line">2   Nighthawks     2nd       Ali            31             57</span><br><span class="line">3   Nighthawks     2nd    Milner             2             62</span><br><span class="line">4     Dragoons     1st     Cooze             3             70</span><br><span class="line">5     Dragoons     1st     Jacon             4             25</span><br><span class="line">6     Dragoons     2nd    Ryaner            24             94</span><br><span class="line">7     Dragoons     2nd      Sone            31             57</span><br><span class="line">8       Scouts     1st     Sloan             2             62</span><br><span class="line">9       Scouts     1st     Piger             3             70</span><br><span class="line">10      Scouts     2nd     Riani             2             62</span><br><span class="line">11      Scouts     2nd       Ali             3             70</span><br></pre></td></tr></table></figure></p><p>通过groupby函数生成一个groupby对象，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 当针对特定列（此例是&apos;preTestScore&apos;）进行分组时，需要通过df[&apos;colume_name&apos;](此例是df[&apos;regiment&apos;])来指定键名</span><br><span class="line">In [73]: groupby_regiment = df[&apos;preTestScore&apos;].groupby(df[&apos;regiment&apos;])</span><br><span class="line"></span><br><span class="line"># 生成的groupby对象没有做任何计算，只是将数据按键进行分组</span><br><span class="line">In [74]: groupby_regiment</span><br><span class="line">Out[74]: &lt;pandas.core.groupby.SeriesGroupBy object at 0x11112cef0&gt;</span><br><span class="line"></span><br><span class="line"># 分组的聚合统计</span><br><span class="line">In [75]: groupby_regiment.describe()</span><br><span class="line">Out[75]:</span><br><span class="line">            count   mean        std  min   25%   50%    75%   max</span><br><span class="line">regiment</span><br><span class="line">Dragoons      4.0  15.50  14.153916  3.0  3.75  14.0  25.75  31.0</span><br><span class="line">Nighthawks    4.0  15.25  14.453950  2.0  3.50  14.0  25.75  31.0</span><br><span class="line">Scouts        4.0   2.50   0.577350  2.0  2.00   2.5   3.00   3.0</span><br><span class="line"></span><br><span class="line"># 也可以针对特定统计单独计算</span><br><span class="line">In [76]: groupby_regiment.mean()</span><br><span class="line">Out[76]:</span><br><span class="line">regiment</span><br><span class="line">Dragoons      15.50</span><br><span class="line">Nighthawks    15.25</span><br><span class="line">Scouts         2.50</span><br><span class="line">Name: preTestScore, dtype: float64</span><br></pre></td></tr></table></figure></p><p>整个分组统计的过程，可以通过下图更清晰地展示：<img src="https://upload-images.jianshu.io/upload_images/3959253-c268458a8035803b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.1-group and aggregate process"></p><h4>聚合函数</h4><p>聚合的时候，既可以使用Pandas内置的函数进行聚合计算，也可以使用自定义的函数进行聚合计算，我们先来看下内置的函数：<img src="https://upload-images.jianshu.io/upload_images/3959253-0b1bee24d432dc9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.2-built-in aggregate functions">另外，我们也可以自定义聚合函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [81]: def my_agg(pre_test_score_group):</span><br><span class="line">    ...:     return np.sum(np.power(pre_test_score_group, 2))</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [82]: df[&apos;preTestScore&apos;].groupby(df[&apos;regiment&apos;]).apply(my_agg)</span><br><span class="line">Out[82]:</span><br><span class="line">regiment</span><br><span class="line">Dragoons      1562</span><br><span class="line">Nighthawks    1557</span><br><span class="line">Scouts          26</span><br><span class="line">Name: preTestScore, dtype: int64</span><br></pre></td></tr></table></figure></p><p>通过上面的例子我们可以看到，通过apply函数也可以完成类似for循环的迭代，在pandas中尽可能使用apply函数来代替for循环迭代，以提高性能。</p><h4>根据多个键进行分组和聚合</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 如果有多个键，将多个键放到一个list当中，作为groupby的参数</span><br><span class="line">In [77]: df[&apos;preTestScore&apos;].groupby([df[&apos;regiment&apos;], df[&apos;company&apos;]]).mean()</span><br><span class="line">Out[77]:</span><br><span class="line">regiment    company</span><br><span class="line">Dragoons    1st         3.5</span><br><span class="line">            2nd        27.5</span><br><span class="line">Nighthawks  1st        14.0</span><br><span class="line">            2nd        16.5</span><br><span class="line">Scouts      1st         2.5</span><br><span class="line">            2nd         2.5</span><br><span class="line">Name: preTestScore, dtype: float64</span><br><span class="line"></span><br><span class="line"># unstack之后变成表格模式，更加清晰</span><br><span class="line">In [78]: df[&apos;preTestScore&apos;].groupby([df[&apos;regiment&apos;], df[&apos;company&apos;]]).mean().unstack()</span><br><span class="line">Out[78]:</span><br><span class="line">company      1st   2nd</span><br><span class="line">regiment</span><br><span class="line">Dragoons     3.5  27.5</span><br><span class="line">Nighthawks  14.0  16.5</span><br><span class="line">Scouts       2.5   2.5</span><br></pre></td></tr></table></figure></p><h2>References</h2><ul><li><a href="https://chrisalbon.com/python/data_wrangling/pandas_apply_operations_to_groups/" target="_blank" rel="noopener">Apply Operations To Groups In Pandas</a></li><li><a href="https://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.groupby.html" target="_blank" rel="noopener">Pandas official doc - groupby </a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在对数据进行处理的时候，分组与聚合是非常常用的操作。在Pandas中此类操作主要是通过groupby函数来完成的。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;p&gt;先看一个实际的例子：
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列5-DataFrame之过滤</title>
    <link href="http://yoursite.com/2018/07/06/Pandas%E7%B3%BB%E5%88%975-DataFrame%E4%B9%8B%E8%BF%87%E6%BB%A4/"/>
    <id>http://yoursite.com/2018/07/06/Pandas系列5-DataFrame之过滤/</id>
    <published>2018-07-06T10:18:18.000Z</published>
    <updated>2018-08-12T10:06:03.730Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas的条件过滤是使用非常频繁的技巧，在这一节我们将看到各种不同的过滤技巧，如果读者有其它过滤技巧，也欢迎告诉我。</p><p>&lt;!--more--&gt;</p><h2>条件过滤与赋值</h2><p>通过loc进行行过滤，并对过滤后的行进行赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [34]: df</span><br><span class="line">Out[34]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20   blue     165</span><br><span class="line">1   30    red     175</span><br><span class="line">2   15  green     185</span><br><span class="line"></span><br><span class="line"># 注意这里赋值需要使用如下方式，而不能使用chained index</span><br><span class="line"># 具体参考http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy</span><br><span class="line">In [38]: df.loc[df.color == &apos;blue&apos;,&apos;height&apos;] = 199</span><br><span class="line"></span><br><span class="line">In [39]: df</span><br><span class="line">Out[39]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20   blue     199</span><br><span class="line">1   30    red     175</span><br><span class="line">2   15  green     185</span><br><span class="line"></span><br><span class="line"># 表示列数据除了上例中使用&apos;.&apos;,还可以使用&apos;[]&apos;,如下:</span><br><span class="line">In [40]: df.loc[df2[&apos;color&apos;]==&apos;blue&apos;, &apos;height&apos;] = 175</span><br><span class="line"></span><br><span class="line">In [41]: df</span><br><span class="line">Out[41]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20   blue     175</span><br><span class="line">1   30    red     175</span><br><span class="line">2   15  green     185</span><br></pre></td></tr></table></figure></p><p>除了上述的过滤方式外，还可以通过query method来进行过滤查询，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [248]: df2</span><br><span class="line">Out[248]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20  black     155</span><br><span class="line">1   33  green     177</span><br><span class="line">2   22    NaN     188</span><br><span class="line">3   20   blue     175</span><br><span class="line"></span><br><span class="line">In [250]: df2.query(&apos;age&gt;20 &amp; age&lt;40&apos;)</span><br><span class="line">Out[250]:</span><br><span class="line">   age  color  height</span><br><span class="line">1   33  green     177</span><br><span class="line">2   22    NaN     188</span><br></pre></td></tr></table></figure></p><h2>空值判断</h2><p>在数据处理的过程中，空值判断是非常常用的技巧，在Pandas中我们主要通过以下几种方式来判断空值。</p><ul><li>isnull函数: 用于针对Series、DataFrame判断是否为null</li><li>notnull函数: 用于判断非null值</li><li>np.isnan函数: 用于针对某个标量值进行判断是否为nan(null)。需要注意的是这个函数不能用于字符串类型的值进行判断，因此如果array中有字符串类型，需要用其它方式进行判断，如isinstance</li></ul><h5>isnull函数</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">In [605]: dfx</span><br><span class="line">Out[605]:</span><br><span class="line">    1  2</span><br><span class="line">0</span><br><span class="line">a1  2  4</span><br><span class="line">a2  5  5</span><br><span class="line">b1  5  7</span><br><span class="line"></span><br><span class="line">In [606]: dfx.iloc[1, 1] = np.nan</span><br><span class="line"></span><br><span class="line">In [607]: dfx</span><br><span class="line">Out[607]:</span><br><span class="line">    1    2</span><br><span class="line">0</span><br><span class="line">a1  2  4.0</span><br><span class="line">a2  5  NaN</span><br><span class="line">b1  5  7.0</span><br><span class="line"></span><br><span class="line">In [608]: dfx.isnull()</span><br><span class="line">Out[608]:</span><br><span class="line">        1      2</span><br><span class="line">0</span><br><span class="line">a1  False  False</span><br><span class="line">a2  False   True</span><br><span class="line">b1  False  False</span><br><span class="line"></span><br><span class="line"># 如果该列所有的值均不为null则返回False，只要有一个值为null则返回True</span><br><span class="line">In [609]: dfx.isnull().any()</span><br><span class="line">Out[609]:</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line"># 针对DataFrame中的所有值进行检查，只要有一个null值，则返回True</span><br><span class="line">In [610]: dfx.isnull().any().any()</span><br><span class="line">Out[610]: True</span><br><span class="line"></span><br><span class="line"># 返回null值的数量</span><br><span class="line">In [611]: dfx.isnull().sum().sum()</span><br><span class="line">Out[611]: 1</span><br></pre></td></tr></table></figure></p><p>将isnull用于过滤条件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [244]: df2</span><br><span class="line">Out[244]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20  black     155</span><br><span class="line">1   33  green     177</span><br><span class="line">2   22    NaN     188</span><br><span class="line">3   20   blue     165</span><br><span class="line"></span><br><span class="line">In [245]: df2.loc[df2[&apos;color&apos;].isnull(), :]</span><br><span class="line">Out[245]:</span><br><span class="line">   age color  height</span><br><span class="line">2   22   NaN     188</span><br></pre></td></tr></table></figure></p><h5>notnull函数</h5><p>notnull的使用与isnull类似,如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [248]: df2</span><br><span class="line">Out[248]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20  black     155</span><br><span class="line">1   33  green     177</span><br><span class="line">2   22    NaN     188</span><br><span class="line">3   20   blue     175</span><br><span class="line"></span><br><span class="line">In [249]: df2.loc[df2.color.notnull(), :]</span><br><span class="line">Out[249]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20  black     155</span><br><span class="line">1   33  green     177</span><br><span class="line">3   20   blue     175</span><br></pre></td></tr></table></figure></p><h5>np.isnan函数</h5><p>需要注意的是判断dataframe中某个值是否为空，不能直接用== np.nan来判断，而需要使用np.isnan函数如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [616]: dfx.iloc[1, 1] == np.nan</span><br><span class="line">Out[616]: False</span><br><span class="line"></span><br><span class="line">In [614]: np.isnan(dfx.iloc[1, 1])</span><br><span class="line">Out[614]: True</span><br><span class="line"></span><br><span class="line"># 其它判断方式同样不行</span><br><span class="line">In [617]: dfx.iloc[1, 1] is None</span><br><span class="line">Out[617]: False</span><br><span class="line"></span><br><span class="line">In [618]: if not dfx.iloc[1, 1]: print(&quot;True&quot;)</span><br><span class="line"></span><br><span class="line">In [619]:</span><br></pre></td></tr></table></figure></p><h2>isin函数</h2><p>使用isin函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In [764]: df</span><br><span class="line">Out[764]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        30   blue   Steak     178    4.6    NY</span><br><span class="line">Nick         2  green    Lamb     181    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     178    9.0    FL</span><br><span class="line">Penelope     4  white   Apple     178    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     175    1.8    AK</span><br><span class="line">Christina   33  black   Melon     178    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans     178    2.2    TX</span><br><span class="line"></span><br><span class="line">In [765]: df3 = df[df[&apos;state&apos;].isin([&apos;NY&apos;, &apos;TX&apos;])]</span><br><span class="line"></span><br><span class="line">In [766]: df3</span><br><span class="line">Out[766]:</span><br><span class="line">           age  color   food  height  score state</span><br><span class="line">Jane        30   blue  Steak     178    4.6    NY</span><br><span class="line">Nick         2  green   Lamb     181    8.3    TX</span><br><span class="line">Christina   33  black  Melon     178    9.5    TX</span><br><span class="line">Cornelia    69    red  Beans     178    2.2    TX</span><br><span class="line"></span><br><span class="line"># 也可以使用&apos;~&apos;或者&apos;-&apos;来选择不在列表中的项</span><br><span class="line">In [773]: df3 = df[-df[&apos;state&apos;].isin([&apos;NY&apos;, &apos;TX&apos;])]</span><br><span class="line"></span><br><span class="line">In [774]: df3</span><br><span class="line">Out[774]:</span><br><span class="line">          age  color    food  height  score state</span><br><span class="line">Aaron      12    red   Mango     178    9.0    FL</span><br><span class="line">Penelope    4  white   Apple     178    3.3    AL</span><br><span class="line">Dean       32   gray  Cheese     175    1.8    AK</span><br></pre></td></tr></table></figure></p><h2>多过滤条件</h2><p>当有多个过滤条件时，我们就需要使用逻辑操作符<code>&amp;</code>, <code>|</code>,如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [251]: df2</span><br><span class="line">Out[251]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20  black     155</span><br><span class="line">1   33  green     177</span><br><span class="line">2   22    NaN     188</span><br><span class="line">3   20   blue     175</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [254]: df2.loc[(df2.age&gt;20) &amp; (df2.color.notnull())]</span><br><span class="line">Out[254]:</span><br><span class="line">   age  color  height</span><br><span class="line">1   33  green     177</span><br><span class="line"></span><br><span class="line"># 注意在逻辑操作符两边的过滤条件必须使用小括号括起来，否则条件过滤不起作用，如下：</span><br><span class="line">In [253]: df2.loc[df2.age&gt;20 &amp; df2.color.notnull()]</span><br><span class="line">Out[253]:</span><br><span class="line">   age  color  height</span><br><span class="line">0   20  black     155</span><br><span class="line">1   33  green     177</span><br><span class="line">2   22    NaN     188</span><br><span class="line">3   20   blue     175</span><br></pre></td></tr></table></figure></p><h2>过滤后的赋值计算</h2><p>在实际项目中，很多时候我们根据条件选取了一些行之后，我们要针对这些行中的数据需要做些操作（比如针对age进行加1操作），更复杂的我们需要获取本行的其它列的数据共同计算和判断。这里我们可以使用如下技巧:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">In [256]: df</span><br><span class="line">Out[256]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        30   blue   Steak     165    4.6    NY</span><br><span class="line">Nick         2  green    Lamb      70    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     120    9.0    FL</span><br><span class="line">Penelope     4  white   Apple      80    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     180    1.8    AK</span><br><span class="line">Christina   33  black   Melon     172    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans     150    2.2    TX</span><br><span class="line"></span><br><span class="line"># 使用mask作为我们的筛选条件</span><br><span class="line">In [258]: mask = (df.color==&apos;blue&apos;)</span><br><span class="line"></span><br><span class="line"># 选出符合条件的行，并对age列的数据进行加1操作</span><br><span class="line">In [260]: df.loc[mask, &apos;age&apos;] = df.loc[mask, &apos;age&apos;] + 1</span><br><span class="line"></span><br><span class="line">In [261]: df</span><br><span class="line">Out[261]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        31   blue   Steak     165    4.6    NY</span><br><span class="line">Nick         2  green    Lamb      70    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     120    9.0    FL</span><br><span class="line">Penelope     4  white   Apple      80    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     180    1.8    AK</span><br><span class="line">Christina   33  black   Melon     172    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans     150    2.2    TX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 更复杂的，我们如果需要同一行的其它数据进行计算，那么我们就需要使用apply函数和并选出响应的列，如下:</span><br><span class="line">In [262]: df_with_age_height = df.loc[mask, [&apos;age&apos;, &apos;height&apos;]]</span><br><span class="line"></span><br><span class="line">In [265]: df.loc[mask, &apos;score&apos;] = df_with_age_height.apply(lambda row: row[&apos;age&apos;] + row[&apos;</span><br><span class="line">     ...: height&apos;]/100, axis=1)</span><br><span class="line"></span><br><span class="line">In [266]: df</span><br><span class="line">Out[266]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        31   blue   Steak     165  32.65    NY</span><br><span class="line">Nick         2  green    Lamb      70   8.30    TX</span><br><span class="line">Aaron       12    red   Mango     120   9.00    FL</span><br><span class="line">Penelope     4  white   Apple      80   3.30    AL</span><br><span class="line">Dean        32   gray  Cheese     180   1.80    AK</span><br><span class="line">Christina   33  black   Melon     172   9.50    TX</span><br><span class="line">Cornelia    69    red   Beans     150   2.20    TX</span><br><span class="line"></span><br><span class="line"># 使用apply仍然是使用迭代的方式，我们可以通过vectorization的方式直接计算，如下</span><br><span class="line">In [10]: mask = (df.color == &apos;red&apos;)</span><br><span class="line">In [13]: df_with_age_height = df.loc[mask, [&apos;age&apos;, &apos;height&apos;]]</span><br><span class="line">In [14]: df.loc[mask, &apos;score&apos;] = (df_with_age_height[&apos;age&apos;] + df_with_age_height[&apos;height&apos;])/100</span><br><span class="line"></span><br><span class="line">In [15]: df</span><br><span class="line">Out[15]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        30   blue   Steak     165   1.95    NY</span><br><span class="line">Nick         2  green    Lamb      70   8.30    TX</span><br><span class="line">Aaron       12    red   Mango     120   1.32    FL</span><br><span class="line">Penelope     4  white   Apple      80   3.30    AL</span><br><span class="line">Dean        32   gray  Cheese     180   1.80    AK</span><br><span class="line">Christina   33  black   Melon     172   9.50    TX</span><br><span class="line">Cornelia    69    red   Beans     150   2.19    TX</span><br></pre></td></tr></table></figure></p><p>关于vectorization矢量化的相关议题，可以参考文章<a href="https://www.jianshu.com/p/4855c24579b8" target="_blank" rel="noopener">Pandas系列4-数据矢量化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pandas的条件过滤是使用非常频繁的技巧，在这一节我们将看到各种不同的过滤技巧，如果读者有其它过滤技巧，也欢迎告诉我。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h2&gt;条件过滤与赋值&lt;/h2&gt;
&lt;p&gt;通过loc进行行过滤，并对过滤后的行进行赋值
&lt;fig
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python定时任务-schedule vs. Celery vs. APScheduler</title>
    <link href="http://yoursite.com/2018/06/21/Python%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-schedule-vs--Celery-vs--APScheduler/"/>
    <id>http://yoursite.com/2018/06/21/Python定时任务-schedule-vs--Celery-vs--APScheduler/</id>
    <published>2018-06-21T10:18:18.000Z</published>
    <updated>2018-08-12T10:06:55.935Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细讲述了在Python开发中常用的几种定时任务途径，并重点对比了schedule, Celery和APScheduler</p><p>&lt;!--more--&gt;</p><p>在Python开发过程中我们经常需要执行定时任务，而此类任务我们通常有如下选项：</p><ul><li>自己造轮子</li><li>使用schedule库</li><li>使用Celery定时任务</li><li>使用APScheduler</li></ul><p>自己造轮子实现，最大的优势就是灵活性，调试方便，对于某些特定系统也许也是一种选择，不过对于大多数应用来说，我们应当尽可能地使用开源的成熟的方案。下面对后三种方案分别讨论：</p><h2>使用schedule库</h2><p>schedule库是一个轻量级的定时任务方案，<strong>优势是使用简单，也不需要做什么配置；缺点是无法动态添加任务，也无法将任务持久化。</strong></p><h5>安装</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install schedule</span><br></pre></td></tr></table></figure></p><h5>使用</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import schedule</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def job():</span><br><span class="line">    print(&quot;I&apos;m working...&quot;)</span><br><span class="line"></span><br><span class="line">schedule.every(10).minutes.do(job)</span><br><span class="line">schedule.every().hour.do(job)</span><br><span class="line">schedule.every().day.at(&quot;10:30&quot;).do(job)</span><br><span class="line">schedule.every(5).to(10).minutes.do(job)</span><br><span class="line">schedule.every().monday.do(job)</span><br><span class="line">schedule.every().wednesday.at(&quot;13:15&quot;).do(job)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    schedule.run_pending()</span><br><span class="line">    time.sleep(1)</span><br></pre></td></tr></table></figure></p><h2>使用Celery</h2><p>Celery在Python领域可谓大名鼎鼎，我们通常将Celery作为一个任务队列来使用，不过Celery也同时提供了定时任务功能。通常，当我们的解决方案中已经在使用Celery的时候可以考虑同时使用其定时任务功能，但是Celery无法在Flask这样的系统中动态添加定时任务（在Django中有相应的插件可以实现动态添加任务），而且如果对于不使用Celery的项目，单独为定时任务搭建Celery显得过于重量级了。(搭建Celery比较麻烦，还需要配置诸如RabbitMQ之类消息分发程序)。</p><p>Celery安装在此不再赘述，大家可以参考官网的资料</p><h5>使用</h5><p>Celery虽然无法动态添加定时任务，但是可以在程序固定位置添加定时任务，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line"></span><br><span class="line">app = Celery()</span><br><span class="line"></span><br><span class="line"># 此处on_after_configure装饰符意味着当Celery app配置完成之后调用该hook函数</span><br><span class="line">@app.on_after_configure.connect</span><br><span class="line">def setup_periodic_tasks(sender, **kwargs):</span><br><span class="line">    # Calls test(&apos;hello&apos;) every 10 seconds.</span><br><span class="line">    sender.add_periodic_task(10.0, test.s(&apos;hello&apos;), name=&apos;add every 10&apos;)</span><br><span class="line"></span><br><span class="line">    # Calls test(&apos;world&apos;) every 30 seconds</span><br><span class="line">    sender.add_periodic_task(30.0, test.s(&apos;world&apos;), expires=10)</span><br><span class="line"></span><br><span class="line">    # Executes every Monday morning at 7:30 a.m.</span><br><span class="line">    sender.add_periodic_task(</span><br><span class="line">        crontab(hour=7, minute=30, day_of_week=1),</span><br><span class="line">        test.s(&apos;Happy Mondays!&apos;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def test(arg):</span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure></p><ul><li><p>这里调用<code>add_periodic_task</code>用于添加一个定时任务，相当于在Celery config文件中的beat_schedule设置项中添加了一项，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line">    &apos;add-every-30-seconds&apos;: &#123;</span><br><span class="line">        &apos;task&apos;: &apos;tasks.add&apos;,</span><br><span class="line">        &apos;schedule&apos;: 30.0,</span><br><span class="line">        &apos;args&apos;: (16, 16)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>在<code>add_periodic_task</code>中指定job function时需要用<code>.s()</code>来调用</p></li></ul><h2>使用APScheduler</h2><p>笔者认为APScheduler是在实际项目最好用的一个工具库。<strong>它不仅可以让我们在程序中动态添加和删除我们的定时任务，还支持持久化，且其持久化方案支持很多形式，包括(Memory, MongoDB, SQLAlchemy, Redis, RethinkDB, ZooKeeper), 也可以非常好与一些Python framework集成(包括asyncio, gevent, Tornado, Twisted, Qt).</strong> 笔者所在的项目使用的是Flask框架，也有相应的插件可以供我们直接使用。</p><p>但是笔者没有使用插件，而是直接将APScheduler集成于项目代码中。</p><h5>初始化scheduler</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 可以在初始化Flask的时候调用，并将返回的scheduler赋给app</span><br><span class="line">def init_scheduler():</span><br><span class="line">    # 这里用于持久化的设置，代码中演示使用MongoDB</span><br><span class="line">    # client用于设置你自己的MongoDB的handler, 即MongoClient对象</span><br><span class="line">    jobstores = &#123;</span><br><span class="line">        &apos;default&apos;: MongoDBJobStore(client=your_db_handler, collection=&quot;schedule_job&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    executors = &#123;</span><br><span class="line">        &apos;default&apos;: ThreadPoolExecutor(20)</span><br><span class="line">    &#125;</span><br><span class="line">    job_defaults = &#123;</span><br><span class="line">        &apos;coalesce&apos;: False,</span><br><span class="line">        &apos;max_instances&apos;: 5</span><br><span class="line">    &#125;</span><br><span class="line">    # 这里使用BackgroundScheduler即可</span><br><span class="line">    scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=utc)</span><br><span class="line">    # 注意这里一定要调用start启动scheduler</span><br><span class="line">    scheduler.start()</span><br><span class="line">    return scheduler</span><br></pre></td></tr></table></figure></p><h5>添加定时任务</h5><p>APScheduler将定时任务分为三种：</p><ul><li>interval: 比如每隔5分钟执行一次任务</li><li>cron: 比如每天早上5点执行一次任务</li><li>date: 比如在2018年5月5日执行一次任务</li></ul><p>我们以添加cron job为例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def test_job(name):</span><br><span class="line">    print &quot;hello, %s&quot; % name</span><br><span class="line">    </span><br><span class="line">def add_daily_job(name):</span><br><span class="line">    exec_time = datetime.now() + timedelta(minutes=2)</span><br><span class="line">    hour = exec_time.strftime(&quot;%H&quot;)</span><br><span class="line">    minute = exec_time.strftime(&quot;%M&quot;)</span><br><span class="line">    # 这里要选择&apos;cron&apos;</span><br><span class="line">    # 另外，job_id可以根据你自己的情况设定，其会被用于remove_job</span><br><span class="line">    current_app.scheduler.add_job(</span><br><span class="line">        test_job, &apos;cron&apos;, hour=hour, minute=minute,</span><br><span class="line">        args=[name], id=job_id)</span><br></pre></td></tr></table></figure></p><h5>删除定时任务</h5><p>通过在add_job时使用的job_id可以删除对应的定时任务。实际上在我们添加任务的时候，APScheduler会把相应的任务信息存储于我们jobstore中设置的持久化存储方案，这里使用的是MongoDB，然后当删除的时候会将相应的任务从MongoDB中删除。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def remove_daily_job(job_id):</span><br><span class="line">    current_app.scheduler.remove_job(job_id)</span><br></pre></td></tr></table></figure></p><h2>总结：</h2><p>APScheduler在实际使用过程中拥有最大的灵活性，可以满足我们的大部分定时任务的相关需求；Celery比较重量级，通常如果项目中已有Celery在使用，而且不需要动态添加定时任务时可以考虑使用；schedule非常轻量级，使用简单，但是不支持任务的持久化，也无法动态添加删除任务，所以主要用于简单的小型应用。</p><h2>References</h2><ul><li><a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">Schedule</a></li><li><a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a></li><li><a href="https://apscheduler.readthedocs.io/en/latest/" target="_blank" rel="noopener">APScheduler</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文详细讲述了在Python开发中常用的几种定时任务途径，并重点对比了schedule, Celery和APScheduler&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;p&gt;在Python开发过程中我们经常需要执行定时任务，而此类任务我们通常有如下选项：&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列4-数据矢量化</title>
    <link href="http://yoursite.com/2018/06/21/Pandas%E7%B3%BB%E5%88%974-%E6%95%B0%E6%8D%AE%E7%9F%A2%E9%87%8F%E5%8C%96/"/>
    <id>http://yoursite.com/2018/06/21/Pandas系列4-数据矢量化/</id>
    <published>2018-06-21T10:18:18.000Z</published>
    <updated>2018-08-12T10:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在处理数据问题时，经常会遇到的问题是要将原有数据进行转化，比如在原有数据的基础上+1操作，或者将原有数据的字符串全部转化为小写字符，更复杂的是要将原有数据的一部分提取出来使用。这些问题都是数据转化问题，即原有的数据不能直接使用，而要进一步转化后才能使用。</p><p>&lt;!--more--&gt;</p><h2>问题</h2><p>我们在处理数据问题时，经常会遇到的问题是要将原有数据进行转化，比如在原有数据的基础上+1操作，或者将原有数据的字符串全部转化为小写字符，更复杂的是要将原有数据的一部分提取出来使用。这些问题都是数据转化问题，即原有的数据不能直接使用，而要进一步转化后才能使用。</p><h2>示例</h2><p>这里举一个笔者在实际项目中遇到的例子来说明。</p><p>笔者项目中需要收集的app version信息，原始信息如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [167]: df</span><br><span class="line">Out[167]:</span><br><span class="line">        app_version  uid</span><br><span class="line">0  7.23.1-180522122    1</span><br><span class="line">1  7.20.1-180502135    2</span><br><span class="line">2  7.23.1-180522122    3</span><br><span class="line">3  7.23.1-180522122    4</span><br><span class="line">4  7.16.7-180411077    5</span><br></pre></td></tr></table></figure></p><p>但是实际上，我们只需要&quot;-&quot;之前的版本号，而且后续比较的时候要用'-'之前的数字进行比较，因此这样就涉及到了将原版本数据进行转化，即只提取'-'之前的数字，而舍弃后边的数字。</p><h4>迭代</h4><p>一个显而易见的做法是通过遍历的方式来逐行修改，如下图所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [178]: %%timeit</span><br><span class="line">     ...: for index, row in df.iterrows():</span><br><span class="line">     ...:     df.iloc[index, 0] = row[&apos;app_version&apos;].split(&apos;-&apos;)[0]</span><br><span class="line">     ...:</span><br><span class="line">2.34 ms ± 47.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span><br><span class="line"></span><br><span class="line">In [179]: df</span><br><span class="line">Out[179]:</span><br><span class="line">  app_version  uid</span><br><span class="line">0      7.23.1    1</span><br><span class="line">1      7.20.1    2</span><br><span class="line">2      7.23.1    3</span><br><span class="line">3      7.23.1    4</span><br><span class="line">4      7.16.7    5</span><br></pre></td></tr></table></figure></p><p>再进一步，我们可以使用apply方法，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [181]: df</span><br><span class="line">Out[181]:</span><br><span class="line">        app_version  uid</span><br><span class="line">0  7.23.1-180522122    1</span><br><span class="line">1  7.20.1-180502135    2</span><br><span class="line">2  7.23.1-180522122    3</span><br><span class="line">3  7.23.1-180522122    4</span><br><span class="line">4  7.16.7-180411077    5</span><br><span class="line"></span><br><span class="line">In [182]: %%timeit</span><br><span class="line">     ...: df[&apos;app_version&apos;] = df[&apos;app_version&apos;].apply(lambda x: x.split(&apos;-&apos;)[0])</span><br><span class="line">     ...:</span><br><span class="line">247 µs ± 11.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><br><span class="line"></span><br><span class="line">In [183]: df</span><br><span class="line">Out[183]:</span><br><span class="line">  app_version  uid</span><br><span class="line">0      7.23.1    1</span><br><span class="line">1      7.20.1    2</span><br><span class="line">2      7.23.1    3</span><br><span class="line">3      7.23.1    4</span><br><span class="line">4      7.16.7    5</span><br></pre></td></tr></table></figure></p><p>我们可以发现使用<code>apply</code>不仅使得代码更加简洁，而且速度也有了较明显的提升。但是以上方法本质上都是通过迭代的方式一条一条的修改，那么我们能否进一步提升性能呢？</p><h4>矢量化</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [197]: df</span><br><span class="line">Out[197]:</span><br><span class="line">        app_version  uid</span><br><span class="line">0  7.23.1-180522122    1</span><br><span class="line">1  7.20.1-180502135    2</span><br><span class="line">2  7.23.1-180522122    3</span><br><span class="line">3  7.23.1-180522122    4</span><br><span class="line">4  7.16.7-180411077    5</span><br><span class="line"></span><br><span class="line">In [198]: %%timeit</span><br><span class="line">     ...: df[&apos;app_version&apos;] = df[&apos;app_version&apos;].str.split(&apos;-&apos;).str.get(0)</span><br><span class="line">     ...:</span><br><span class="line">424 µs ± 11.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><br></pre></td></tr></table></figure></p><p>这里发现矢量化貌似不能提高性能啊，这是为什么？</p><blockquote><p>这里我猜测是由于我们的矢量化代码是分为两步操作，且在数据量较小的情况下就会显得慢</p></blockquote><p>为了验证这个假设，我做了如下实验：先将原数据concat为2560条记录，然后再计算时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2557  7.23.1-180522122    3</span><br><span class="line">2558  7.23.1-180522122    4</span><br><span class="line">2559  7.16.7-180411077    5</span><br><span class="line"></span><br><span class="line">[2560 rows x 2 columns]</span><br><span class="line"></span><br><span class="line">In [232]: df3 = df</span><br><span class="line"></span><br><span class="line">In [233]: %%timeit</span><br><span class="line">     ...: df[&apos;app_version&apos;] = df[&apos;app_version&apos;].apply(lambda x: x.split(&apos;-&apos;)[0])</span><br><span class="line">     ...:</span><br><span class="line">1.36 ms ± 35.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><br><span class="line"></span><br><span class="line"># 矢量化方式</span><br><span class="line">In [250]: %%timeit</span><br><span class="line">     ...: df[&apos;app_version&apos;] = df[&apos;app_version&apos;].str.split(&quot;-&quot;).str.get(0)</span><br><span class="line">     ...:</span><br><span class="line">2.61 ms ± 113 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span><br></pre></td></tr></table></figure></p><p>发现单纯的数据量增大并没有影响结果，那么用其它转化来测试下，这里获取字符串长度的转化进行实验<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [253]: %%timeit</span><br><span class="line">     ...: df[&apos;length&apos;] = df[&apos;app_version&apos;].str.len()</span><br><span class="line">     ...:</span><br><span class="line">901 µs ± 17.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><br><span class="line"></span><br><span class="line">In [254]: %%timeit</span><br><span class="line">     ...: df3[&apos;length&apos;] = df3[&apos;app_version&apos;].apply(lambda x: len(x))</span><br><span class="line">     ...:</span><br><span class="line">     ...:</span><br><span class="line">1.16 ms ± 14.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><br></pre></td></tr></table></figure></p><p>我们看到在这里就体现出了矢量化的优势，因为这里大家都是一步。</p><p>结论：当矢量化步数只有一步时，其性能还是要比apply方式好的，但当需要多步的时候，不一定好于apply方式。</p><p>那么，我们能否将其转化为一步呢？后发现有extract这样的函数，使用如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [312]: df</span><br><span class="line">Out[312]:</span><br><span class="line">        app_version  uid</span><br><span class="line">0  7.23.1-180522122    1</span><br><span class="line">1  7.20.1-180502135    2</span><br><span class="line">2  7.23.1-180522122    3</span><br><span class="line">3  7.23.1-180522122    4</span><br><span class="line">4  7.16.7-180411077    5</span><br><span class="line"></span><br><span class="line">In [313]: %%timeit</span><br><span class="line">     ...: df[&apos;app_version&apos;] = df[&apos;app_version&apos;].str.extract(r&quot;([0-9\.]+)-[0-9]+&quot;, expand=Fal</span><br><span class="line">     ...: se)</span><br><span class="line">     ...:</span><br><span class="line">247 µs ± 8.95 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><br></pre></td></tr></table></figure></p><p>通过<code>extract</code>终于实现了一步的矢量化。而且性能上也是最优的。</p><blockquote><p>这里需要注意的是，如果使用timeit, 由于多次操作，会导致后续df中'app_version'的值变为NaN。当我们只操作一次的时候则不存在此问题。</p></blockquote><h2>References</h2><ul><li><a href="https://pandas.pydata.org/pandas-docs/stable/text.html" target="_blank" rel="noopener">Working with text data</a></li><li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/03.10-working-with-strings.html" target="_blank" rel="noopener">Working with strings</a></li><li><a href="https://python.freelycode.com/contribution/detail/1083" target="_blank" rel="noopener">优化Pandas代码执行速度入门指南</a></li><li><a href="https://blog.csdn.net/u010814042/article/details/76401133" target="_blank" rel="noopener">Pandas 中map, applymap and apply的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在处理数据问题时，经常会遇到的问题是要将原有数据进行转化，比如在原有
数据的基础上+1操作，或者将原有数据的字符串全部转化为小写字符，更复杂的是
要将原有数据的一部分提取出来使用。这些问题都是数据转化问题，即原有的数据
不能直接使用，而要进一步转化后才能使用。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列3-DataFrame之增加与删除</title>
    <link href="http://yoursite.com/2018/06/16/Pandas%E7%B3%BB%E5%88%973-DataFrame%E4%B9%8B%E5%A2%9E%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2018/06/16/Pandas系列3-DataFrame之增加与删除/</id>
    <published>2018-06-16T10:18:18.000Z</published>
    <updated>2018-08-12T10:05:38.026Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Pandas的过程增删改查是频繁使用的操作，这一节主要就是展示DataFrame常用的增加和删除操作</p><p>&lt;!--more--&gt;</p><h2>增加行和增加列</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 增加一列，我们可以有两种方式，如下：</span><br><span class="line">In [345]: df</span><br><span class="line">Out[345]:</span><br><span class="line">   one  two</span><br><span class="line">a    0    1</span><br><span class="line">b    4    5</span><br><span class="line">c    8    9</span><br><span class="line">d   12   13</span><br><span class="line"></span><br><span class="line">In [346]: df[&apos;three&apos;] = [3, 5, 5, 7]</span><br><span class="line"></span><br><span class="line">In [347]: df</span><br><span class="line">Out[347]:</span><br><span class="line">   one  two  three</span><br><span class="line">a    0    1      3</span><br><span class="line">b    4    5      5</span><br><span class="line">c    8    9      5</span><br><span class="line">d   12   13      7</span><br><span class="line"></span><br><span class="line"># 或者使用loc</span><br><span class="line">In [369]: df</span><br><span class="line">Out[369]:</span><br><span class="line">   one  two  three</span><br><span class="line">a    0    1      2</span><br><span class="line">b    4    5      6</span><br><span class="line">c    8    9     10</span><br><span class="line">d   12   13     14</span><br><span class="line"></span><br><span class="line">In [370]: df.loc[:, &quot;four&quot;] = [1, 4, 5, 9]</span><br><span class="line"></span><br><span class="line">In [371]: df</span><br><span class="line">Out[371]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a    0    1      2     1</span><br><span class="line">b    4    5      6     4</span><br><span class="line">c    8    9     10     5</span><br><span class="line">d   12   13     14     9</span><br></pre></td></tr></table></figure></p><p>需要注意的是使用如上两种方式增加一列的时候，其数组的长度必须与原有DataFrame的行数相同，否则会报如下错误<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Length of values does not match length of index</span><br></pre></td></tr></table></figure></p><p>增加行同样我们也可以使用loc, 如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [376]: df</span><br><span class="line">Out[376]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a    0    1      2     3</span><br><span class="line">b    4    5      6     7</span><br><span class="line">c    8    9     10    11</span><br><span class="line">d   12   13     14    15</span><br><span class="line"></span><br><span class="line">In [377]: df.loc[&apos;e&apos;] = [3, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">In [378]: df</span><br><span class="line">Out[378]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a    0    1      2     3</span><br><span class="line">b    4    5      6     7</span><br><span class="line">c    8    9     10    11</span><br><span class="line">d   12   13     14    15</span><br><span class="line">e    3    7      8     9</span><br></pre></td></tr></table></figure></p><p>但很多时候，我们并不需要row index, 只想自动增加一行，那么可以通过如下的方式</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [379]: df.loc[df.shape[0]+1] = [3, 5, 9, 9]</span><br><span class="line"></span><br><span class="line">In [380]: df</span><br><span class="line">Out[380]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a    0    1      2     3</span><br><span class="line">b    4    5      6     7</span><br><span class="line">c    8    9     10    11</span><br><span class="line">d   12   13     14    15</span><br><span class="line">e    3    7      8     9</span><br><span class="line">6    3    5      9     9</span><br></pre></td></tr></table></figure></p><p>另外，我们还可以将数据转化为Series，然后利用concat或者append的方式将其与原有的DataFrame进行合并。这种方式不仅可以添加一行数据，也可以一次性添加多行数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [392]: df = pd.DataFrame(np.arange(16).reshape((4,4)), index=[1, 2, 3, 4], columns=[&apos;a&apos;,</span><br><span class="line">     ...:  &apos;b&apos;, &apos;c&apos;,&apos;d&apos;])</span><br><span class="line"></span><br><span class="line">In [393]: df2 = pd.DataFrame(np.arange(16).reshape((4,4)), index=[5, 6, 7, 8], columns=[&apos;a&apos;</span><br><span class="line">     ...: , &apos;b&apos;, &apos;c&apos;,&apos;d&apos;])</span><br><span class="line"></span><br><span class="line"># 这里相当于添加了多行数据</span><br><span class="line">In [394]: pd.concat([df, df2])</span><br><span class="line">Out[394]:</span><br><span class="line">    a   b   c   d</span><br><span class="line">1   0   1   2   3</span><br><span class="line">2   4   5   6   7</span><br><span class="line">3   8   9  10  11</span><br><span class="line">4  12  13  14  15</span><br><span class="line">5   0   1   2   3</span><br><span class="line">6   4   5   6   7</span><br><span class="line">7   8   9  10  11</span><br><span class="line">8  12  13  14  15</span><br></pre></td></tr></table></figure></p><p>更多关于concat和append将在后续的章节详细讲解。</p><h2>删除行和删除列</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">In [751]: df</span><br><span class="line">Out[751]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        30   blue   Steak     178    4.6    NY</span><br><span class="line">Nick         2  green    Lamb     181    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     178    9.0    FL</span><br><span class="line">Penelope     4  white   Apple     178    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     175    1.8    AK</span><br><span class="line">Christina   33  black   Melon     178    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans     178    2.2    TX</span><br><span class="line"></span><br><span class="line"># 使用drop删除index为&apos;Dean&apos;的行</span><br><span class="line">In [752]: df.drop([&apos;Dean&apos;])</span><br><span class="line">Out[752]:</span><br><span class="line">           age  color   food  height  score state</span><br><span class="line">Jane        30   blue  Steak     178    4.6    NY</span><br><span class="line">Nick         2  green   Lamb     181    8.3    TX</span><br><span class="line">Aaron       12    red  Mango     178    9.0    FL</span><br><span class="line">Penelope     4  white  Apple     178    3.3    AL</span><br><span class="line">Christina   33  black  Melon     178    9.5    TX</span><br><span class="line">Cornelia    69    red  Beans     178    2.2    TX</span><br><span class="line"></span><br><span class="line">In [749]: df</span><br><span class="line">Out[749]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        30   blue   Steak     178    4.6    NY</span><br><span class="line">Nick         2  green    Lamb     181    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     178    9.0    FL</span><br><span class="line">Penelope     4  white   Apple     178    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     175    1.8    AK</span><br><span class="line">Christina   33  black   Melon     178    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans     178    2.2    TX</span><br><span class="line"></span><br><span class="line"># 使用drop删除名为&apos;height&apos;的列，注意需要使用axis=1</span><br><span class="line"># 使用inplace来空值是在同一块内存还是copy</span><br><span class="line">In [750]: df.drop([&apos;height&apos;], axis=1, inplace=True)</span><br><span class="line">Out[750]:</span><br><span class="line">           age  color    food  score state</span><br><span class="line">Jane        30   blue   Steak    4.6    NY</span><br><span class="line">Nick         2  green    Lamb    8.3    TX</span><br><span class="line">Aaron       12    red   Mango    9.0    FL</span><br><span class="line">Penelope     4  white   Apple    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese    1.8    AK</span><br><span class="line">Christina   33  black   Melon    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans    2.2    TX</span><br><span class="line"></span><br><span class="line"># drop多列</span><br><span class="line">df.drop([&apos;height&apos;, &apos;food&apos;], axis=1, inplace=True)</span><br></pre></td></tr></table></figure></p><h2>条件删除</h2><p>由于在数据清洗的过程中经常需要删除不符合条件的record，所以以下这种条件过滤行就非常有用。<strong>需要注意的是，这里是重新生成了一个DataFrame，而不是直接在原有的DataFrame上修改</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [755]: df2 = df[df.color!=&apos;blue&apos;]</span><br><span class="line"></span><br><span class="line">In [756]: df2</span><br><span class="line">Out[756]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Nick         2  green    Lamb     181    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     178    9.0    FL</span><br><span class="line">Penelope     4  white   Apple     178    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     175    1.8    AK</span><br><span class="line">Christina   33  black   Melon     178    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans     178    2.2    TX</span><br></pre></td></tr></table></figure></p><h2>去重</h2><p>使用<code>drop_duplicates</code>，我们可以去掉重复项，这是一个非常有用的函数，下面我们来详细分析下</p><ul><li>通过参数subset,指定去重比较时用哪些column。如果不指定则所有的数据都会比较，只有所有列的数据都一致的时候才会去掉，否则不会去掉，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [459]: df_con2</span><br><span class="line">Out[459]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line">0  a1     1   4.0</span><br><span class="line">1  a2     3   5.0</span><br><span class="line">2  b1     5   7.0</span><br><span class="line">0  a1     2   4.0</span><br><span class="line">1  a2     5   NaN</span><br><span class="line">2  a3     2   2.0</span><br><span class="line"></span><br><span class="line">In [460]: df_drop = df_con2.drop_duplicates()</span><br><span class="line"></span><br><span class="line">In [461]: df_drop</span><br><span class="line">Out[461]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line">0  a1     1   4.0</span><br><span class="line">1  a2     3   5.0</span><br><span class="line">2  b1     5   7.0</span><br><span class="line">0  a1     2   4.0</span><br><span class="line">1  a2     5   NaN</span><br><span class="line">2  a3     2   2.0</span><br></pre></td></tr></table></figure></li></ul><p>我们可以让两个dataframe只比较uid列，只要这一列的数据重复，我们就认为重复，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [462]: df_drop2 = df_con2.drop_duplicates(subset=&apos;uid&apos;)</span><br><span class="line"></span><br><span class="line">In [463]: df_drop2</span><br><span class="line">Out[463]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line">0  a1     1   4.0</span><br><span class="line">1  a2     3   5.0</span><br><span class="line">2  b1     5   7.0</span><br><span class="line">2  a3     2   2.0</span><br></pre></td></tr></table></figure></p><ul><li>另外从上边的例子可以看出，其去重是去掉了后边出现的重复的项，我们也可以保留后边的项，将前边的项去掉，那么就需要使用keep参数。另外，我们也可以直接在DataFrame中进行去重，而不需要再另外copy一份数据，这可以通过<code>inplace=True</code>来实现，示例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [453]: df_con</span><br><span class="line">Out[453]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line">0  a1     1   4.0</span><br><span class="line">1  a2     3   5.0</span><br><span class="line">2  b1     5   7.0</span><br><span class="line">0  a1     2   4.0</span><br><span class="line">1  a2     5   NaN</span><br><span class="line">2  a3     2   2.0</span><br><span class="line"></span><br><span class="line"># 注意这里没有赋值操作，因为使用了inplace=True</span><br><span class="line"># 使用keep=&apos;last&apos;用于保存后边的数据，删除前边的重复项</span><br><span class="line">In [454]: df_con.drop_duplicates(subset=&apos;uid&apos;, keep=&apos;last&apos;, inplace=True)</span><br><span class="line"></span><br><span class="line">In [455]: df_con</span><br><span class="line">Out[455]:</span><br><span class="line">  uid  num1  num2</span><br><span class="line">2  b1     5   7.0</span><br><span class="line">0  a1     2   4.0</span><br><span class="line">1  a2     5   NaN</span><br><span class="line">2  a3     2   2.0</span><br></pre></td></tr></table></figure></li></ul><h2>References</h2><ul><li><a href="https://stackoverflow.com/questions/10715965/add-one-row-in-a-pandas-dataframe" target="_blank" rel="noopener">StackOverflow</a></li><li><a href="https://www.jianshu.com/p/67e67c7034f6" target="_blank" rel="noopener">删除行和列</a></li><li><a href="http://pandas.pydata.org/pandas-docs/stable/merging.html" target="_blank" rel="noopener">Merging</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Pandas的过程增删改查是频繁使用的操作，这一节主要就是展示DataFrame常用的增加和删除操作&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h2&gt;增加行和增加列&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列2-DataFrame之数据定位</title>
    <link href="http://yoursite.com/2018/06/15/Pandas%E7%B3%BB%E5%88%972-DataFrame%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/06/15/Pandas系列2-DataFrame之数据定位/</id>
    <published>2018-06-15T10:18:18.000Z</published>
    <updated>2018-08-12T10:05:16.900Z</updated>
    
    <content type="html"><![CDATA[<p>在Pandas中我们往往需要先定位数据才能进行相应的赋值、修改等后续操作，因此定位是Pandas中非常重要的一环，本文将详解Pandas中的各种定位方式。</p><p>&lt;!--more--&gt;</p><p>在Pandas中我们主要通过以下几个函数来定位DataFrame中的特定数据</p><ul><li>iloc</li><li>loc</li><li>iat</li><li>at</li></ul><p>总的来说，分为两种：</p><ol><li><p>一种是通过lables(即row index和column names，这里row index可以字符，日期等非数字index)(使用loc, at);</p></li><li><p>另一种通过index(这里特指数字位置index)(使用iloc, iat)</p></li></ol><p>loc和at的区别在于， loc可以选择特定的行或列，但是at只能定位某个特定的值，标量值。一般情况下，我们iloc和loc更加通用，而at, iat有一定的性能提升。</p><p>具体示例可以参考Reference中StackOverflow的示例下面展示一些特别的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">In [630]: df</span><br><span class="line">Out[630]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Jane        30   blue   Steak     165    4.6    NY</span><br><span class="line">Nick         2  green    Lamb      70    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     120    9.0    FL</span><br><span class="line">Penelope     4  white   Apple      80    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     180    1.8    AK</span><br><span class="line">Christina   33  black   Melon     172    9.5    TX</span><br><span class="line">Cornelia    69    red   Beans     150    2.2    TX</span><br><span class="line"></span><br><span class="line"># 选择某一行数据</span><br><span class="line">In [631]: df.loc[&apos;Dean&apos;]</span><br><span class="line">Out[631]:</span><br><span class="line">age           32</span><br><span class="line">color       gray</span><br><span class="line">food      Cheese</span><br><span class="line">height       180</span><br><span class="line">score        1.8</span><br><span class="line">state         AK</span><br><span class="line">Name: Dean, dtype: object</span><br><span class="line"></span><br><span class="line"># 选择某一列数据，逗号前面是行的label，逗号后边是列的label，使用&quot;:&quot;来表示选取所有的，本例是选取所有的行，当&apos;:&apos;在逗号后边时表示选取所有的列，但通常我们可以省略。</span><br><span class="line">In [241]: df.loc[:, &apos;color&apos;]</span><br><span class="line">Out[241]:</span><br><span class="line">Jane          blue</span><br><span class="line">Nick         green</span><br><span class="line">Aaron          red</span><br><span class="line">Penelope     white</span><br><span class="line">Dean          gray</span><br><span class="line">Christina    black</span><br><span class="line">Cornelia       red</span><br><span class="line">Name: color, dtype: object</span><br><span class="line"># 也可以如下选取一列，但是与前者是有区别的，具体参考Reference中的《Returning a view versus a copy》</span><br><span class="line">In [632]: df.loc[:][&apos;color&apos;]</span><br><span class="line">Out[632]:</span><br><span class="line">Jane          blue</span><br><span class="line">Nick         green</span><br><span class="line">Aaron          red</span><br><span class="line">Penelope     white</span><br><span class="line">Dean          gray</span><br><span class="line">Christina    black</span><br><span class="line">Cornelia       red</span><br><span class="line">Name: color, dtype: object</span><br><span class="line"></span><br><span class="line"># 选择某几行数据，注意无论选择多行还是多列，都需要将其label放在一个数组当中，而选择单个行或列，则不需要放在数组当中</span><br><span class="line">In [634]: df.loc[[&apos;Nick&apos;, &apos;Dean&apos;]]</span><br><span class="line">Out[634]:</span><br><span class="line">      age  color    food  height  score state</span><br><span class="line">Nick    2  green    Lamb      70    8.3    TX</span><br><span class="line">Dean   32   gray  Cheese     180    1.8    AK</span><br><span class="line"></span><br><span class="line"># 注意以下这种用法不行，这是由于Pandas会认为逗号后边是列的label</span><br><span class="line">df.loc[&apos;Nick&apos;, &apos;Dean&apos;]</span><br><span class="line"></span><br><span class="line"># 选择范围</span><br><span class="line">In [636]: df.loc[&apos;Nick&apos;:&apos;Christina&apos;]</span><br><span class="line">Out[636]:</span><br><span class="line">           age  color    food  height  score state</span><br><span class="line">Nick         2  green    Lamb      70    8.3    TX</span><br><span class="line">Aaron       12    red   Mango     120    9.0    FL</span><br><span class="line">Penelope     4  white   Apple      80    3.3    AL</span><br><span class="line">Dean        32   gray  Cheese     180    1.8    AK</span><br><span class="line">Christina   33  black   Melon     172    9.5    TX</span><br><span class="line"></span><br><span class="line"># iloc的特定用法, 可以用-1这样index来获取最后一行的数据</span><br><span class="line">In [637]: df.iloc[[1, -1]]</span><br><span class="line">Out[637]:</span><br><span class="line">          age  color   food  height  score state</span><br><span class="line">Nick        2  green   Lamb      70    8.3    TX</span><br><span class="line">Cornelia   69    red  Beans     150    2.2    TX</span><br></pre></td></tr></table></figure></p><p>数据定位是后续条件过滤、赋值以及各种转换的基础，一定要熟练掌握。</p><p>另外，在定位某一个具体的元素的时候，loc和at并不完全相同</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># loc支持以下两种定位方式</span><br><span class="line">In [726]: df.loc[&apos;Jane&apos;, &apos;score&apos;]</span><br><span class="line">Out[726]: 4.6</span><br><span class="line"></span><br><span class="line">In [727]: df.loc[&apos;Jane&apos;][&apos;score&apos;]</span><br><span class="line">Out[727]: 4.6</span><br><span class="line"></span><br><span class="line"># 但是at只支持第一种定位方式</span><br><span class="line">In [729]: df.at[&apos;Nick&apos;, &apos;height&apos;]</span><br><span class="line">Out[729]: 181</span><br><span class="line"></span><br><span class="line">In [730]: df.at[&apos;Nick&apos;][&apos;height&apos;]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-730-948408df1727&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 df.at[&apos;Nick&apos;][&apos;height&apos;]</span><br><span class="line"></span><br><span class="line">~/.pyenv/versions/3.6.4/envs/data_analysis/lib/python3.6/site-packages/pandas/core/indexing.py in __getitem__(self, key)</span><br><span class="line">   1867</span><br><span class="line">   1868         key = self._convert_key(key)</span><br><span class="line">-&gt; 1869         return self.obj._get_value(*key, takeable=self._takeable)</span><br><span class="line">   1870</span><br><span class="line">   1871     def __setitem__(self, key, value):</span><br><span class="line"></span><br><span class="line">TypeError: _get_value() missing 1 required positional argument: &apos;col&apos;</span><br></pre></td></tr></table></figure></p><p>有两点需要说明：</p><ul><li>在针对特定元素赋值的时候最好使用at来进行操作，性能提升还是很明显的。</li><li>loc的两种方式并不等同，<code>df.loc['Jane', 'score']</code>是在同一块内存中对数据进行操作，而<code>df.loc['Jane']['score']</code>是在另一个copy上进行操作，具体参考<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy" target="_blank" rel="noopener">Returning a view versus a copy</a></li></ul><h2>References</h2><ul><li><a href="https://stackoverflow.com/questions/28757389/loc-vs-iloc-vs-ix-vs-at-vs-iat" target="_blank" rel="noopener">StackOverflow: iloc vs. loc vs. iat vs. at</a></li><li><a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy" target="_blank" rel="noopener">Returning a view versus a copy</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Pandas中我们往往需要先定位数据才能进行相应的赋值、修改等后续操作，因此定位是Pandas中非常重要的一环，本文将详解Pandas中的各种定位方式。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;p&gt;在Pandas中我们主要通过以下几个函数来定位Data
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pandas系列1-DataFrame之初始化</title>
    <link href="http://yoursite.com/2018/06/08/Pandas%E7%B3%BB%E5%88%971-DataFrame%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2018/06/08/Pandas系列1-DataFrame之初始化/</id>
    <published>2018-06-08T10:18:18.000Z</published>
    <updated>2018-08-12T10:04:59.043Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas中如果要初始化DataFrame对象，实际又很多种方式，本文将详解Pandas初始化的几种不同方式。</p><p>&lt;!--more--&gt;</p><p>DataFrame有多种初始化方法，主要分为以下几种情况：</p><ul><li>通过Object初始化</li><li>通过文件初始化</li><li>通过SQL查询结果初始化</li><li>通过NoSQL数据库查询结果初始化</li></ul><p>下面分别介绍：</p><h2>通过object初始化</h2><p>这又分为以下几种方式</p><ul><li>Dict of 1D ndarrays, lists, dicts, or Series</li><li>2-D numpy.ndarray</li><li>Structured or record ndarray</li><li>A Series</li><li>Another DataFrame</li></ul><h4>通过list</h4><p>通过1D data series初始化的时候，如果有多列，那么需要等长<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># columns参数是通过一个list参数来指定column labels</span><br><span class="line">df = pd.DataFrame([[&apos;a1&apos;, 1], [&apos;a2&apos;, 4]], columns=[&apos;uid&apos;, &apos;score&apos;])</span><br><span class="line">In [477]: df</span><br><span class="line">Out[477]:</span><br><span class="line">  uid  score</span><br><span class="line">0  a1      1</span><br><span class="line">1  a2      4</span><br></pre></td></tr></table></figure></p><h4>通过Dict of 1D ndarray</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [298]: df = pd.DataFrame(&#123;&apos;col1&apos;: np.arange(3), &apos;col2&apos;: np.arange(5, 8)&#125;)</span><br><span class="line"></span><br><span class="line">In [299]: df</span><br><span class="line">Out[299]:</span><br><span class="line">   col1  col2</span><br><span class="line">0     0     5</span><br><span class="line">1     1     6</span><br><span class="line">2     2     7</span><br></pre></td></tr></table></figure></p><h4>通过Dict of lists</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [294]: df = pd.DataFrame(&#123;&apos;col1&apos;: [1, 2, 3, 4], &apos;col2&apos;: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]&#125;)</span><br><span class="line"></span><br><span class="line">In [295]: df</span><br><span class="line">Out[295]:</span><br><span class="line">   col1 col2</span><br><span class="line">0     1    a</span><br><span class="line">1     2    b</span><br><span class="line">2     3    c</span><br><span class="line">3     4    d</span><br></pre></td></tr></table></figure></p><h4>通过list of dicts</h4><p>注意与上边的dict of lists区分，如果最外层是dict，那么key值默认是column label。而在list of dicts中，每个dict都是一个record，或者说一行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 可以不等长，缺失值自动设为NaN</span><br><span class="line">In [49]: data2 = [&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;, &#123;&apos;a&apos;: 5, &apos;b&apos;: 10, &apos;c&apos;: 20&#125;]</span><br><span class="line"></span><br><span class="line">In [50]: pd.DataFrame(data2)</span><br><span class="line">Out[50]: </span><br><span class="line">   a   b     c</span><br><span class="line">0  1   2   NaN</span><br><span class="line">1  5  10  20.0</span><br><span class="line"></span><br><span class="line">In [51]: pd.DataFrame(data2, index=[&apos;first&apos;, &apos;second&apos;])</span><br><span class="line">Out[51]: </span><br><span class="line">        a   b     c</span><br><span class="line">first   1   2   NaN</span><br><span class="line">second  5  10  20.0</span><br><span class="line"></span><br><span class="line">In [52]: pd.DataFrame(data2, columns=[&apos;a&apos;, &apos;b&apos;])</span><br><span class="line">Out[52]: </span><br><span class="line">   a   b</span><br><span class="line">0  1   2</span><br><span class="line">1  5  10</span><br></pre></td></tr></table></figure></p><h4>通过Dict of Series</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In [314]: s = pd.Series(range(5))</span><br><span class="line"></span><br><span class="line">In [315]: s</span><br><span class="line">Out[315]:</span><br><span class="line">0    0</span><br><span class="line">1    1</span><br><span class="line">2    2</span><br><span class="line">3    3</span><br><span class="line">4    4</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [316]: p = pd.Series(range(8, 13))</span><br><span class="line"></span><br><span class="line">In [317]: p</span><br><span class="line">Out[317]:</span><br><span class="line">0     8</span><br><span class="line">1     9</span><br><span class="line">2    10</span><br><span class="line">3    11</span><br><span class="line">4    12</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [318]: df = pd.DataFrame(&#123;&apos;a&apos;: s, &apos;b&apos;: p&#125;)</span><br><span class="line"></span><br><span class="line">In [319]: df</span><br><span class="line">Out[319]:</span><br><span class="line">   a   b</span><br><span class="line">0  0   8</span><br><span class="line">1  1   9</span><br><span class="line">2  2  10</span><br><span class="line">3  3  11</span><br><span class="line">4  4  12</span><br></pre></td></tr></table></figure></p><h4>通过2-D numpy.ndarray</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [289]: df = pd.DataFrame(np.arange(16).reshape((4,4)), columns=[&apos;one&apos;, &apos;two&apos;, &apos;three&apos;,</span><br><span class="line">     ...:  &apos;four&apos;], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;,&apos;d&apos;])</span><br><span class="line"></span><br><span class="line">In [290]: df</span><br><span class="line">Out[290]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a    0    1      2     3</span><br><span class="line">b    4    5      6     7</span><br><span class="line">c    8    9     10    11</span><br><span class="line">d   12   13     14    15</span><br></pre></td></tr></table></figure></p><h2>通过文件初始化</h2><p>pandas通过各种数据文件也可以初始化，比如csv文件，excel文件，json文件，html文件等，详见下图<img src="https://upload-images.jianshu.io/upload_images/3959253-4ebb77efcd970e59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO Tools"></p><p>下面以<code>read_csv</code>详细解释下读取csv文件以及初始化的过程<code>read_csv</code>的完整文档参考<a href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.read_csv.html#pandas.read_csv" target="_blank" rel="noopener">read_csv api</a>，下面通过示例对常用的parameter进行解释：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csv_path = &quot;./test.csv&quot;</span><br><span class="line">columns = [&apos;id&apos;, &apos;name&apos;, &apos;age&apos;]</span><br><span class="line">dtype = &#123;&apos;id&apos;: int, &apos;name&apos;: object, &apos;age&apos;: int&#125;</span><br><span class="line">pd.read_csv(csv_path, header=None, names=columns, dtype=dtype)</span><br></pre></td></tr></table></figure></p><ul><li>filepath_or_buffer, 这个是最基本的参数，用以指明文件的路径(路径可以是字符串，也可以是各种path对象，详见文档)或者文件对象(也可以接收类文件对象, 即提供read method， 如StringIO对象)。另外，这个参数也可以是一个URL，而这个URL可以http, ftp, 或者s3的url.</li></ul><blockquote><p>对于没有权限限制的url，直接使用read_csv可以大大简化代码，但是通过我们的数据不会放置到公开的url地址上，因此这就涉及权限的问题，通常还是通过其它手段将文件下载到本地后再读取。</p></blockquote><ul><li>header, 这个参数用于设置第几行为column names, 默认是'infer'，即Pandas会自动推断哪一行是column names。当文件中没有column names时，相当于设定header=0。很多时候想要忽略原始的column names而自己设定column names，那么可以将这个参数设置为None, 然后通过names参数来设定column names</li><li>names, 用于设定column names</li><li>dtype, 用于设定每一列对应的数据类型，需要注意的是对string类型需要设置为object</li><li>nrows, 要读取多少行，通过这个参数我们可以部分读取文件</li><li>usecols, 用于选定列，即指定哪些列load进DataFrame中，通过这个参数可以只读取我们需要的数据，从而减少内存占用，加快load速度。</li></ul><h2>通过SQL查询结果初始化</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pandas.io.sql as sql</span><br><span class="line"></span><br><span class="line"># conn是数据库的连接对象</span><br><span class="line">sql.read_frame(&apos;select * from test&apos;, conn)</span><br></pre></td></tr></table></figure></p><h2>NoSQL查询结果初始化</h2><p>这里以MongoDB为例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 从MongoDB中查询年龄大于20岁的用户，查询返回一个cursor对象</span><br><span class="line">user_results = user.find(&#123;&quot;age&quot;: &#123;&quot;$gt&quot;: 20&#125;&#125;)</span><br><span class="line"></span><br><span class="line"># 将cursor对象转化为list，然后初始化</span><br><span class="line"># columns可以用于选取相应的field的数据，只有在这个列表中的field才会被load进DataFrame对象当中，如果没有对应的数据，会被填入NaN</span><br><span class="line">df = pd.DataFrame(list(user_results), columns=[&apos;id&apos;, &apos;age&apos;, &apos;name&apos;]</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是如果不指定columns参数，有可能导致某些为空的field没有对应的列，如果指定了列名称，则如果相对应的域没有数据的话，就会自动置为nan</p><h2>References</h2><ul><li><a href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.read_csv.html#pandas.read_csv" target="_blank" rel="noopener">read_csv API</a></li><li><a href="https://pandas.pydata.org/pandas-docs/version/0.22/io.html#io-read-csv-table" target="_blank" rel="noopener">IO Tools</a></li><li>《利用Python进行数据分析》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pandas中如果要初始化DataFrame对象，实际又很多种方式，本文将详解Pandas初始化的几种不同方式。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;p&gt;DataFrame有多种初始化方法，主要分为以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过Obj
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB大批量读写数据优化记录</title>
    <link href="http://yoursite.com/2018/04/20/MongoDB%E5%A4%A7%E6%89%B9%E9%87%8F%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/04/20/MongoDB大批量读写数据优化记录/</id>
    <published>2018-04-20T10:18:18.000Z</published>
    <updated>2018-08-12T10:07:41.645Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要阐述了MongoDB大批量数据读写过程中的一些优化技巧</p><p>&lt;!--more--&gt;</p><h2>用批量写入代替单个写入</h2><p>最开始，我的代码逻辑是这样的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for uid, data in user_dict.items():</span><br><span class="line">    user_collection.insert_one(&#123;&apos;uid&apos;:uid, &apos;user_data&apos;: data&#125;)</span><br></pre></td></tr></table></figure></p><p>这种方法在数据量较小时可以很好的工作，但是当数据量非常大时，此种操作会非常慢，我们需要通过批量写入的方式来写入数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_data = (&#123;&apos;uid&apos;: uid, &apos;user_data&apos;: data&#125; for uid, data in user_dict.items())</span><br><span class="line">user_collection.insert_many(user_data)</span><br></pre></td></tr></table></figure></p><h2>调整insert_many参数</h2><p>再来看是否可以通过调整insert_many参数来进一步优化性能。</p><ul><li>ordered: 这个参数为True时，迫使MongoDB按顺序同步插入数据；而如果为False，则MongoDB会并发的不按固定顺序进行批量插入。显然当我们对性能有要求时，将该参数设为False是非常必要的。</li><li>bypass_document_validation: MongoDB3.2之后加入了document validation功能，用于验证写入的文档是否符合collection制定的规则，具体可以参考reference中的链接。而既然是验证就肯定需要花费时间，当我们对性能有极致要求时，也可以将此参数设为True，从而越过验证，直接写入。</li><li>session: 关于session，请参考References中的Client Session链接。</li></ul><p>修改后的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_data = (&#123;&apos;uid&apos;: uid, &apos;user_data&apos;: data&#125; for uid, data in user_dict.items())</span><br><span class="line">user_collection.insert_many(user_data, ordere=False, bypass_document_validation=True)</span><br></pre></td></tr></table></figure></p><p>最终性能的提升是非常明显的，时间量级从天降为分钟。</p><h2>批量更新</h2><p>前面的例子在插入操作时非常有效，但是对于更新操作由于update_many无法针对每一个doc进行更新，如本例中针对每一个uid进行更新，那么就需要使用<code>bulk_write</code>操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import UpdateOne</span><br><span class="line"></span><br><span class="line">update_operations = []</span><br><span class="line">for uid, user_data in user_dict.items():</span><br><span class="line">    op = UpdateOne(&#123;&apos;uid&apos;: uid&#125;, &#123;&apos;$set&apos;: &#123;&apos;user_data&apos;: user_data&#125;&#125;, upsert=True)</span><br><span class="line">    update_operations.append(op)</span><br><span class="line"></span><br><span class="line">user_collection.bulk_write(update_operations, ordered=False, bypass_document_validation=True)</span><br></pre></td></tr></table></figure></p><h2>批量读取</h2><p>批量读取我们可以使用<code>$in</code>操作符，但是需要注意的是如果<code>$in</code>针对的list过大，那么可能会导致报错<code>pymongo.errors.DocumentTooLarge</code>, 目前我的做法是将大的list分割成1000个一段，然后分段查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list_length = len(uid_list)</span><br><span class="line">iter_size = 1000</span><br><span class="line">current = 0</span><br><span class="line">while current &lt; list_length:</span><br><span class="line">    end = current + iter_size</span><br><span class="line">    uid_segment = uid_list[current: end]</span><br><span class="line">    result_cursor = mongo_collection.find(&#123;&quot;uid&quot;: &#123;&quot;$in&quot;: uid_segment&#125;&#125;)</span><br><span class="line">    for user_info in result_cursor:</span><br><span class="line">        # do something</span><br><span class="line">        ...</span><br><span class="line">    current = current + iter_size</span><br></pre></td></tr></table></figure></p><h2>异常处理</h2><p>在实践过程中，会遇到异常的情况，尤其是写入的时候，可能由于各种原因导致写入失败，因此需要catch exception，并打印详细信息，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    user_collection.insert_many(</span><br><span class="line">        data_iter, ordered=False, bypass_document_validation=True)</span><br><span class="line">except BulkWriteError as e:</span><br><span class="line">    lg.error(e.details)</span><br></pre></td></tr></table></figure></p><h2>References:</h2><ul><li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html" target="_blank" rel="noopener">PyMongo API</a></li><li><a href="http://www.shangyang.me/2017/08/22/mongodb-basic-09-document-validation/" target="_blank" rel="noopener">MongoDB document validation</a></li><li><a href="https://docs.mongodb.com/manual/core/read-isolation-consistency-recency/#sessions" target="_blank" rel="noopener">Client Session</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要阐述了MongoDB大批量数据读写过程中的一些优化技巧&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h2&gt;用批量写入代替单个写入&lt;/h2&gt;
&lt;p&gt;最开始，我的代码逻辑是这样的：
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在Flask中使用Celery的最佳实践</title>
    <link href="http://yoursite.com/2018/02/22/flask_celery/"/>
    <id>http://yoursite.com/2018/02/22/flask_celery/</id>
    <published>2018-02-22T10:18:18.000Z</published>
    <updated>2018-08-12T10:10:02.073Z</updated>
    
    <content type="html"><![CDATA[<p>主要是笔者在项目实践中总结的关于Celery使用的一些最佳实践，欢迎补充</p><p>&lt;!--more--&gt;</p><h2>写在前面</h2><p>本最佳实践是基于作者有限的经验，欢迎大家共同讨论，可以持续维护此最佳实践。另本文中所使用的环境为Mac&amp;Ubuntu环境，软件版本如下：</p><ul><li>Celery (4.1.0)</li><li>Flask (0.12.1)</li><li>RabbitMQ(3.6.9)</li><li>librabbitmq (1.6.1)</li></ul><h2>介绍</h2><p>简单来说Celery是一个异步的任务队列，当我们需要将一些任务(比如一些需要长时间操作的任务)异步操作的时候，这时候Celery就可以帮到我们，另外Celery还支持定时任务(类似Crontab)。详细的介绍可以参考<a href="http://www.celeryproject.org/" target="_blank" rel="noopener">官网</a></p><h2>使用RabbitMQ作为Broker</h2><p>RabbitMQ是官方推荐使用的Broker，它实际是一个消息中间件，负责消息的路由分发，安装RabbitMQ如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># install on Ubuntu</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install rabbitmq-server -yq</span><br></pre></td></tr></table></figure></p><p>需要注意的是，线上环境我们需要创建新的账号，并将guest账号删除，操作如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user myuser mypassword  # 新增用户</span><br><span class="line">rabbitmqctl add_vhost myvhost  # 新增vhost，以使用不同的命名空间</span><br><span class="line">rabbitmqctl set_permissions -p myvhost myuser &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;  # 设置权限</span><br><span class="line">rabbitmqctl  delete_user guest  # 安全原因，删除guest</span><br></pre></td></tr></table></figure></p><p>注意：vhost是一个虚拟空间，用于区分不同类型的消息然后，在Celery的配置中配置broker URL<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CELERY_BROKER_URL = &apos;amqp://myuser:mypassword@localhost:5672/myvhost&apos;</span><br></pre></td></tr></table></figure></p><p>注意：当使用amqp协议头时，如果安装有<code>librabbitmq</code>则使用<code>librabbitmq</code>，否则使用pyamqp</p><h2>Celery的日志输出</h2><p>在task中想要输出日志，最好的方法是通过如下方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from celery.utils.log import get_task_logger</span><br><span class="line"></span><br><span class="line">lg = get_task_logger(__name__)</span><br><span class="line"></span><br><span class="line">@celery.task</span><br><span class="line">def log_test():</span><br><span class="line">    lg.debug(&quot;in log_test()&quot;)</span><br></pre></td></tr></table></figure></p><p>但是仅如此会发现所有的日志最后都跑到shell窗口的stdout当中，原来必须得在启动celery的时候使用-f option来指定输出文件，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A main.celery worker -l debug -f log/celery/celery_task.log &amp;</span><br></pre></td></tr></table></figure></p><p>-A：指定celery实例worker: 启动worker进程-l：指定log level，这里指定log level为debug level-f：指定输出的日志文件</p><h2>使用Redis作为backend</h2><p>当使用Redis作为存储后端的时候，我们可以通过设置DB number来使得Celery的结果存储与其它数据存储隔离开来，比如在笔者的项目中，redis还用作缓存的存储后端，因此为了区分，Celery在使用Redis的时候使用的DB number是1（默认是0），关于Redis DB number可以参考<a href="http://blog.teeceepee.com/blog/2015/02/14/redis-db-number/" target="_blank" rel="noopener">这里</a>.因此我们的backend设置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CELERY_RESULT_BACKEND = &apos;redis://localhost:6379/1&apos; # 最后的数字1代表DB number</span><br></pre></td></tr></table></figure></p><p>查看Celery任务的结果可以通过Redis-cli连接Redis数据库进行查看<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-cli</span><br><span class="line">&gt; select 1 # 这里选择DB 1， 也可以在使用redis-cli -n 1来进入指定的DB</span><br><span class="line">&gt; get key # 获取指定key对应的结果</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-5674ca727b61be6d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis-cli.jpg"></p><h2>调试代码</h2><p>我认为此处是非常重要的一个技巧，即在调试代码的时候，我们可以将<code>delay</code>或者<code>apply_async</code>先去掉，直接调用worker的函数进行同步调试，调试成功后再加上<code>delay</code>或者<code>apply_async</code> method</p><h2>Celery可能会遇到的坑</h2><h4>Celery4.x版本使用librabbitmq的问题</h4><p>Celery 4.x版本在使用librabbitmq时，会出现类似这样的错误<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Received and deleted unknown message.  Wrong destination?!?</span><br></pre></td></tr></table></figure></p><p>完整错误如图：<img src="http://upload-images.jianshu.io/upload_images/3959253-43eac6585498fc34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="celeryerror"></p><p>解决这个问题有两个方式：</p><ol><li>推荐方式，更改配置项<em>task_protocol</em>为1。Github上Robert Kopaczewski详细解释了这个问题，原文如下：</li></ol><blockquote><p>Apparently librabbitmq issue is related to new default protocol in celery 4.x. You can switch to previous protocol version by either putting CELERY_TASK_PROTOCOL = 1 in your settings if you're using Django or settings app.conf.task_protocol = 1 in celeryconf.py.</p></blockquote><ol start="2"><li>另一种方式是不使用librabbitmq, 通过pip uninstall librabbitmq, 并且更改broker配置的协议头为'pyamqp',如下，也可以解决这个问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = &apos;pyamqp://guest:guest@localhost:5672/%2F&apos;</span><br></pre></td></tr></table></figure></li></ol><p>由于librabbitmq的性能优势，我们还是推荐方式1来解决该问题。</p><h4>RabbitMQ远程连接问题</h4><p>如果RabbitMQ与Celery不在同一台机器上，除在Celery配置的时候要将<code>BROKER_URL</code>设置为正确的IP地址外，还需要将Rabbitmq的配置文件<code>/usr/local/etc/rabbitmq/rabbitmq-env.conf</code>中的<code>NODE_IP_ADDRESS</code>更改为0.0.0.0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_IP_ADDRESS=0.0.0.0</span><br></pre></td></tr></table></figure></p><h4>Celery import问题</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">The message has been ignored and discarded.</span><br><span class="line"></span><br><span class="line">Did you remember to import the module containing this task?</span><br><span class="line">Or maybe you&apos;re using relative imports?</span><br><span class="line"></span><br><span class="line">Please see</span><br><span class="line">http://docs.celeryq.org/en/latest/internals/protocol.html</span><br><span class="line">for more information.</span><br><span class="line"></span><br><span class="line">The full contents of the message body was:</span><br><span class="line">&apos;\x8e\xa7expires\xc0\xa3utc\xc3\xa4args\x91\x85\xa3tid\xb85971a43d47f84bb278f77fc2\xa3sen\xa2A1\xa2tt\xa2ar\xa2co\xc4\x00\xa1t\xa4like\xa5chord\xc0\xa9callbacks\xc0\xa8errbacks\xc0\xa7taskset\xc0\xa2id\xc4$c133dbf8-2c89-4311-b7cf-c377041058ec\xa7retries\x00\xa4task\xd9$tasks.messageTasks.send_like_message\xa5group\xc0\xa9timelimit\x92\xc0\xc0\xa3eta\xc0\xa6kwargs\x80&apos; (239b)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/liufeng/.pyenv/versions/2.7.13/envs/kaopu_backend/lib/python2.7/site-packages/celery/worker/consumer/consumer.py&quot;, line 561, in on_task_received</span><br><span class="line">    strategy = strategies[type_]</span><br><span class="line">KeyError: u&apos;tasks.messageTasks.send_like_message&apos;</span><br></pre></td></tr></table></figure></p><p>出现这条错误是由于我们的tasks跟celery并不是在同一个文件中，即不是同一个module，当我们通过如下命令启动task worker时，实际只加载了app module，而没有加载tasks相关的module<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">celery -A app.celery worker -l info</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>要解决这个问题，必须为celery配置文件添加import参数，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config[&apos;imports&apos;] = [&apos;tasks.messageTasks&apos;]</span><br></pre></td></tr></table></figure></p><h4>Celery unregistered task问题</h4><p>在开发过程中遇到了这样一个问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[2017-08-31 15:38:19,605: ERROR/MainProcess] Received unregistered task of type u&apos;app.tasks.messageTasks.send_follow_message&apos;.</span><br><span class="line">The message has been ignored and discarded.</span><br><span class="line"></span><br><span class="line">Did you remember to import the module containing this task?</span><br><span class="line">Or maybe you&apos;re using relative imports?</span><br><span class="line"></span><br><span class="line">Please see</span><br><span class="line">http://docs.celeryq.org/en/latest/internals/protocol.html</span><br><span class="line">for more information.</span><br><span class="line"></span><br><span class="line">The full contents of the message body was:</span><br><span class="line">&apos;\x8e\xa7expires\xc0\xa3utc\xc3\xa4args\x91\x86\xa6sender\xa5Jenny\xa9target_id\xb859a5313847f84be534ad7d46\xabtarget_type\xa4user\xa7content\xc4\x00\xa8receiver\xb859a5313847f84be534ad7d46\xa4type\xa6follow\xa5chord\xc0\xa9callbacks\xc0\xa8errbacks\xc0\xa7taskset\xc0\xa2id\xc4$a4d40c14-1976-41a6-a753-d2a495929920\xa7retries\x00\xa4task\xd9*app.tasks.messageTasks.send_follow_message\xa5group\xc0\xa9timelimit\x92\xc0\xc0\xa3eta\xc0\xa6kwargs\x80&apos; (312b)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/liufeng/.pyenv/versions/2.7.13/envs/kaopu_backend/lib/python2.7/site-packages/celery/worker/consumer/consumer.py&quot;, line 561, in on_task_received</span><br><span class="line">    strategy = strategies[type_]</span><br><span class="line">KeyError: u&apos;app.tasks.messageTasks.send_follow_message&apos;</span><br></pre></td></tr></table></figure></p><p>解决这个问题，最开始是根据提示，将所有涉及到task的module全部加上<code>from __future__ import absolute_import</code> 之后运行之后还是不行，后来发现是由于之前启动时使用的是app module， 但是我的代码已经改成了main.py，所以重新启动了celery，最后问题解决</p><h4>使用镜像迁移系统也依然需要重新添加rabbitmq的用户</h4><p>问题最开始是发现无法点赞，也无法Follow用户，通过http消息发现出现502错误，于是登录到服务器检查，发现应用服务本身没有任何报错，于是又去查看Celery的日志，结果发现出现如下错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2017-11-13 16:32:01,243: ERROR/MainProcess] consumer: Cannot connect to amqp://celeryuser:**@loc      alhost:5672/celeryvhost: Couldn&apos;t log in: a socket error occurred.</span><br></pre></td></tr></table></figure></p><p>经过一番搜索发现网上的评论主要是说URL不对的情况下会出现这种情况，但是我的URL没有改过啊，那又会是什么问题呢？继续看，发现有人提到了权限问题，于是又是一番检查，发现RabbitMQ中并没有原先设置的用户（我使用的是原系统的镜像，原以为用户也是已经设置好的）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看有哪些用户</span><br><span class="line">rabbitmqctl  list_users</span><br></pre></td></tr></table></figure></p><p>然后就简单了，按照步骤创建用户，vhost，再赋予权限，删除guest，然后就终于都连好了</p><p>另外，发现从镜像复制系统后，RabbitMQ并不能正常工作，必须杀掉原先的进程，重新启动</p><h4>更改task的代码后，重启Celery</h4><p>需要注意的是，在更改task的代码后，必须重新启动Celery，否则代码改动无法生效，可能导致一些意外的问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是笔者在项目实践中总结的关于Celery使用的一些最佳实践，欢迎补充&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本最佳实践是基于作者有限的经验，欢迎大家共同讨论，可以持续维护此最佳实践。另本文中所使用的环境为Mac&amp;am
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python collections.deque vs. Queue.Queue vs. multiprocessing.Queue</title>
    <link href="http://yoursite.com/2018/02/12/Python-collections-deque-vs--Queue-Queue-vs--multiprocessing-Queue/"/>
    <id>http://yoursite.com/2018/02/12/Python-collections-deque-vs--Queue-Queue-vs--multiprocessing-Queue/</id>
    <published>2018-02-12T10:18:18.000Z</published>
    <updated>2018-08-12T10:08:41.412Z</updated>
    
    <content type="html"><![CDATA[<p>总体上来说，当需要在进程间通信的时候需要使用multiprocessing.Queue; 当在同一个进程当中，而需要多线程之间通信的时候，可以使用Queue.Queue；而至于collections.deque一般就是在同一个线程当中，作为一种数据结构来使用的。下面分别讲述一下它们的用法：</p><p>&lt;!--more--&gt;</p><h3>multiprocessing.Queue</h3><p>multiprocessing提供了两种进程间通信机制，一种是我们要说的Queue，另外一种是Pipe。而实际上Queue也是通过Pipe来实现的。具体可以参考<a href="https://docs.python.org/2/library/multiprocessing.html#exchanging-objects-between-processes" target="_blank" rel="noopener">进程间通信</a>Queue常用methods：</p><ul><li>Queue.qsize(): 返回queue中item的数量，注意这个数量并不准确,  not reliable</li><li>Queue.empty(): return True if queue is empty,  not reliable</li><li>Queue.full(): return True if queue is full,  not reliable</li><li>Queue.put(item[, block[, timeout]]): block表示是否阻塞，默认为True即阻塞，如果设定了timeout，则阻塞timeout时长，如果仍然没有空余的slot，则raise Queue.full exception。如果block=False，那么就不阻塞，当queue full时，直接报Queue.full exception。</li><li>Queue.put_nowait(item): Equivalent to put(item, False)</li><li>Queue.get([block[, timeout]])</li><li>Queue.get_nowait(): Equivalent to get(False)</li></ul><p>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line"></span><br><span class="line">def f(q):</span><br><span class="line">    q.put([42, None, &apos;hello&apos;])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=f, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    print q.get()    # prints &quot;[42, None, &apos;hello&apos;]&quot;</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><p><strong>需要注意的是Queue不提供join()和task_done()，因此在producer process中无法确保所有的task均已经被处理, 如果需要join and task_done就需要使用multiprocessing.JoinableQueue，详情参看<a href="https://docs.python.org/2/library/multiprocessing.html?highlight=multiprocessing#multiprocessing.JoinableQueue" target="_blank" rel="noopener">JoinableQueue</a></strong></p><h3>Queue.Queue</h3><p>Queue.Queue通常用于同一个进程中的不同线程间的通信，其提供的方法与multiprocessing.Queue类似，但是多出了两个methods如下：</p><ul><li>task_done(): 用于告知任务完成</li><li>join(): 用于等待队列中所有的任务完成。具体使用见下图<img src="http://upload-images.jianshu.io/upload_images/3959253-0e780f8002f768ac.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="queue"></li></ul><h3>collections.deque</h3><p>主要用于队列这种数据结构，通过append和popleft来实现队列的FIFO机制。常用方法如下：</p><ul><li>extendleft</li><li>appendleft</li><li>popleft</li><li>extend</li><li>append</li><li>pop具体参考<a href="https://docs.python.org/2/library/collections.html?highlight=deque#deque-objects" target="_blank" rel="noopener">官网</a>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; d = deque(&apos;ghi&apos;)                 # make a new deque with three items</span><br><span class="line">&gt;&gt;&gt; for elem in d:                   # iterate over the deque&apos;s elements</span><br><span class="line">...     print elem.upper()</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">I</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d.append(&apos;j&apos;)                    # add a new entry to the right side</span><br><span class="line">&gt;&gt;&gt; d.appendleft(&apos;f&apos;)                # add a new entry to the left side</span><br><span class="line">&gt;&gt;&gt; d                                # show the representation of the deque</span><br><span class="line">deque([&apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d.pop()                          # return and remove the rightmost item</span><br><span class="line">&apos;j&apos;</span><br><span class="line">&gt;&gt;&gt; d.popleft()                      # return and remove the leftmost item</span><br><span class="line">&apos;f&apos;</span><br><span class="line">&gt;&gt;&gt; list(d)                          # list the contents of the deque</span><br><span class="line">[&apos;g&apos;, &apos;h&apos;, &apos;i&apos;]</span><br><span class="line">&gt;&gt;&gt; d[0]                             # peek at leftmost item</span><br><span class="line">&apos;g&apos;</span><br><span class="line">&gt;&gt;&gt; d[-1]                            # peek at rightmost item</span><br><span class="line">&apos;i&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; list(reversed(d))                # list the contents of a deque in reverse</span><br><span class="line">[&apos;i&apos;, &apos;h&apos;, &apos;g&apos;]</span><br><span class="line">&gt;&gt;&gt; &apos;h&apos; in d                         # search the deque</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; d.extend(&apos;jkl&apos;)                  # add multiple elements at once</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">deque([&apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;])</span><br><span class="line">&gt;&gt;&gt; d.rotate(1)                      # right rotation</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">deque([&apos;l&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;])</span><br><span class="line">&gt;&gt;&gt; d.rotate(-1)                     # left rotation</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">deque([&apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; deque(reversed(d))               # make a new deque in reverse order</span><br><span class="line">deque([&apos;l&apos;, &apos;k&apos;, &apos;j&apos;, &apos;i&apos;, &apos;h&apos;, &apos;g&apos;])</span><br><span class="line">&gt;&gt;&gt; d.clear()                        # empty the deque</span><br><span class="line">&gt;&gt;&gt; d.pop()                          # cannot pop from an empty deque</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in -toplevel-</span><br><span class="line">    d.pop()</span><br><span class="line">IndexError: pop from an empty deque</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d.extendleft(&apos;abc&apos;)              # extendleft() reverses the input order</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">deque([&apos;c&apos;, &apos;b&apos;, &apos;a&apos;])</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总体上来说，当需要在进程间通信的时候需要使用multiprocessing.Queue; 当在同一个进程当中，而需要多线程之间通信的时候，可以使用Queue.Queue；而至于collections.deque一般就是在同一个线程当中，作为一种数据结构来使用的。下面分别讲述
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB Sharding</title>
    <link href="http://yoursite.com/2018/02/03/MongoDB-Sharding/"/>
    <id>http://yoursite.com/2018/02/03/MongoDB-Sharding/</id>
    <published>2018-02-03T10:18:18.000Z</published>
    <updated>2018-08-12T10:07:28.933Z</updated>
    
    <content type="html"><![CDATA[<p>详细介绍MongoDB sharding</p><p>&lt;!--more--&gt;</p><h2>介绍</h2><h2>Sharding Key</h2><ul><li>Sharding key必须是在对应的collection当中所有的文档都存在的field，比如我要sharding我的user collection，我就可以找nick_name这种所有documents中都存在的field来做为sharding key，当然还要考虑其它因素，但是这个是一个必要条件。</li><li>sharding key可以一个或者多个fields组成，还以user document为例，除了可以使用nick_name还可以加一个created time一起作为sharding key。当然具体使用什么field要根据系统的实际情况来综合考虑。</li><li>sharding只能有一个，而且设定后不可更改</li><li>针对已经有数据的collections做sharding时，原collections必须有以sharding key开头的索引；如果是空的collection，则MongoDB会自动创建对应的索引</li></ul><h2>Sharding的优势</h2><h3>读写效率</h3><p>由于我们可以将相应的写操作分布在不同的shard上，可以更加均匀分担写压力，因此写的性能一般情况下会得到提高。读取操作时，如果query中包含shard key对应的field，或者以这个field为prefix的compound index key</p><h3>存储容量</h3><p>由于是水平分割，因此几乎可以无限扩容，不需要担心某个collection过大而无法单机存储的问题</p><h3>高可用</h3><p>从MongoDB3.2开始，config server已经支持replicaset模式，这样的话sharding节点和config节点均可以通过replicaset来保证高可用。</p><h2>关于Sharding的考虑</h2><p>由于sharding的不可逆性，所以最好是先不使用sharding，在业务运行一段时间后，根据业务的情况来做决定，这主要需要考虑如下因素：</p><ul><li>某个collection的数据是否非常大，达到未来可能一台机器的存储容量都无法解决该collection的存储。</li><li>是否有些collection存在性能问题，希望通过sharding来解决</li><li>由于具有不可逆性，我们可以只针对需要做sharding的collection做sharding，而其它collection不需要sharding。不做sharding的collection会存储于primary shard之上（所以可见这个shard应该有更大的容量）</li><li>针对需要分片的collection，需要确定满足以下几个条件：<ul><li>选取的key可以使得collection的数据能均衡地分布在不同的shard上</li><li>写请求的时候也能均匀分布，比如时间戳作为key时，虽然也能将key均匀分布到不同的shard上，但是同一时间段，写请求就会持续在一个shard上，这样就不是均匀写了</li><li>我们针对该collection的查询主要是使用哪个field来作为查询条件，那么这个field最好是作为shard key</li><li>作为sharding key的field需要有索引，或者是作为compound索引的prefix。</li><li>尽量避免会导致jumbo chunk的key，比如通过age来作为key，同一个age的数据均会放到同一个chunk，这就可能导致chunk不断变大，当超过chunk size时，就会变成jumbo chunk</li></ul></li></ul><h2>Sharding策略</h2><p>Sharding有两种策略：一种是ranged sharding; 另一种是hashed sharding。</p><ul><li>如果选择的key，其值域非常接近，尤其是单调递增或者递减(increase or decrease monotonically, 也可以翻译成单向递增递减)，就会导致所有的新增操作都会集中在最大的range的shard上（如果是递增）；或者集中在最小range的那个shard上（如果是递减）。这就导致无法均匀地进行写操作（因为所有的写操作都集中在一个shard甚至一个chunk上）。而那个最大或最小range的shard将成为系统的瓶颈。具体参考<a href="https://docs.mongodb.com/manual/core/sharding-shard-key/#shard-key-monotonic" target="_blank" rel="noopener">shard-key-monotonic</a>。在这种情况下，我们应当选择hashed sharding.</li><li>hashed sharding。MongoDB通过hash算法(MD5)来计算key的hash值，然后将数据存储于对应范围的chunk上。由于算法的原因，即使非常&quot;近&quot;的key通过hash之后的值可能会有很大的差异，从而可以更加均匀的分布在不同的chunk之上。hashed sharding的缺点在于当我们的业务有很多范围查询时，（比如uid 5~20)，此时由于可能分布在很多不同的chunk上，所以就必须进行广播时操作，即要求所有的shard都进行查询，看是否有在这个范围内的数据，如果有就会交给mongos，mongos再负责将这些数据组合成一个完整的答案给客户端。这种情况下，势必会影响到查询性能。所以具体使用什么样的策略，需要综合考虑很多因素。</li></ul><h2>Splitting and Migration</h2><h3>Splitting</h3><p>splitting就是当chunk中存储的数据量超过设定的chunk size时(默认64M)，将其分裂成两个chunk，具体参考<a href="https://docs.mongodb.com/manual/core/sharding-data-partitioning/#chunk-splits" target="_blank" rel="noopener">chunk split</a><img src="http://upload-images.jianshu.io/upload_images/3959253-e563c219fc51aa4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Splitting"></p><h3>Migration</h3><p>数据迁移，是将某一个shard中的chunk数据迁移到另一个shard上。迁移有两种方式，一种是手动迁移，一种自动迁移。大部分时候，MongoDB会通过balancer进行自动迁移，以保持chunk在shard上能够均匀分布。手动迁移仅用于某些特定场景如bulk insert。</p><h4>关于balancer</h4><p>balancer是一个后台进程，它会自动判断含有最多chunk的shard和最少chunk的shard之间的chunk数量差达到了设定的threshold，如果达到了，就会自动进行数据迁移。<img src="http://upload-images.jianshu.io/upload_images/3959253-2700a7cbe0745a9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Balancing"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;详细介绍MongoDB sharding&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h2&gt;Sharding Key&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sharding key必须是在对应的collection当中所有的文档都存在的fiel
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB的事务、ACID和一致性</title>
    <link href="http://yoursite.com/2018/01/10/MongoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E3%80%81ACID%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/2018/01/10/MongoDB的事务、ACID和一致性/</id>
    <published>2018-01-10T10:18:18.000Z</published>
    <updated>2018-08-12T10:08:00.765Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇<a href="http://localhost:4000/2018/01/08/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%8CACID%EF%BC%8CCAP%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7/" target="_blank" rel="noopener">《理解数据库的事务，ACID，CAP和一致性》</a>我已经将数据库的一些基本概念包括事务，ACID，CAP，一致性，隔离性等都深入的介绍了一遍，而此篇主要是针对MongoDB数据库系统做一下深入的了解，主要希望弄清楚如下几个问题：</p><p>&lt;!--more--&gt;</p><ul><li>MongoDB是如何实现事务的？有哪些局限？</li><li>MongoDB的一致性是如何保证的？</li></ul><h2>MongoDB的事务</h2><p>首先我们需要知道MongoDB是有多种存储引擎的，不同的存储引擎在实现ACID的时候，使用不同的机制。而Mongodb从3.0开始默认使用的是WiredTiger引擎，本文后续所有文字均是针对WiredTiger引擎。WiredTiger引擎可以针对单个文档来保证ACID特性，但是当需要操作多个文档的时候无法保证ACID，也即无法提供事务支持。但是，我们是否就无法实现事务呢？实际上，MongoDB本身虽然不支持跨文档的事务，但是我们依然可以可以在应用层来获取类似事务的支持。这其中有很多方式，MongoDB公司的Antoine Girbal曾经撰写过文章详细阐释了五种方式来支持事务，可以参考Reference中的链接。不过在此之前，让我们先了解下MongoDB在单文档上是如何实现ACID特性的。</p><h4>单文档的ACID是如何实现的？</h4><p>MongoDB在更新单个文档时，会对该文档加锁，而要理解MongoDB的锁机制，需要先了解以下几个概念：</p><ul><li><p>Intent Lock（我把它翻译为<em>意图锁</em>): 意图锁表明读写方(reader-writer)意图针对更细粒度的资源进行读取或写入操作。比如：如果当某个Collection被加了intent lock，那么说明读写方意图针对该Collection中的某个文档进行读或写的操作。如下图所示：<img src="http://upload-images.jianshu.io/upload_images/3959253-1d185d143c10acfe.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1:MongoDB Lock">上图展示了当reader or writer需要操作文档时，相对更高的层级都需要加intent lock.</p></li><li><p>Multiple granularity locking (我把它翻译为<em>多粒度锁机制</em>): MongoDB采用的是所谓的MGL多粒度锁机制，具体可以参考文末的wiki链接。简单来说就是结合了多种不同粒度的锁，包括S锁（Shared lock），X锁（Exclusive lock), IS锁(Intent Share lock), IX(Intent Exclusive lock)，这几种锁的互斥关系如下表所示：<img src="http://upload-images.jianshu.io/upload_images/3959253-537623996ad86ac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lockrelation.png"></p></li></ul><p>下面，我用一个例子来简单说明下。假设我要更改name为Jim的document<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_collection.update(&#123;&apos;name&apos;: &apos;Jim&apos;&#125;, &#123;$set: &#123;&apos;age&apos;: 26, &apos;score&apos;: 50&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>此时，如图1所示，MongoDB会为name为Jim的document加上X锁，同时为包含该document的Collection，Database和instance都加上IX锁，这时，针对该文档的操作就保证了原子性。需要注意的是：</p><ul><li>如果当<code>age</code>修改成功，而<code>score</code>没有修改成功时，MongoDB会自动回滚，因此我们可以说针对单个文档，MongoDB是支持事务，保证ACID的（严格来说，要想保证Durability，需要在写操作时使用特殊的write concern，这个后边再谈）</li><li>所有的锁都是平等的，它们是排在一个队列里，符合FIFO原则。但是，MongoDB做了优化，即当一个锁被采用时，所有与它兼容的锁（即上表为yes的锁）都会被采纳，从而可以并发操作。举个例子，当你针对Collection A中的Document a使用S锁时，其它reader可以同时使用S锁来读取该Document a，也可以同时读取同一个Collection的Document b.因为所有的S锁都是兼容的。那么，如果此时针对Collection A中的Document c进行写操作是否可以呢？显然需要为Document c赋予x锁，此时Collection A就需要IX锁，而由于IX和IS是兼容的，所以没有问题。简单来说，只要不是同一个Document，读写操作是可以并发的；如果是同一个Document，读可以并发，但写不可以。</li><li>WiredTiger针对global, db, collection level只能使用intent lock。另外，针对冲突的情况，WiredTiger会自动重试。</li></ul><h4>跨文档的事务支持</h4><p>前面已经说过，针对多文档，MongoDB是不支持事务的，但是我们的应用却可以自己去实现类事务的功能，这里只针对其中最常用的两步提交方式来做详细阐释。假设我们有两个账户A和B，现在我们要让账户A转账100元给账户B，我们需要将整个过程放在一个事务当中，来保证数据的一致性。在这个应用模拟的事务当中，需要涉及两个Collection，一个是accounts collection，另一个是transaction collection（用于存储交易的信息和状态）。先来看下transaction最终成功的大体流程：如图2所示<img src="http://upload-images.jianshu.io/upload_images/3959253-1f43175f98bf3140.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 success transaction">伪代码如下：</p><h4>initial accounts</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bulk_result = db.accounts.insert(</span><br><span class="line">   [</span><br><span class="line">     &#123; _id: &quot;A&quot;, balance: 1000, pendingTransactions: [] &#125;,</span><br><span class="line">     &#123; _id: &quot;B&quot;, balance: 1000, pendingTransactions: [] &#125;</span><br><span class="line">   ]</span><br><span class="line">)</span><br><span class="line">if bulk_result.nInserted != 2:</span><br><span class="line">   print &quot;insert account failed.&quot;</span><br><span class="line">  return False</span><br></pre></td></tr></table></figure></p><h4>add a transaction</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write_result = db.transactions.insert(</span><br><span class="line">    &#123; _id: 1, source: &quot;A&quot;, destination: &quot;B&quot;, value: 100, state: &quot;initial&quot;, lastModified: new Date() &#125;</span><br><span class="line">)</span><br><span class="line">if write_result.nInserted != 1:</span><br><span class="line">  print &quot;transaction failed&quot;</span><br><span class="line">  return False</span><br></pre></td></tr></table></figure></p><h4>update transaction to pending</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t = db.transactions.findOne( &#123; state: &quot;initial&quot; &#125; )</span><br><span class="line">result = db.transactions.update(</span><br><span class="line">    &#123; _id: t._id, state: &quot;initial&quot; &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      $set: &#123; state: &quot;pending&quot; &#125;,</span><br><span class="line">      $currentDate: &#123; lastModified: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">if result.nModified != 1:</span><br><span class="line">  print &quot;transaction failed&quot;</span><br><span class="line">  return False</span><br></pre></td></tr></table></figure></p><h4>update accounts &amp; push transaction id</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result_source = db.accounts.update(</span><br><span class="line">   &#123; _id: t.source, pendingTransactions: &#123; $ne: t._id &#125; &#125;,</span><br><span class="line">   &#123; $inc: &#123; balance: -t.value &#125;, $push: &#123; pendingTransactions: t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line">result_destination = db.accounts.update(</span><br><span class="line">   &#123; _id: t.destination, pendingTransactions: &#123; $ne: t._id &#125; &#125;,</span><br><span class="line">   &#123; $inc: &#123; balance: t.value &#125;, $push: &#123; pendingTransactions: t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line">if result_source.nModified != 1 or result_destination.nModified != 1:</span><br><span class="line">   # 进入回滚的流程</span><br><span class="line">  ...</span><br><span class="line">   return False</span><br></pre></td></tr></table></figure></p><h4>update transaction to applied</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = db.transactions.update(</span><br><span class="line">   &#123; _id: t._id, state: &quot;pending&quot; &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     $set: &#123; state: &quot;applied&quot; &#125;,</span><br><span class="line">     $currentDate: &#123; lastModified: true &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">if result.nModified != 1:</span><br><span class="line">  # 重新update accounts &amp; push transaction id</span><br><span class="line">  # 注意：如果上一步是成功的，pendingTransactions列表中会有相应的Transaction，那么就不会重复更新账户</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><h4>pull transaction id</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result_source = db.accounts.update(</span><br><span class="line">   &#123; _id: t.source, pendingTransactions: t._id &#125;,</span><br><span class="line">   &#123; $pull: &#123; pendingTransactions: t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line">result_destination = db.accounts.update(</span><br><span class="line">   &#123; _id: t.destination, pendingTransactions: t._id &#125;,</span><br><span class="line">   &#123; $pull: &#123; pendingTransactions: t._id &#125; &#125;</span><br><span class="line">)</span><br><span class="line">if result_source.nModified != 1 or result_destination.nModified != 1:</span><br><span class="line">  # 重新执行pull transaction id</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><h4>update transaction to done</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = db.transactions.update(</span><br><span class="line">   &#123; _id: t._id, state: &quot;applied&quot; &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     $set: &#123; state: &quot;done&quot; &#125;,</span><br><span class="line">     $currentDate: &#123; lastModified: true &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">if result.nModified != 1:</span><br><span class="line">  # 重新从pull transaction id执行</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>包含回滚和失败的整体流程如图3：<img src="http://upload-images.jianshu.io/upload_images/3959253-f9054cb97e7a5e3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 whole transaction procedure">从上图可以看出，任何一步失败都有相应的应对措施来保证事务或者执行完毕或者回滚。当然所有的实现都需要应用程序自己实现，更何况如果涉及多个应用并发的情况时，会更加复杂，如何保证多个事务不互相影响，又会进一步增加复杂度，这也就是为什么如果需要此类跨文档事务支持的时候推荐使用关系数据库。</p><h2>MongoDB的一致性</h2><p>当我们说外部一致性时，是针对分布式系统所说的CAP理论中的一致性，简单来说就是如何使得多台机器的副本保持一致，实际上Mongodb只能做到最终一致性，总会有“不一致时间窗口”，这是由于Mongodb在更新操作的时候，需要将同样的更新复制到副本节点当中，而这段时间无法保证reader读到的一定是最新数据，即使ReadConcern设置为<em>majority</em>，也只能保证返回目前大多数节点的所持有的数据，而不一定是最新的数据（比如，只有primary节点更新完成，其它所有secondary节点都还没有更新完成）。当我们说内部一致性时，是针对ACID中的一致性，这里主要针对如何避免脏读，当Mongodb无法在大多数节点成功的更新操作时，会导致回滚操作，这时如果Reader已经读取了更改后的数据，就会产生脏读现象。而避免脏读，可以通过设置Read Concern和Write Concer来实现，关于Write Concern和Read Concern，请参考Reference中链接，已经讲的很详细了，不再赘述。当我们设置Read Concern为majority时，可以保证返回的数据是大多数节点所持有的数据，这种情况是不会发生回滚的，也就避免了脏读。还有一种情况可能出现脏读，就是当writer写数据时，虽然已经写入到了内存当中，但是并没有写入到磁盘中，这时reader读取到了更新后的数据，但当Mongodb将内存中的数据写入磁盘时可能会产生错误，从而导致磁盘写入失败，这时就可能导致该数据丢失，这种情况下也会产生脏读，而为了避免这种情况，我们需要在Write Concern设置的时候使用<code>j:1</code>，这样实际是在写入journal之后才返回写入成功，保证不会出现上述的脏读现象。当然这种情况下，性能势必会受到影响。所以还是要根据业务情况来决定，非关键业务不需要很强的一致性的情况下，也不需要此种设置。</p><h2>Reference</h2><ul><li><a href="http://www.csdn.net/article/2014-08-07/2821104-Implement-Robust-and-Scalable-Transactions-with-MongoDB" target="_blank" rel="noopener">五个解决方案让MongoDB拥有RDBMS的鲁棒性事务</a></li><li><a href="https://en.wikipedia.org/wiki/Multiple_granularity_locking" target="_blank" rel="noopener">Wiki: multiple granularity locking</a></li><li><a href="https://docs.mongodb.com/manual/faq/concurrency/#faq-concurrency-locking" target="_blank" rel="noopener">mongodb locking</a></li><li><a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" target="_blank" rel="noopener">MongoDB 2 phase commits</a></li><li><a href="http://www.ywnds.com/?p=3688" target="_blank" rel="noopener">MongoDW Write Concern机制</a></li><li><a href="http://vincentwang.top/2017/08/02/MongoDB-%E5%86%99%E5%AE%89%E5%85%A8-Write-Concern/" target="_blank" rel="noopener">MongoDB 写安全(Write Concern)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前一篇&lt;a href=&quot;http://localhost:4000/2018/01/08/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%8CACID%EF%BC
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解数据库的事务，ACID，CAP和一致性</title>
    <link href="http://yoursite.com/2018/01/08/db_acid_cap/"/>
    <id>http://yoursite.com/2018/01/08/db_acid_cap/</id>
    <published>2018-01-08T10:18:18.000Z</published>
    <updated>2018-08-12T10:11:02.288Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细阐述了数据库常用的一些概念如事务、ACID、CAP等</p><p>&lt;!--more--&gt;</p><h2>什么是事务</h2><p>事务是指由一系列数据库操作组成的一个完整的逻辑过程，这个过程中的所有操作要么都成功，要么都不成功。比如：常见的例子就是银行转账的例子，一次转账操作会包含多个数据库操作，而这些数据库操作需要放到一个事务当中，保证其要么都成功，要么都不成功。</p><h2>什么是ACID</h2><p>ACID是事务的四个特性，指的是atomicity，原子性；consistency，一致性；isolation，隔离性；durability，持久性。</p><ol><li>原子性(atomicity): 指所有在事务中的操作要么都成功，要么都不成功，所有的操作都不可分割，没有中间状态。一旦某一步执行失败，就会全部回滚到初始状态。</li><li>一致性(consistency): 指的是逻辑上的一致性，即所有操作是符合现实当中的期望的。具体参考下一节</li><li>隔离性(isolation): 即不同事务之间的相互影响和隔离的程度。比如，不同的隔离级别，事务的并发程度也不同，最强的隔离状态是所有的事务都是串行化的（serializable）（即一个事务完成之后才能进行下一个事务），这样并发性也会降到最低，在保证了强一致性的情况下，性能也会受很大影响，所以在实际工程当中，往往会折中一下。</li><li>持久性(durability): 可以简单地理解为事务执行完毕后数据不可逆并持久化存储于存储系统当中</li></ol><h2>理解一致性</h2><p>实际上我们通常说的数据库事务的一致性和分布式系统的一致性并不是一个概念。这里可以区分成“内部一致性”和“外部一致性”。“内部一致性”搞数据库的人很少这么说，一般就直接说一致性，更准确的说是“Consistency in ACID”（“事务 ACID 属性中的一致性”）；“外部一致性”是针对分布式系统而言的，分布式领域提及的 Consistency 表示系统的正确性模型，著名的也是臭名昭著的 CAP 理论中的 C 就是这个范畴的。这主要是由于分布式系统写入和读取都可能不在同一台机器上，而这必然会有一段时间导致不同机器上所存的数据不一致的情况，这就是所谓的“不一致时间窗口”。</p><h4>内部一致性</h4><p>要理解内部一致性也就是我们通常所说的ACID中的一致性，就必须从反面考虑什么情况下是不一致的。不一致的情况主要有以下几种情况：<img src="http://upload-images.jianshu.io/upload_images/3959253-604e246793805ad0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丢失修改、不可重复读、脏读"></p><ul><li>修改丢失：丢失修改是事务A和B先后更改数据数据x（假设初始是x0)，但是在A未正式更改前，B已经读取了原先的数据x0，最后A更改后为x1，B更改的并不是A更新后的x1，而是更改的x0，更改后假设为x2，这时x2将x1覆盖了，相当于事务A针对x的更改丢失了。</li><li>脏读： 事务T1读取了T2更改的x，但是T2在实际存储数据时可能出错回滚了，这时T1读取的实际是无效的数据，这种情况下就是脏读</li><li>不可重复读：是说在T1读取x时，由于中间T2更改了x，所以T1前后两次读取的x值不相同，这就是所谓的不可重复读</li><li>幻读：在T1读取符合某个条件的所有记录时，T2增加了一条符合该条件的记录，这就导致T1执行过程中前后读取的记录可能不一致，即T2之后读取时会多出一条记录。</li></ul><p>其中前三种（丢失修改、不能重复读、脏读）都是由于并发事务在修改同一份数据的时候导致的问题，此类问题可以通过对同一个资源加锁的方式来解决，而最后一种情况是由于不同事务并发时，新增数据导致的问题，对于新增的记录是无法加锁的，此种情况只能通过事务的串行化来解决。而串行化与并发是矛盾的，所以要在性能和事务的一致性强度上取得一个平衡，就涉及到不同的隔离等级，关于隔离等级，详见<em>理解隔离性</em>一节。</p><h4>外部一致性</h4><p>在分布式系统中我们所说的一致性，也就是外部一致性，通常会分为强一致性，弱一致性，还有最终一致性，而要理解外部一致性，需要对CAP理论（Consistency，Availability和Partition Tolerance）有所了解，关于CAP详见<em>CAP定理</em>一节。</p><ul><li>强一致性：指系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值</li><li>弱一致性：弱一致性是相对于强一致性而言，它不保证总能得到最新的值；</li><li>最终一致性：是弱一致性的特殊形式，即保证在没有新的更新的条件下，经过一段“不一致时间窗口”，最终所有的访问都是最后更新的值。最常见的是DNS服务，更新域名指向的机器后，多级缓存要等到expiration time的时候才会更新，但是随着时间的推移，最终数据会趋于一致。</li></ul><h2>理解隔离性</h2><p>事务的隔离级别从低到高有读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</p><ul><li>Read Uncommitted：事务读数据时不会加锁，写数据时会有行级共享锁。假设事务1先于事务2，当事务1更新数据的时候，事务2可以读取事务1未提交的数据，但是不能更新事务1正在更新的数据。而如果事务1只是读数据，那么事务2既可以读数据，也可以更新数据。这种情况下无法规避脏读，不可重复读的问题。</li><li>Read Committed：即在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据，或者说只能读取committed的数据。事务读数据的瞬间会加行级共享锁，一旦读完该行，立即释放该行级共享锁；而写数据的瞬间会加行级排它锁，直到事务结束。这种情况下就避免了脏读，但是却不能避免不可重复读的问题</li><li>Repeatable Read：当然就再升一级，为的就是避免不可重复读的问题，所以名字叫repeatable read。怎么实现的呢，我们知道read committed是，事务读操作只在读的一瞬间加锁，读完这行就释放锁了，而repeatable read级别是读的一瞬间加锁，但是一直到事务结束才释放锁。但是repeatable read不能解决幻读的问题，因为幻读是增加记录，并不是更改原先的记录。</li><li>Serialization：到达这一级别的隔离，可以彻底解决一致性的所有问题。一般来说是通过加表锁来解决串行化的问题。</li></ul><h2>CAP定理</h2><p>CAP理论主要是针对分布式存储系统的，C是指Consistency一致性，A是指Availability可用性，P是指Partition tolerance分区容忍性。CAP定理认为分布式系统中这三个特性最多只能同时满足两个特性。下面我们来分别看下这三个特性究竟是什么意思。<img src="http://upload-images.jianshu.io/upload_images/3959253-184c37c7dc01d4d5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAP"></p><ul><li>一致性(Consistency): 指在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性(Availability): 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性(Partition tolerance): 即当节点之间无法正常通信时，就产生了分区，而分区产生后，依然能够保证服务可用，那么我们就说系统是分区容忍的。显然如果节点越多，且备份越多，分区容忍度就越高（因为即便是其中一个或多个节点挂了，仍然有其它节点和备份可用）。</li></ul><p>那么，为什么说三个特性无法全部保证呢？首先，假如我们要保证分区容忍性，必然要做多个副本节点，而这必然会带来一致性的问题，即保证多个节点的数据是相同的，但是，要让多个节点数据相同，就必须要花时间去复制数据，这还是能够正常通信的情况下，那么在数据复制的过程中为了保持一致性，就不能对外提供服务，所以这段时间就无法满足可用性的问题。实际工程通常会采取一些折中措施，比如并不保证强一致性，只保证最终一致性，什么意思呢？比如，有三个数据节点互为备份，某份数据在节点A更改后，需要将更改复制到节点B和C，假设复制过程中，有客户访问该数据，那么此时不保证是一致的，即访问A节点的用户得到的是最新数据，而访问B和C节点的用户得到是老数据，但是最终，数据会复制完成，所以最终A、B、C三个节点的数据是一致的。（比如像文章点赞这种数据，延迟下也没有关系啦）</p><h2>Reference</h2><ul><li><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="noopener">深入分析事务的隔离级别</a></li><li><a href="https://www.zhihu.com/question/56073588/answer/253106572" target="_blank" rel="noopener">如何理解数据库的内部一致性和外部一致性？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文详细阐述了数据库常用的一些概念如事务、ACID、CAP等&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h2&gt;什么是事务&lt;/h2&gt;
&lt;p&gt;事务是指由一系列数据库操作组成的一个完整的逻辑过程，这个过程中的所有操作要么都成功，要么都不成功。比如：常见的例子就是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask-Login详解</title>
    <link href="http://yoursite.com/2017/10/12/Flask-Login/"/>
    <id>http://yoursite.com/2017/10/12/Flask-Login/</id>
    <published>2017-10-12T10:18:18.000Z</published>
    <updated>2018-08-12T10:10:24.884Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要通过源码分析Flask-Login插件，并详述其使用方法</p><p>&lt;!--more--&gt;</p><p>关于Flask登录认证的详细过程请参见拙作<a href="http://geekpy.github.io/2016/12/06/flask_login_detail/" target="_blank" rel="noopener">&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;</a>一文，而本文则偏重于详细介绍Flask-Login的原理，代码的解析。</p><h3>首次登陆</h3><p>我们首先来看一下首次登录验证的流程图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-b34989af4a0d0b2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首次登陆"></p><p>Flask-Login在登录过程中主要负责：</p><ul><li>将用户对象存入request context中</li><li>将用户ID，Session ID等信息存入Session中在<a href="http://www.jianshu.com/p/06bd93e21945" target="_blank" rel="noopener">&lt;&lt;使用Flask实现用户登陆认证的详细过程&gt;&gt;</a>中我们已经介绍过如何通过Flask-Login来实现登录的过程，其中最重要的代码就是login_user，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login_user(user, remember=remember_me)</span><br></pre></td></tr></table></figure></li></ul><p>那么login_user具体做了什么呢？我们来看下源码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def login_user(user, remember=False, force=False, fresh=True):</span><br><span class="line">    if not force and not user.is_active:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    user_id = getattr(user, current_app.login_manager.id_attribute)()</span><br><span class="line">    session[&apos;user_id&apos;] = user_id</span><br><span class="line">    session[&apos;_fresh&apos;] = fresh</span><br><span class="line">    session[&apos;_id&apos;] = current_app.login_manager._session_identifier_generator()</span><br><span class="line"></span><br><span class="line">    if remember:</span><br><span class="line">        session[&apos;remember&apos;] = &apos;set&apos;</span><br><span class="line"></span><br><span class="line">    _request_ctx_stack.top.user = user</span><br><span class="line">    user_logged_in.send(current_app._get_current_object(), user=_get_user())</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure></p><ul><li><code>getattr(user, current_app.login_manager.id_attribute)()</code> 这里<code>login_manager.id_attribute</code>是一个字符串<code>'get_id'</code>。因此这句的意思是获取User对象的get_id method，然后执行，从而获取到用户的ID</li><li>通过<code>session['user_id'] = user_id</code>来将用户的ID存储进Session当中，后面紧跟着将fresh信息，session id信息，remember信息存储进session。</li></ul><blockquote><p>注意：Flask的session是以cookie为基础，但是是在Server端使用secret key并使用AES之类的对称加密算法进行加密的，然后将加密后的cookie发送给客户端。由于是加密后的数据，客户端无法篡改数据，也无法获知session中的信息，只能保存该session信息，在之后的请求中携带该session信息</p></blockquote><ul><li><code>_request_ctx_stack.top.user = user</code>这里是将user对象存储进当前的request context中，_request_ctx_stack是一个LocalStack对象，top属性指向的就是当前的request context。关于LocalStack及相关技术，请参考拙作<a href="http://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt;</a></li><li><code>user_logged_in.send(current_app._get_current_object(), user=_get_user())</code> 此句中<code>user_logged_in</code>是Flask-Login定义的signal，此处通过send来发射此signal，当注册监听此signal的回调函数收到此signal之后就会执行函数。这里send有两个参数，第一个参数是sender对象，此处通过<code>current_app._get_current_object()</code>来获取当前的app对象，即此signal的sender设为当前的应用；第二个参数是该signal携带的数据，此处将user对象做为signal的数据传递给相应的回调函数。关于signal的详细解释请参考拙作<a href="http://www.jianshu.com/p/756ed0267f53" target="_blank" rel="noopener">&lt;&lt;Flask Signals详解&gt;&gt;</a></li></ul><h3>非首次登陆</h3><p>非首次登陆流程图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-7ea20e139da6e2ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非首次登陆"></p><p>在这个流程图中，Flask-Login主要起如下作用：</p><ol><li>从session中获取用户ID</li><li>当用户的请求访问的是受登录保护的路由时，就要通过用户ID重新load user，如果load user失败则进入鉴权失败处理流程，如果成功，则允许正常处理请求那么Flask-Login究竟是如何保护路由的呢？我们来看个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">@app.route(&apos;/main&apos;)</span><br><span class="line">@login_required</span><br><span class="line">def main():</span><br><span class="line">    return render_template(</span><br><span class="line">        &apos;main.html&apos;, username=current_user.username)</span><br></pre></td></tr></table></figure></li></ol><p>我们看到只要给路由函数加一个<code>@login_required</code>装饰器就可以了，那么这个装饰器究竟是怎么做到的呢？来看下源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/utils.py</span><br><span class="line">def login_required(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def decorated_view(*args, **kwargs):</span><br><span class="line">        # 如果request method为例外method，即在EXEMPT_METHODS中的method，可以不必鉴权</span><br><span class="line">        if request.method in EXEMPT_METHODS:</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        # 如果_login_disabled为True则不必鉴权</span><br><span class="line">        elif current_app.login_manager._login_disabled:</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        # 正常鉴权</span><br><span class="line">        elif not current_user.is_authenticated:</span><br><span class="line">            return current_app.login_manager.unauthorized()</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return decorated_view</span><br></pre></td></tr></table></figure></p><ul><li>默认情况下只有<em>OPTIONS</em> method在EXEMPT_METHODS set中，而GET、PUT、POST等常见的methods都需要鉴权</li><li><code>_login_disabled</code>默认为False</li><li>正常鉴权的关键在于<code>current_user.is_authenticated</code>是否为True，为True则正常处理请求，为False则进入unauthorized处理流程。那么这个current_user到底怎么就能鉴权了？它是怎么来的呢？来看下定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/utils.py</span><br><span class="line">current_user = LocalProxy(lambda: _get_user())</span><br></pre></td></tr></table></figure></li></ul><p>原来current_user是一个LocalProxy对象，其代理的对象需要通过<code>_get_user()</code>来获取，简单来说_get_user()会返回两种用户，一种是正常的用户对象(鉴权成功)，一种是anonymous用户对象(鉴权失败)。而正常的用户对象其<code>is_authenticated</code>属性总是为True，相对的anonymous用户对象的<code>is_authenticated</code>属性总是为False</p><blockquote><p>LocalProxy对象每次操作都会重新获取代理的对象从而实现动态更新，关于LocalProxy的详细说明请参考拙作<a href="http://www.jianshu.com/p/3f38b777a621" target="_blank" rel="noopener">&lt;&lt;Werkzeug(Flask)之Local、LocalStack和LocalProxy&gt;&gt;</a></p></blockquote><p>而要实现动态更新的关键就在于<code>_get_user</code>函数，接下来我们看下<code>_get_user</code>函数是如何获取user对象的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/utils.py</span><br><span class="line">def _get_user():</span><br><span class="line">    if has_request_context() and not hasattr(_request_ctx_stack.top, &apos;user&apos;):</span><br><span class="line">        current_app.login_manager._load_user()</span><br><span class="line"></span><br><span class="line">    return getattr(_request_ctx_stack.top, &apos;user&apos;, None)</span><br></pre></td></tr></table></figure></p><p>在之前的首次登陆那小节中，我们已经知道用户鉴权成功后，会将User对象保存在当前的request context当中，这时我们调用<code>_get_user</code>函数时就会直接从request context中获取user对象<code>return getattr(_request_ctx_stack.top, 'user', None)</code>但如果是非首次登陆，当前request context中并没有保存user对象，就需要调用<code>current_app.login_manager._load_user()</code>来去load user对象，接下来再看看如何去load：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/login_manager.py</span><br><span class="line">def _load_user(self):</span><br><span class="line">        &apos;&apos;&apos;Loads user from session or remember_me cookie as applicable&apos;&apos;&apos;</span><br><span class="line">        user_accessed.send(current_app._get_current_object())</span><br><span class="line"></span><br><span class="line">        # first check SESSION_PROTECTION</span><br><span class="line">        config = current_app.config</span><br><span class="line">        if config.get(&apos;SESSION_PROTECTION&apos;, self.session_protection):</span><br><span class="line">            deleted = self._session_protection()</span><br><span class="line">            if deleted:</span><br><span class="line">                return self.reload_user()</span><br><span class="line"></span><br><span class="line">        # If a remember cookie is set, and the session is not, move the</span><br><span class="line">        # cookie user ID to the session.</span><br><span class="line">        #</span><br><span class="line">        # However, the session may have been set if the user has been</span><br><span class="line">        # logged out on this request, &apos;remember&apos; would be set to clear,</span><br><span class="line">        # so we should check for that and not restore the session.</span><br><span class="line">        is_missing_user_id = &apos;user_id&apos; not in session</span><br><span class="line">        if is_missing_user_id:</span><br><span class="line">            cookie_name = config.get(&apos;REMEMBER_COOKIE_NAME&apos;, COOKIE_NAME)</span><br><span class="line">            header_name = config.get(&apos;AUTH_HEADER_NAME&apos;, AUTH_HEADER_NAME)</span><br><span class="line">            has_cookie = (cookie_name in request.cookies and</span><br><span class="line">                          session.get(&apos;remember&apos;) != &apos;clear&apos;)</span><br><span class="line">            if has_cookie:</span><br><span class="line">                return self._load_from_cookie(request.cookies[cookie_name])</span><br><span class="line">            elif self.request_callback:</span><br><span class="line">                return self._load_from_request(request)</span><br><span class="line">            elif header_name in request.headers:</span><br><span class="line">                return self._load_from_header(request.headers[header_name])</span><br><span class="line"></span><br><span class="line">        return self.reload_user()</span><br></pre></td></tr></table></figure></p><ul><li><code>_load_user</code>大体的过程是首先检查<em>SESSION_PROTECTION</em>设置，如果<em>SESSION_PROTECTION</em> 为strong或者basic类型，那么就会执行<code>_session_protection()</code>动作，否则不执行此操作。<code>_session_protection</code>在session_id不一致的时候(比如IP变化会导致session id的变化)才真正有用，这时，如果为basic类型或者session permanent为True时，只标注session为非新鲜的(not fresh)；而如果为strong，则会删除session中的用户信息，并重新load user，即调用<code>reload_user</code>。</li></ul><blockquote><p>session permanent为True时，用户退出浏览器不会删除session，其会保留permanent_session_lifetime s(默认是31天)，但是当其为False且<em>SESSION_PROTECTION</em> 设为strong时，用户的session就会被删除。</p></blockquote><ul><li>接下来的代码是说当session中没有用户信息时(这里通过是否能获取到<code>user_id</code>来判断)，如果有则直接<code>reload_user</code>,如果没有，则有三种方式来load user，一种是通过remember cookie，一种通过request，一种是通过request header，依次尝试。</li></ul><blockquote><p>remember cookie是指，当用户勾选'remember me'复选框时，Flask-Login会将用户信息放入到指定的cookie当中，同样也是加密的。这就是为什么当session中没有携带用户信息时，我们可以通过remember cookie来获取用户的信息</p></blockquote><p>而<code>reload_user</code>是如何获取用户的呢，来看下源代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># flask_login/login_manager.py</span><br><span class="line">def reload_user(self, user=None):</span><br><span class="line">        ctx = _request_ctx_stack.top</span><br><span class="line"></span><br><span class="line">        if user is None:</span><br><span class="line">            user_id = session.get(&apos;user_id&apos;)</span><br><span class="line">            if user_id is None:</span><br><span class="line">                # 当无法获取到有效的用户id时，就认为是anonymous user</span><br><span class="line">                ctx.user = self.anonymous_user()</span><br><span class="line">            else:</span><br><span class="line">                # user callback就是我们通过@login_manager.user_loader装饰的函数，用于获取user object</span><br><span class="line">                if self.user_callback is None:</span><br><span class="line">                    raise Exception(</span><br><span class="line">                        &quot;No user_loader has been installed for this &quot;</span><br><span class="line">                        &quot;LoginManager. Add one with the &quot;</span><br><span class="line">                        &quot;&apos;LoginManager.user_loader&apos; decorator.&quot;)</span><br><span class="line">                user = self.user_callback(user_id)</span><br><span class="line">                if user is None:</span><br><span class="line">                    ctx.user = self.anonymous_user()</span><br><span class="line">                else:</span><br><span class="line">                    ctx.user = user</span><br><span class="line">        else:</span><br><span class="line">            ctx.user = user</span><br></pre></td></tr></table></figure></p><ul><li>首先获取user id，如果获取不到有效的id，就将user设为anonymous user</li><li>获取到id后，再通过@login_manager.user_loader装饰的函数获取到user对象，如果没有获取到有效的user对象，就认为是anonymous user</li><li>最后将user保存于request context中（无论是正常的用户还是anonymous用户）</li></ul><p>至此，我们已经将Flask-Login的核心代码剖析了一遍，如果你有收获，不妨点个赞鼓励一下吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要通过源码分析Flask-Login插件，并详述其使用方法&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;p&gt;关于Flask登录认证的详细过程请参见拙作&lt;a href=&quot;http://geekpy.github.io/2016/12/06/flask_l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Werkzeug(Flask)之Local、LocalStack和LocalProxy</title>
    <link href="http://yoursite.com/2017/10/08/Werkzeug-Local/"/>
    <id>http://yoursite.com/2017/10/08/Werkzeug-Local/</id>
    <published>2017-10-08T10:18:18.000Z</published>
    <updated>2018-08-12T05:29:42.840Z</updated>
    
    <content type="html"><![CDATA[<p>在我们使用Flask以及Werkzeug框架的过程中，经常会遇到如下三个概念：Local、LocalStack和LocalProxy。尤其在学习Flask的Request Context和App Context的过程中，这几个概念出现的更加频繁，另外很多Flask插件都会使用这三个概念对应的技术。那么这三个东西到底是什么？我们为什么需要它们？以及如何使用呢？本篇文章主要就是来解答这些问题。</p><h2>Local</h2><p>这部分我们重点介绍Local概念，主要分为以下几个部分：</p><ul><li>为什么需要Local？</li><li>Local的使用</li><li>Local的实现</li></ul><h4>为什么需要Local？</h4><p>在Python的标准库中提供了<code>thread local</code>对象用于存储<em>thread-safe</em>和<em>thread-specific</em>的数据，通过这种方式存储的数据只在本线程中有效，而对于其它线程则不可见。正是基于这样的特性，我们可以把针对线程全局的数据存储进<code>thread local</code>对象，举个简单的例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;from threading import local</span><br><span class="line">&gt;&gt;thread_local_data = local()</span><br><span class="line">&gt;&gt;thread_local_data.user_name=&quot;Jim&quot;</span><br><span class="line">&gt;&gt;thread_local_data.user_name</span><br><span class="line">&apos;Jim&apos;</span><br></pre></td></tr></table></figure></p><p>使用<code>thread local</code>对象虽然可以基于线程存储全局变量，但是在Web应用中可能会存在如下问题：</p><ol><li>有些应用使用的是greenlet协程，这种情况下无法保证协程之间数据的隔离，因为不同的协程可以在同一个线程当中。</li><li>即使使用的是线程，WSGI应用也无法保证每个http请求使用的都是不同的线程，因为后一个http请求可能使用的是之前的http请求的线程，这样的话存储于<code>thread local</code>中的数据可能是之前残留的数据。</li></ol><p>为了解决上述问题，Werkzeug开发了自己的local对象，这也是为什么我们需要Werkzeug的local对象</p><h4>Local的使用</h4><p>先举一个简单的示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from werkzeug.local import Local, LocalManager</span><br><span class="line"></span><br><span class="line">local = Local()</span><br><span class="line">local_manager = LocalManager([local])</span><br><span class="line"></span><br><span class="line">def application(environ, start_response):</span><br><span class="line">    local.request = request = Request(environ)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"># make_middleware会确保当request结束时，所有存储于local中的对象的reference被清除</span><br><span class="line">application = local_manager.make_middleware(application)</span><br></pre></td></tr></table></figure></p><ul><li>首先Local对象需要通过LocalManager来管理，初次生成LocalManager对象需要传一个list类型的参数，list中是Local对象，当有新的Local对象时，可以通过<code>local_manager.locals.append()</code>来添加。而当LocalManager对象清理的时候会将所有存储于locals中的当前context的数据都清理掉</li><li>上例中当local.request被赋值之后，其可以在当前context中作为全局数据使用</li><li>所谓当前context(the same context)意味着是在同一个greenlet(如果有)中，也就肯定是在同一个线程当中</li></ul><p>那么Werkzeug的Local对象是如何实现这种在相同的context环境下保证数据的全局性和隔离性的呢？</p><h4>Local的实现</h4><p>我们先来看下源代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 在有greenlet的情况下，get_indent实际获取的是greenlet的id，而没有greenlet的情况下获取的是thread id</span><br><span class="line">try:</span><br><span class="line">    from greenlet import getcurrent as get_ident</span><br><span class="line">except ImportError:</span><br><span class="line">    try:</span><br><span class="line">        from thread import get_ident</span><br><span class="line">    except ImportError:</span><br><span class="line">        from _thread import get_ident</span><br><span class="line"></span><br><span class="line">class Local(object):</span><br><span class="line">    __slots__ = (&apos;__storage__&apos;, &apos;__ident_func__&apos;)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        object.__setattr__(self, &apos;__storage__&apos;, &#123;&#125;)</span><br><span class="line">        object.__setattr__(self, &apos;__ident_func__&apos;, get_ident)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    # 当调用Local对象时，返回对应的LocalProxy</span><br><span class="line">    def __call__(self, proxy):</span><br><span class="line">        &quot;&quot;&quot;Create a proxy for a name.&quot;&quot;&quot;</span><br><span class="line">        return LocalProxy(self, proxy)</span><br><span class="line"></span><br><span class="line">    # Local类中特有的method，用于清空greenlet id或线程id对应的dict数据</span><br><span class="line">    def __release_local__(self):</span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), None)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, name):</span><br><span class="line">        try:</span><br><span class="line">            return self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(name)</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, name, value):</span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        try:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        except KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    def __delattr__(self, name):</span><br><span class="line">        try:</span><br><span class="line">            del self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(name)</span><br></pre></td></tr></table></figure></p><ul><li>这段代码实际是对<code>__storage__</code> dict的封装，而这个dict中的key使用的就是get_indent函数获取的id（当有greenlet时使用greenlet id，没有则使用thread id）</li><li><code>__storage__</code> dict中的value也是一个dict，这个dict就是该greenlet(或者线程)对应的local存储空间</li><li>通过重新实现<code>__getattr__</code>, <code>__setattr__</code>等魔术方法，我们在greenlet或者线程中使用local对象时，实际会自动获取greenlet id(或者线程id)，从而获取到对应的dict存储空间，再通过name key就可以获取到真正的存储的对象</li><li>当我们需要释放local数据的内存时，可以通过调用release_local()函数来释放当前context的local数据，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; loc = Local()</span><br><span class="line">&gt;&gt;&gt; loc.foo = 42</span><br><span class="line">&gt;&gt;&gt; release_local(loc)  # release_local实际调用local对象的__release_local__ method</span><br><span class="line">&gt;&gt;&gt; hasattr(loc, &apos;foo&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li></ul><h2>LocalStack</h2><p>LocalStack与Local对象类似，都是可以基于Greenlet协程或者线程进行全局存储的存储空间(实际LocalStack是对Local进行了二次封装），区别在于其数据结构是栈的形式。示例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ls = LocalStack()</span><br><span class="line">&gt;&gt;&gt; ls.push(42)</span><br><span class="line">&gt;&gt;&gt; ls.top</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt; ls.push(23)</span><br><span class="line">&gt;&gt;&gt; ls.top</span><br><span class="line">23</span><br><span class="line">&gt;&gt;&gt; ls.pop()</span><br><span class="line">23</span><br><span class="line">&gt;&gt;&gt; ls.top</span><br><span class="line">42</span><br></pre></td></tr></table></figure></p><ul><li>从示例看出Local对象存储的时候是类似字典的方式，需要有key和value，而LocalStack是基于栈的，通过push和pop来存储和弹出数据</li><li>另外，当我们想释放存储空间的时候，也可以调用release_local()</li></ul><p>LocalStack在Flask框架中会频繁的出现，其Request Context和App Context的实现都是基于LocalStack，具体可以参考Github上的<a href="https://github.com/pallets/flask/tree/master/flask" target="_blank" rel="noopener">Flask源码</a></p><h2>LocalProxy</h2><p>LocalProxy用于代理Local对象和LocalStack对象，而所谓代理就是作为中间的代理人来处理所有针对被代理对象的操作，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-e64c1ca00b6f14e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="proxy.jpg"></p><p>接下来我们将重点讲下如下内容：</p><ul><li>LocalProxy的使用</li><li>LocalProxy代码解析</li><li>为什么要使用LocalProxy</li></ul><h4>LocalProxy的使用</h4><p>初始化LocalProxy有三种方式：</p><ol><li>通过Local或者LocalStack对象的<code>__call__</code> method<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from werkzeug.local import Local</span><br><span class="line">l = Local()</span><br><span class="line"></span><br><span class="line"># these are proxies</span><br><span class="line">request = l(&apos;request&apos;)</span><br><span class="line">user = l(&apos;user&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from werkzeug.local import LocalStack</span><br><span class="line">_response_local = LocalStack()</span><br><span class="line"></span><br><span class="line"># this is a proxy</span><br><span class="line">response = _response_local()</span><br></pre></td></tr></table></figure></li></ol><p>上述代码直接将对象像函数一样调用，这是因为Local和LocalStack都实现了<code>__call__</code> method，这样其对象就是callable的，因此当我们将对象作为函数调用时，实际调用的是<code>__call__</code> method，可以看下本文开头部分的Local的源代码，会发现<code>__call__</code> method会返回一个LocalProxy对象</p><ol start="2"><li>通过LocalProxy类进行初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = Local()</span><br><span class="line">request = LocalProxy(l, &apos;request&apos;)</span><br></pre></td></tr></table></figure></li></ol><p>实际上这段代码跟第一种方式是等价的，但这种方式是最'原始'的方式，我们在Local的源代码实现中看到其<code>__call__</code> method就是通过这种方式生成LocalProxy的</p><ol start="3"><li>使用callable对象作为参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request = LocalProxy(get_current_request())</span><br></pre></td></tr></table></figure></li></ol><p>通过传递一个函数，我们可以自定义如何返回Local或LocalStack对象</p><p>那么LocalProxy是如何实现这种代理的呢？接下来看下源码解析</p><h4>LocalProxy代码解析</h4><p>下面截取LocalProxy的部分代码，我们来进行解析<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># LocalProxy部分代码</span><br><span class="line"></span><br><span class="line">@implements_bool</span><br><span class="line">class LocalProxy(object):</span><br><span class="line">    __slots__ = (&apos;__local&apos;, &apos;__dict__&apos;, &apos;__name__&apos;, &apos;__wrapped__&apos;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, local, name=None):</span><br><span class="line">        object.__setattr__(self, &apos;_LocalProxy__local&apos;, local)</span><br><span class="line">        object.__setattr__(self, &apos;__name__&apos;, name)</span><br><span class="line">        if callable(local) and not hasattr(local, &apos;__release_local__&apos;):</span><br><span class="line">            # &quot;local&quot; is a callable that is not an instance of Local or</span><br><span class="line">            # LocalManager: mark it as a wrapped function.</span><br><span class="line">            object.__setattr__(self, &apos;__wrapped__&apos;, local)</span><br><span class="line"></span><br><span class="line">    def _get_current_object(self):</span><br><span class="line">        &quot;&quot;&quot;Return the current object.  This is useful if you want the real</span><br><span class="line">        object behind the proxy at a time for performance reasons or because</span><br><span class="line">        you want to pass the object into a different context.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 由于所有Local或LocalStack对象都有__release_local__ method, 所以如果没有该属性就表明self.__local为callable对象</span><br><span class="line">        if not hasattr(self.__local, &apos;__release_local__&apos;):</span><br><span class="line">            return self.__local()</span><br><span class="line">        try:</span><br><span class="line">            # 此处self.__local为Local或LocalStack对象</span><br><span class="line">            return getattr(self.__local, self.__name__)</span><br><span class="line">        except AttributeError:</span><br><span class="line">            raise RuntimeError(&apos;no object bound to %s&apos; % self.__name__)</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def __dict__(self):</span><br><span class="line">        try:</span><br><span class="line">            return self._get_current_object().__dict__</span><br><span class="line">        except RuntimeError:</span><br><span class="line">            raise AttributeError(&apos;__dict__&apos;)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, name):</span><br><span class="line">        if name == &apos;__members__&apos;:</span><br><span class="line">            return dir(self._get_current_object())</span><br><span class="line">        return getattr(self._get_current_object(), name)</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        self._get_current_object()[key] = value</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        del self._get_current_object()[key]</span><br><span class="line"></span><br><span class="line">    if PY2:</span><br><span class="line">        __getslice__ = lambda x, i, j: x._get_current_object()[i:j]</span><br><span class="line"></span><br><span class="line">        def __setslice__(self, i, j, seq):</span><br><span class="line">            self._get_current_object()[i:j] = seq</span><br><span class="line"></span><br><span class="line">        def __delslice__(self, i, j):</span><br><span class="line">            del self._get_current_object()[i:j]</span><br><span class="line"></span><br><span class="line">    # 截取部分操作符代码</span><br><span class="line">    __setattr__ = lambda x, n, v: setattr(x._get_current_object(), n, v)</span><br><span class="line">    __delattr__ = lambda x, n: delattr(x._get_current_object(), n)</span><br><span class="line">    __str__ = lambda x: str(x._get_current_object())</span><br><span class="line">    __lt__ = lambda x, o: x._get_current_object() &lt; o</span><br><span class="line">    __le__ = lambda x, o: x._get_current_object() &lt;= o</span><br><span class="line">    __eq__ = lambda x, o: x._get_current_object() == o</span><br></pre></td></tr></table></figure></p><ul><li>首先在<code>__init__</code> method中传递的<code>local</code>参数会被赋予属性<code>_LocalProxy__local</code>,该属性可以通过<code>self.local</code>进行访问，关于这一点可以看<a href="https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-a-single-and-a-double-underscore-before-an-object-name" target="_blank" rel="noopener">StackOverflow的问题回答</a></li><li>LocalProxy通过<code>_get_current_object</code>来获取代理的对象。需要注意的是当初始化参数为callable对象时，则直接调用以返回Local或LocalStack对象，具体看源代码的注释。</li><li>重载了绝大多数操作符，以便在调用LocalProxy的相应操作时，通过<code>_get_current_object</code> method来获取真正代理的对象，然后再进行相应操作</li></ul><h4>为什么要使用LocalProxy</h4><p>可是说了这么多，为什么一定要用proxy，而不能直接调用Local或LocalStack对象呢？这主要是在有多个可供调用的对象的时候会出现问题，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-b474030cec52260b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="multiple objects"></p><p>我们再通过下面的代码也许可以看出一二：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># use Local object directly</span><br><span class="line">from werkzeug.local import LocalStack</span><br><span class="line">user_stack = LocalStack()</span><br><span class="line">user_stack.push(&#123;&apos;name&apos;: &apos;Bob&apos;&#125;)</span><br><span class="line">user_stack.push(&#123;&apos;name&apos;: &apos;John&apos;&#125;)</span><br><span class="line"></span><br><span class="line">def get_user():</span><br><span class="line">    # do something to get User object and return it</span><br><span class="line">    return user_stack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 直接调用函数获取user对象</span><br><span class="line">user = get_user()</span><br><span class="line">print user[&apos;name&apos;]</span><br><span class="line">print user[&apos;name&apos;]</span><br></pre></td></tr></table></figure></p><p>打印结果是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">John</span><br><span class="line">John</span><br></pre></td></tr></table></figure></p><p>再看下使用LocalProxy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># use LocalProxy</span><br><span class="line">from werkzeug.local import LocalStack, LocalProxy</span><br><span class="line">user_stack = LocalStack()</span><br><span class="line">user_stack.push(&#123;&apos;name&apos;: &apos;Bob&apos;&#125;)</span><br><span class="line">user_stack.push(&#123;&apos;name&apos;: &apos;John&apos;&#125;)</span><br><span class="line"></span><br><span class="line">def get_user():</span><br><span class="line">    # do something to get User object and return it</span><br><span class="line">    return user_stack.pop()</span><br><span class="line"></span><br><span class="line"># 通过LocalProxy使用user对象</span><br><span class="line">user = LocalProxy(get_user)</span><br><span class="line">print user[&apos;name&apos;]</span><br><span class="line">print user[&apos;name&apos;]</span><br></pre></td></tr></table></figure></p><p>打印结果是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">John</span><br><span class="line">Bob</span><br></pre></td></tr></table></figure></p><p>怎么样，看出区别了吧，直接使用LocalStack对象，user一旦赋值就无法再动态更新了，而使用Proxy，每次调用操作符(这里<code>[]操作符</code>用于获取属性)，都会重新获取user，从而实现了动态更新user的效果。见下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3959253-b673a9a708167969.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="proxy auto select object"></p><p>Flask以及Flask的插件很多时候都需要这种动态更新的效果，因此LocalProxy就会非常有用了。</p><p>至此，我们针对Local、LocalStack和LocalProxy的概念已经做了详细阐释，如果你觉得文章对你有帮助，不妨点个赞吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们使用Flask以及Werkzeug框架的过程中，经常会遇到如下三个概念：Local、LocalStack和LocalProxy。尤其在学习Flask的Request Context和App Context的过程中，这几个概念出现的更加频繁，另外很多Flask插件都会使
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask Signals 详解</title>
    <link href="http://yoursite.com/2017/10/05/Flask-Signals/"/>
    <id>http://yoursite.com/2017/10/05/Flask-Signals/</id>
    <published>2017-10-05T14:22:18.000Z</published>
    <updated>2018-08-12T10:08:57.286Z</updated>
    
    <content type="html"><![CDATA[<p>Flask Signals和操作系统的signals系统很类似，都是通过信号（也可以说是事件event）来通知已经注册的回调函数，让回调函数自动开始执行。Flask定义了自己的一套核心signals和对应的functions(用于发起消息，注册回调函数)，我们需要定义自己的回调函数，然后注册到对应的signal，这样就可以在收到该信号的时候自动执行我们定义的回调函数。</p><p>&lt;!--more--&gt;</p><h2>Flask Signals简介</h2><p>Flask Signals和操作系统的signals系统很类似，都是通过信号（也可以说是事件event）来通知已经注册的回调函数，让回调函数自动开始执行。Flask定义了自己的一套核心signals和对应的functions(用于发起消息，注册回调函数)，我们需要定义自己的回调函数，然后注册到对应的signal，这样就可以在收到该信号的时候自动执行我们定义的回调函数。</p><h2>什么情况下需要使用Signals?</h2><p>当我们需要使用观察者模式来解耦模块之间的信息传递的时候，Signals系统就可以帮助我们轻松达到目的。观察者模式如下图(图片来自voidcn)<img src="http://upload-images.jianshu.io/upload_images/3959253-15e7e0cf37d01caa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="观察者模式"></p><h3>与Hook函数的区别</h3><p>试想，当我们需要监听某个事件，当它发生的时候，需要执行一系列functions，来实现诸如log记录等功能时，我们就可以使用Signals系统来实现，但是这里有一个疑问就是这个功能通过hook函数似乎也可以实现，比如通过<code>before_request</code> decorator实现记录日志的功能和使用<code>request_started</code>来记录日志就非常相似， 如下代码所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from flask import Flask, request, request_started</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.before_request</span><br><span class="line">def print_url_in_hook():</span><br><span class="line">    print &quot;in hook, url: %s&quot; % request.url</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">def print_url_in_signal_subscriber(sender, **extra):</span><br><span class="line">    print &quot;in signal subscriber, url: %s&quot; % request.url</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    request_started.connect(print_url_in_signal_subscriber, app)</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>当收到http请求后，打印如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in signal subscriber, url: http://localhost:5000/</span><br><span class="line">in hook, url: http://localhost:5000/</span><br><span class="line">127.0.0.1 - - [05/Oct/2017 16:57:20] &quot;GET / HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure></p><p>那么到底什么情况下使用signal，什么情况下使用hook函数呢？我们来看下它们的主要区别：</p><ol><li>signal的callback函数是无顺序的，而hook函数的执行是按照定义的顺序执行的。（这一点虽然是官网提出的区别，但是实际测试发现signal执行实际是按照注册的顺序执行的，即先通过connect进行注册的回调函数会先被执行）</li><li>signal无法直接abort这个request请求，相比较在hook函数中可以直接abort request，即直接返回response给客户端，而无需再执行后续的操作。</li><li>signal可以通过参数携带数据，而hook函数通常不会携带额外的参数</li></ol><h3>与RabbitMQ等消息中间件的区别</h3><p>Rabbitmq与signals都支持观察者模式，但是它们的区别也是很明显的：</p><ol><li>Rabbitmq之类的消息中间件更加重量级，提供更多功能，如分布式部署，消息存储备份等功能，而signal系统显然更加轻量级，只提供简单的消息分发功能</li><li>Rabbitmq之类的消息中间件可以在不同的系统间传递消息，从而使得不同的功能模块可以使用不同的语言进行开发，而signal系统显然仅限于Flask系统中使用</li></ol><p>显然，signal系统使用局限性更大，但也更加轻量级，在只是简单的进行消息分发的系统中，使用signal更加简单方便</p><h2>怎么使用Signals?</h2><p>Flask提供的signal机制优先使用<a href="https://pythonhosted.org/blinker/" target="_blank" rel="noopener">blinker</a>提供的库，但当blinker没有安装的时候，Flask也可以回退到使用自己的库。但是鉴于官网推荐使用blinker，所以我们最好还是安装blinker。</p><h3>使用blinker</h3><p>安装blinker<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install blinker</span><br></pre></td></tr></table></figure></p><p>测试Flask signal是否使用blinker<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from flask import signals</span><br><span class="line"></span><br><span class="line">In [2]: signals.signals_available</span><br><span class="line">Out[2]: True</span><br></pre></td></tr></table></figure></p><p>当<code>signals.signals_available</code>返回True时，说明使用的是Blinker库</p><h3>使用Flask Built-in signals</h3><p>Flask内置有多个signals可以直接使用，这些signals会自动emit(发射)，我们只需要定义自己的回调函数，然后通过connect方式来subscribe我们定义的函数到对应的signal即可监听该signal</p><p>下表展示了Flask内置的Signals，详细请参考<a href="http://flask.pocoo.org/docs/0.12/api/#core-signals-list" target="_blank" rel="noopener">Flask built-in signals</a>:</p><table><thead><tr><th>Signals</th><th>说明</th></tr></thead><tbody><tr><td>template_rendered</td><td>当template被成功渲染之后会触发</td></tr><tr><td>before_render_template</td><td>当template被渲染之前会触发</td></tr><tr><td>request_started</td><td>当request context建立好之后，并在request被处理之前</td></tr><tr><td>request_finished</td><td>当发送response给客户端之后被触发</td></tr><tr><td>got_request_exception</td><td>当request处理过程中发生异常时，该signal会被触发，它甚至早于程序中的异常处理</td></tr><tr><td>request_tearing_down</td><td>当request tear down的时候触发，无论何种情况该signal都会被触发，即使发生异常</td></tr><tr><td>appcontext_tearing_down</td><td>当应用的context tear down的时候触发</td></tr><tr><td>appcontext_pushed</td><td>当应用的context被push时触发</td></tr><tr><td>appcontext_popped</td><td>当应用的context被pop时触发</td></tr><tr><td>message_flashed</td><td>当应用发送flash message时触发</td></tr></tbody></table><p>之前的例子我们已经看到如何使用<code>request_started</code> signal了，这里需要说明两点：</p><ol><li>在定义回调函数时，第一个参数必须是sender对象（即发送该signal的对象），第二个参数**extra用于接受额外的参数，也防止将来Flask在发送signal时添加新的参数。</li><li>使用connect注册回调函数时，第一个参数是回调函数，这个是必须的，第二参数是sender对象，是可选的，但最佳实践是要明确发送该signal的对象</li></ol><p>另外，我们也可以临时性注册一个回调函数，这个尤其在进行单元测试时非常有用，因为我们不想在实际程序中添加测试相关的回调函数，因此需要一种机制在测试完成后，再取消注册该回调函数，有两种方式可以此种临时注册的机制：</p><ul><li>一种是通过<code>contextmanager</code>decorator和disconnect函数一起来实现，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from flask import template_rendered</span><br><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def captured_templates(app):</span><br><span class="line">    recorded = []</span><br><span class="line">    def record(sender, template, context, **extra):</span><br><span class="line">        recorded.append((template, context))</span><br><span class="line">    # 当使用with关键字进入with context时，自动注册record函数到template_rendered signal</span><br><span class="line">    template_rendered.connect(record, app)</span><br><span class="line">    try:</span><br><span class="line">        yield recorded</span><br><span class="line">    finally:</span><br><span class="line">        # with context结束时会自动调用disconnect函数来解除注册</span><br><span class="line">        template_rendered.disconnect(record, app)</span><br></pre></td></tr></table></figure></li></ul><p>使用时代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with captured_templates(app) as templates:</span><br><span class="line">    rv = app.test_client().get(&apos;/&apos;)</span><br><span class="line">    assert rv.status_code == 200</span><br><span class="line">    assert len(templates) == 1</span><br><span class="line">    template, context = templates[0]</span><br><span class="line">    assert template.name == &apos;index.html&apos;</span><br><span class="line">    assert len(context[&apos;items&apos;]) == 10</span><br></pre></td></tr></table></figure></p><ul><li>另外一种方式是使用connect_to函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask import template_rendered</span><br><span class="line"></span><br><span class="line">def captured_templates(app, recorded, **extra):</span><br><span class="line">    def record(sender, template, context):</span><br><span class="line">        recorded.append((template, context))</span><br><span class="line">    return template_rendered.connected_to(record, app)</span><br></pre></td></tr></table></figure></li></ul><p>使用时代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">templates = []</span><br><span class="line">with captured_templates(app, templates, **extra):</span><br><span class="line">    ...</span><br><span class="line">    template, context = templates[0]</span><br></pre></td></tr></table></figure></p><h3>自定义signals的使用</h3><h4>自定义signal</h4><p>当我们需要自定义signal时，我们可以直接使用blinker库</p><ol><li><p>首先定义一个namespace<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from blinker import Namespace</span><br><span class="line">my_signals = Namespace()</span><br></pre></td></tr></table></figure></p></li><li><p>使用我们自定义的namespace定义自己的signal<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload_image_finished = my_signals.signal(&apos;upload_image_finished&apos;)</span><br></pre></td></tr></table></figure></p></li></ol><p>至此，我们就定义了一个signal，名为<code>upload_image_finished</code></p><h4>发射自定义signal</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from flask import current_app</span><br><span class="line"></span><br><span class="line">def upload_image(image_path, upload_url):</span><br><span class="line">    # upload image code</span><br><span class="line">    ...</span><br><span class="line">    # after upload image</span><br><span class="line">    upload_image_finished.send(current_app._get_current_object())</span><br></pre></td></tr></table></figure></p><ul><li>当在类的method中使用send函数发射signal时，我们可以选择该类的对象作为sender对象，因此直接使用self作为参数，但是当我们不是在类的method当中，或者我们想让应用对象作为sender，那么我们就需使用如上代码所示的current_app._get_current_object()来获取应用对象</li><li>使用sender时，第一个参数是sender对象，是必选的。其余实际我们还可以传递更多参数(记得我们的callback函数使用了**extra), 这样的话我们实际就拥有了传递更多数据的能力。</li></ul><h3>注册回调函数的简化写法</h3><p>从文章的第一个示例可以看出我们需要通过调用connect函数来对回调函数进行注册, 其实还有一个简化的写法可以把回调函数的定义和注册过程结合在一起，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask import template_rendered</span><br><span class="line"></span><br><span class="line">@template_rendered.connect_via(app)</span><br><span class="line">def when_template_rendered(sender, template, context, **extra):</span><br><span class="line">    print &apos;Template %s is rendered with %s&apos; % (template.name, context)</span><br></pre></td></tr></table></figure></p><p>通过connect_via装饰器来简化回调函数定义和注册的过程</p><h2>Reference</h2><ul><li><a href="http://flask.pocoo.org/docs/0.12/signals/" target="_blank" rel="noopener">Flask Signals</a></li><li><a href="https://pythonhosted.org/blinker/" target="_blank" rel="noopener">Blinker Doc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flask Signals和操作系统的signals系统很类似，都是通过信号（也可以说是事件
event）来通知已经注册的回调函数，让回调函数自动开始执行。Flask定义了自己
的一套核心signals和对应的functions(用于发起消息，注册回调函数)，我们需要
定义
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask Restful API权限管理设计与实现</title>
    <link href="http://yoursite.com/2017/08/10/flask_restful_api/"/>
    <id>http://yoursite.com/2017/08/10/flask_restful_api/</id>
    <published>2017-08-10T08:21:18.000Z</published>
    <updated>2018-08-12T05:50:21.523Z</updated>
    
    <content type="html"><![CDATA[<p>在使用flask设计restful api的时候，有一个很重要的问题就是如何进行权限管理，以及如何进行角色的定义，在网上找了一下没有发现有类似的资料，虽然有些针对网站进行的权限管理设计，但是跟restful api接口的权限管理还是有很多不同的，于是乎自己动手，丰衣足食。为方便后来者，特撰此文！</p><h2>权限的设计</h2><p>从本质上思考，我需要为每个API接口设定相应的权限，所以针对API的权限列表跟普通网站的权限设计是不同的，普通网站的权限设计是针对某个功能，比如是否可以comment功能，通常的权限定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Permission:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    权限表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    COMMENT = 0x01  # 评论</span><br><span class="line">    MODERATE_COMMENT = 0x02  # 移除评论</span><br></pre></td></tr></table></figure></p><p>但是针对restful api，我们更希望权限是针对我们的api接口，而restful api接口是跟我们路由的endpoint以及http method相关的，所以我们的权限设计应该是类似如下示例中的样子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里comments是路由的endpoint，接口在判断用户是否有权限的时候</span><br><span class="line"># 可以先获取到endpoint和http method，然后就可以查看其是否有权限</span><br><span class="line">comment_permission = &#123;&quot;comments&quot;: &#123;&quot;post&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: False&#125;&#125;</span><br></pre></td></tr></table></figure></p><h2>角色的设计</h2><p>通常，我们在做网站的角色设计时会将角色存储在数据库当中，并会通过或运算(|)赋予角色以特定权限，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Role(db.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户角色</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    # 该用户角色名称</span><br><span class="line">    name = db.Column(db.String(164))</span><br><span class="line">    # 该用户角色是否为默认</span><br><span class="line">    default = db.Column(db.Boolean, default=False, index=True)</span><br><span class="line">    # 该用户角色对应的权限</span><br><span class="line">    permissions = db.Column(db.Integer)</span><br><span class="line">    # 该用户角色和用户的关系</span><br><span class="line">    # 角色为该用户角色的所有用户</span><br><span class="line">    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;, lazy=&apos;dynamic&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def insert_roles():</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        创建用户角色</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        roles = &#123;</span><br><span class="line">            # 定义了两个用户角色(User, Admin)</span><br><span class="line">            &apos;User&apos;: (Permission.COMMENT, True),</span><br><span class="line">            &apos;Admin&apos;: (Permission.COMMENT |</span><br><span class="line">                      Permission.MODERATE_COMMENT, False)</span><br><span class="line">        &#125;</span><br><span class="line">        for r in roles:</span><br><span class="line">            role = Role.query.filter_by(name=r).first()</span><br><span class="line">            if role is None:</span><br><span class="line">                # 如果用户角色没有创建: 创建用户角色</span><br><span class="line">                role = Role(name=r)</span><br><span class="line">            role.permissions = roles[r][0]</span><br><span class="line">            role.default = roles[r][1]</span><br><span class="line">            db.session.add(role)</span><br><span class="line">            db.session.commit()</span><br></pre></td></tr></table></figure></p><p>这里其实我一直没有搞明白，为什么要将角色存储于数据库当中，在我看来这只会导致更多的I/O操作从而影响系统的性能，因此我在设计角色的时候根本没有考虑存储到数据库中，角色的数据结构在系统运行时，直接存在内存当中，这样在接口调用时，可以直接使用角色相关的数据结构。而且由于我们的权限设计也不太相同，所以我针对restful api设计的Role如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">USER = 1</span><br><span class="line">ADMIN = 2</span><br><span class="line">VISITOR = 3</span><br><span class="line"></span><br><span class="line">Role = &#123;</span><br><span class="line">    USER: &#123;</span><br><span class="line">        &quot;comment&quot;: &#123;&quot;post&quot;: True, &quot;patch&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: True&#125;,</span><br><span class="line">        &quot;share&quot;: &#123;&quot;post&quot;: True&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ADMIN: &#123;</span><br><span class="line">        &quot;comment&quot;: &#123;&quot;post&quot;: True, &quot;patch&quot;: True, &quot;get&quot;: True, &quot;delete&quot;: True&#125;,</span><br><span class="line">        &quot;share&quot;: &#123;&quot;post&quot;: True&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    VISITOR: &#123;</span><br><span class="line">        &quot;comment&quot;: &#123;&quot;get&quot;: True&#125;,</span><br><span class="line">        &quot;share&quot;: &#123;&quot;post&quot;: True&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户可以被赋予特定的role，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userA = &#123;&quot;name&quot;: &quot;John&quot;, &quot;role&quot;: USER&#125;</span><br></pre></td></tr></table></figure></p><p>那么接口如何判断用户是否有权限访问呢？首先用户访问接口时都会带有用户信息，restful api一般是通过token来表明身份，系统通过token来获取用户的信息，比如用户名，然后我们可以通过用户名来获取用户的角色role，假设我们访问的接口是comments endpoint的post接口，那么就可以如下判断：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def access_control(user):</span><br><span class="line">    &quot;&quot;&quot;判断用户是否有访问权限，有就返回True，没有返回False&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # 首先要获取到API的endpoint和http method，此处代码省略</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    role = user.get(&apos;role&apos;, VISITOR)</span><br><span class="line">    try:</span><br><span class="line">        if not Role[role][endpoint][http_method]:</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br><span class="line">    except KeyError:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></p><p>由于基本所有的接口都需要access control，那么我们把上边的代码稍作改变，让它成为一个decorator，同时，user信息也可以直接获取而不需要从参数传递，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def get_role():</span><br><span class="line">    # 这里get_resource_by_name用于从数据库中获取该用户的信息，这个需要自己去定义</span><br><span class="line">    # 另外我们可以在登录验证的时候或者token验证的时候讲user name存储于全局变量g中，这样我们可以随时获取该用户名</span><br><span class="line">    user = UserModel.get_resource_by_name(g.user_name)</span><br><span class="line">    return user.get(&quot;role&quot;, VISITOR)</span><br><span class="line"></span><br><span class="line">def access_control(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def wrap_func(*args, **kwargs):</span><br><span class="line">        # 同样要先获取到API的endpoint和http method，此处代码省略</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            if not Role[role][endpoint][http_method]:</span><br><span class="line">                return make_response(</span><br><span class="line">                    jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403)</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line">        except KeyError:</span><br><span class="line">            return make_response(</span><br><span class="line">                jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403)</span><br><span class="line">    return wrap_func</span><br></pre></td></tr></table></figure></p><p>以下是一个获取图片resource的使用示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from flask_restful import Resource</span><br><span class="line"></span><br><span class="line">class ImageResource(Resource):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(ImageResource, self).__init__()</span><br><span class="line"></span><br><span class="line">    @token_auth.login_required</span><br><span class="line">    @access_control</span><br><span class="line">    def get(self, resource_id):</span><br><span class="line">        response = resource_get(resource_id)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure></p><p>这里另外一个decortor @token_auth.login_required用于token验证，大家可以先不用理会。到这里我们已经可以针对每个接口自动判断该用户是否有权限访问了，而所有权限的变化，都可以通过修改Role中的权限来进行更改，而不需要更改原来的代码，很爽吧，有木有？不过，笔者在项目中还遇到了另外一个问题，有时候针对一个接口所有的user都应该有权限，但是针对特定的resource，只能resource owner可以操作，举个栗子，比如我们要删除某个评论，但是只允许发布评论的人才有权限删除，也就是comment resource的owner才可以使用delete接口删除，但是我们所有的用户在Role定义的时候delete接口都是True，这个怎么办呢？这就需要我们在access_control检测完了之后再进一步检测该用户是否是resource owner，所以我们就需要进一步检测，这里添加一个decorator如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def get_resource_owner():</span><br><span class="line">    &quot;&quot;&quot;获取resource的owner&quot;&quot;&quot;</span><br><span class="line">    # 自定义，代码省略</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">def owner_permission_required(func):</span><br><span class="line">    @wrap(func)</span><br><span class="line">    def wrap_func(*args, **kwargs):</span><br><span class="line">        if g.user_name == get_resource_owner():</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line">        return make_response(</span><br><span class="line">            jsonify(&#123;&apos;error&apos;: &apos;no permission&apos;&#125;), 403)</span><br><span class="line">    return wrap_func</span><br></pre></td></tr></table></figure></p><p>使用如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask_restful import Resource</span><br><span class="line"></span><br><span class="line">class CommentResource(Resource):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(CommentResource, self).__init__()</span><br><span class="line"></span><br><span class="line">    @token_auth.login_required</span><br><span class="line">    @access_control</span><br><span class="line">    @owner_permission_required</span><br><span class="line">    @marshal_with(image_fields)</span><br><span class="line">    def delete(self, resource_id):</span><br><span class="line">        response = resource_delete(resource_id)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure></p><p>注意：decorator的顺序是不能改变的。</p><p>至此，Restful API权限管理相关的设计就完成了，如果文章给你带来了启发，记得点赞哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用flask设计restful api的时候，有一个很重要的问题就是如何进行权限管理，以及如何进行角色的定义，在网上找了一下没有发现有类似的资料，虽然有些针对网站进行的权限管理设计，但是跟restful api接口的权限管理还是有很多不同的，于是乎自己动手，丰衣足食。为
      
    
    </summary>
    
    
  </entry>
  
</feed>
